<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>語音報讀系統</title>
    <style>
	    html {
    touch-action: manipulation;
}
	     body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

select, input, button {
  font-size: 18px; /* Increase font size for better readability */
  padding: 15px; /* Increase padding for larger touch targets */
  margin-bottom: 20px;
  border-radius: 8px; /* Add rounded corners for a modern look */
  border: 2px solid #ccc; /* Add border for better visibility */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add subtle shadow for depth */
}

select {
  width: 20%; /* Increase width for better usability */
  z-index: 1900;
  position: fixed;
  right: 20px;
  top:5px;
}
#pdfContainer {
  margin-top: 55px; /* 設定頂部邊距為 55px */
}
  #prevPage, #nextPage {
    padding: 15px 30px; /* 增加內邊距以擴大觸控區域 */
    font-size: 18px; /* 增加字體大小以提高可讀性 */
    cursor: pointer;
    background-color: #007BFF; /* 添加背景色以提高可見性 */
    color: white; /* 將文字顏色改為白色 */
    border: none; /* 移除默認邊框 */
    transition: background-color 0.3s; /* 添加過渡效果以提高互動性 */
  }

  #prevPage:hover, #nextPage:hover {
    background-color: #0056b3; /* 懸停時更改背景色 */
  }
audio {
    width: 50%;
    bottom: 5px;
    z-index: 1000;
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
}
	.pdf-page-container {
            margin-bottom: 20px;
        }
        .pdf-viewer {
            position: relative;
        }
        canvas {
            display: block;
        }
        .textLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            color:rgba(255,255,255,0);
        }
        .textLayer > span {
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
        }
		  .no-select {
        user-select: none; /* 禁用反白選取 */
        -webkit-user-select: none; /* 禁用反白選取 for Safari */
        -moz-user-select: none; /* 禁用反白選取 for Firefox */
        -ms-user-select: none; /* 禁用反白選取 for Internet Explorer/Edge */
    }
    
    /* 模态窗口样式 */
    .modal {
      display: none;
      /* 默认隐藏 */
      position: fixed;
      z-index: 900;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    /* 遮罩层样式 */
    .modal-overlay {
      display: none;
      /* 默认隐藏 */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.05);
      z-index: 900;
    }

    /* 按钮样式 */
    .button {
      padding: 10px 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .button-secondary {
      background-color: #6c757d;
    }

    .button-success {
      background-color: #28a745;
    }

    .button-light {
      background-color: #ded520;
    }

    .button-danger {
      background-color: #dc3545;
      
    }
     
   my-fra {
            display: inline; /* 確保不影響排版 */
        }
 input[type=range] {
    -webkit-appearance: none;
    width: 300px;
    height: 20px;
    background: linear-gradient(145deg, #d4d4d4, #f0f0f0);
    border: 1px solid #b0b0b0;
    border-radius: 10px;
    outline: none;
    opacity: 0.9;
    -webkit-transition: .2s;
    transition: opacity .2s;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

input[type=range]::-moz-range-thumb {
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}
   #verticalDiv {
            position: fixed;
            top: 200px; /* 距離頂部50px */
            right: 15px; /* 距離右側0px */
            z-index: 1000;
            display: flex;
            flex-direction: column; /* 使內容縱向排列 */
            align-items: center; /* 內容置中 */	
			
        }

        #speakSpeed {
		
            z-index: 1000;
            transform: rotate(-90deg); /* 旋轉滑軌 */
            transform-origin: right center; /* 設置旋轉中心 */

        }
    </style>
	  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.js"></script>
</head>
<body tabindex="0">
	 <div class="container">
<div>
    <!-- 聲音選擇 -->  
    <select id="voiceSelect">
	選擇聲音：
      <option value="zh-TW-HsiaoChenNeural">中文：曉臻 (女性)</option>
      <option value="zh-TW-YunJheNeural">中文：允哲 (男性)</option>
      <option value="zh-TW-HsiaoYuNeural">中文：曉雨 (女性)</option>
      <option value="en-US-JennyNeural">英文：Jenny (女性)</option>
      <option value="en-US-GuyNeural">英文：Guy (男性)</option>
      <option value="en-US-AriaNeural">英文：Aria (女性)</option>
      <option value="en-US-ChristopherNeural">英文：Christ (男性)</option> 
    </select>
</div>
		  <!-- 語速調整 -->
 <div id="verticalDiv">	     
      <label for="speakSpeed" style="writing-mode: vertical-lr; position: fixed; top: 120px; right: 5px; color: rgb(134, 101, 224); font-size: 20px; font-weight: bold; text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px; height: 200px; display: flex; align-items: center;">
    <span id="speedLabel">語速加</span>
    <span id="speedPercent" style="writing-mode: horizontal-tb; margin-left: 5px;">0%</span>
</label>
      <input type="range" id="speakSpeed" name="rate" min="-50" max="50" value="-30" oninput="updateRate(this.value)" style="  width:20%;  padding: 10px;  margin-bottom: 20px; z-index:1000;right:15px;position: fixed;">
    </div>
    
    <!-- 音頻播放器 -->
    <audio id="audioPlayer" controls></audio>
  </div>
<div id="movable-frame"></div>
<input type="file" id="pdfFileInput" style=" width: 20%; /* Increase width for better usability */  z-index: 1900;  position: fixed;  left: 20px; top:5px;">
<div id="viewerContainer" tabindex="0">
    <center><div id="pdfContainer"></div></center>
</div>
	
<div class="pagination" style="width: 100%; top: 5px; z-index: 1000;  position: fixed;">
	<center>
    <button id="prevPage">上一頁</button>
    <span id="pageNumber"></span>
    <button id="nextPage">下一頁</button>
	</center>	
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>    
  <button id="select-all-text" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;right: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" >整頁朗讀</button>
  <!-- 页面遮罩 -->
  <div id="modalOverlay" class="modal-overlay"></div>

   <button id="sendButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;right: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">朗讀選取文字</button>
  <button id="clearButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;left: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">清除選取文字</button>
    <label style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; top: 300px;left: 2px; z-index: 1000;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;">
        <input type="checkbox" id="touchSelectCheckbox" style="writing-mode: vertical-rl; text-orientation: upright; width: 30px; height: 30px; position: fixed;left: 1px;top: 260px;">觸控選取</label>
  
     

<button  class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;left: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" onclick="redirectToNewPage()">切換載具語音</button>
<script>
// 移除 BroadcastChannel 相關代碼，替換為以下實現

// 頁數同步相關變量
let pageSyncTimeout = null;
const PAGE_SYNC_DELAY = 300; // 防抖延遲(毫秒)

// 修改 notifyPageChange 函數
function notifyPageChange(page) {
    // 更新 URL hash
    updateUrlHash(page);
    
    // 如果是 iframe 內嵌的情況，通知父窗口
    if (window !== window.top) {
        window.parent.postMessage({
            type: 'pageChange',
            page: page,
            source: 'pdfViewer'
        }, '*'); // 注意: 實際應用中應指定具體域名而非 '*'
    }
    
    // 更新 localStorage
    localStorage.setItem('currentPage', page);
}

//  更新URL hash (不觸發頁面刷新)
function updateUrlHash(page) {
    const newUrl = new URL(window.location.href);
    newUrl.hash = `page=${page}`;
    window.history.replaceState({}, '', newUrl);
}
// 獲取當前頁數 (從URL hash或localStorage)
function getPageFromHash() {
    const hash = window.location.hash.substring(1);
    const params = new URLSearchParams(hash);
    const pageFromHash = params.get('page') ? parseInt(params.get('page')) : null;
    
    // 從 localStorage 讀取作為備用
    const pageFromStorage = localStorage.getItem('currentPage') ? parseInt(localStorage.getItem('currentPage')) : 1;
    
    return pageFromHash || pageFromStorage;
}
// 切換網路語音時保留當前檔案和頁數
function redirectToNewPage() {
    const urlParams = new URLSearchParams(window.location.search);
    const params = new URLSearchParams();
    
    // 保留所有現有參數
    if (urlParams.get('file')) params.set('file', urlParams.get('file'));
    if (urlParams.get('googlesheetid')) params.set('googlesheetid', urlParams.get('googlesheetid'));
    
    // 構建新URL
    let newUrl = 'localvoice.html';
    if (params.toString()) newUrl += `?${params.toString()}`;
    
    // 保留當前頁數
    const currentPage = getPageFromHash();
    if (currentPage > 1) newUrl += `#page=${currentPage}`;
    
    window.location.href = newUrl;
}
// PDF.js 初始化
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

const pdfFileInput = document.getElementById('pdfFileInput');
const pdfContainer = document.getElementById('pdfContainer');
const prevPageButton = document.getElementById('prevPage');
const nextPageButton = document.getElementById('nextPage');
const pageNumberSpan = document.getElementById('pageNumber');

let pdfDoc = null;
let currentPage = 1;
    // 修改 renderPage 函數
function renderPage(pageNum) {
    if (!pdfDoc) return;
    
    pdfDoc.getPage(pageNum).then(page => {
        const screenWidth = window.innerWidth;
        const desiredWidth = screenWidth * 0.8;
        const viewport = page.getViewport({ scale: 1 });
        const scale = desiredWidth / viewport.width;

        const scaledViewport = page.getViewport({ scale: scale });

        pdfContainer.innerHTML = '';

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';

        const pdfViewer = document.createElement('div');
        pdfViewer.className = 'pdf-viewer';

        const pdfCanvas = document.createElement('canvas');
        const context = pdfCanvas.getContext('2d');

        const dpi = window.devicePixelRatio || 1;
        pdfCanvas.height = scaledViewport.height * dpi;
        pdfCanvas.width = scaledViewport.width * dpi;
        context.scale(dpi, dpi);

        pdfCanvas.style.height = `${scaledViewport.height}px`;
        pdfCanvas.style.width = `${scaledViewport.width}px`;

        pdfViewer.style.height = scaledViewport.height + 'px';
        pdfViewer.style.width = scaledViewport.width + 'px';

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';

        pageContainer.appendChild(pdfViewer);
        pdfViewer.appendChild(pdfCanvas);
        pdfViewer.appendChild(textLayerDiv);
        pdfContainer.appendChild(pageContainer);

        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };
        page.render(renderContext);

        page.getTextContent().then(textContent => {
            textLayerDiv.innerHTML = '';
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: scaledViewport,
            });
            textLayerDiv.style.top = '-4px';
        });

        pageNumberSpan.textContent = `Page ${pageNum} of ${pdfDoc.numPages}`;
        
         // 更新hash但不觸發hashchange
    const currentHash = window.location.hash;
    const newHash = `page=${pageNum}`;
    if (currentHash !== newHash) {
        const newUrl = new URL(window.location.href);
        newUrl.hash = newHash;
        window.history.replaceState({}, '', newUrl);
    }
    });
}

	
// Google Apps Script 代理 URL
const gasUrl = 'https://script.google.com/macros/s/AKfycbyDDM097ofMimASd_KdrF-TrDWr0TaMLJwbiHGwcJFvjrOi0HpT28IIqg1dj5os9NzZ/exec'; // 替換為你的 GAS 部署 URL


// 打開 IndexedDB 資料庫
const openDB = () => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('pdfDB', 1);
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('pdfFiles')) {
                db.createObjectStore('pdfFiles', { keyPath: 'id' });
            }
        };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
    });
};

// 保存檔案到 IndexedDB
const saveFileToIndexedDB = async (file) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        store.put({ id: 'currentPdf', file });
    } catch (error) {
        console.error('保存檔案到 IndexedDB 失敗：', error);
        throw error;
    }
};

// 從 IndexedDB 讀取檔案
const loadFileFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readonly');
        const store = transaction.objectStore('pdfFiles');
        const request = store.get('currentPdf');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.file);
                } else {
                    reject(new Error('IndexedDB 中未找到檔案'));
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('從 IndexedDB 讀取檔案失敗：', error);
        throw error;
    }
};

// 清空 IndexedDB 中的檔案
const clearIndexedDB = async (forceClear = false) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        if (forceClear) {
            store.delete('currentPdf');
        }
        updateUrl(null);
    } catch (error) {
        console.error('清除 IndexedDB 失敗：', error);
    }
};

// 更新網址中的檔案名稱

function updateUrl(fileName) {
    const newUrl = new URL(window.location.href);
    if (fileName) {
        newUrl.searchParams.set('file', fileName); // 不使用 encodeURIComponent
    } else {
        newUrl.searchParams.delete('file');
    }
    window.history.replaceState({}, '', newUrl);
}

// 從 Google 雲端硬碟載入 PDF 檔案
async function loadPdfFromDrive(fileId, showLoading = true) {
    // 檢查是否是本地檔案名稱（包含 .pdf 結尾）
    if (fileId && fileId.toLowerCase().endsWith('.pdf')) {
        // 如果是本地檔案名稱，直接返回不處理
        return;
    }

    const url = `${gasUrl}?fileId=${fileId}`;
    
    try {
        if (showLoading) {
            Swal.fire({
                title: '載入中請稍候',
                text: '正在從雲端硬碟載入檔案...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
        }

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Failed to fetch file');
        }
        const data = await response.json();
        const fileContent = atob(data.fileContent);
        const arrayBuffer = new ArrayBuffer(fileContent.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < fileContent.length; i++) {
            uint8Array[i] = fileContent.charCodeAt(i);
        }
        const blob = new Blob([uint8Array], { type: 'application/pdf' });
        const file = new File([blob], data.fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        const typedarray = new Uint8Array(arrayBuffer);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
            pdfDoc = pdf;
            renderPage(currentPage);
            updateUrl(fileId);
            if (showLoading) {
                Swal.close();
            }
        }).catch(error => {
            console.error('PDF 檔案載入失敗：', error);
            Swal.fire({
                icon: 'error',
                title: '載入失敗',
                text: '無法載入 PDF 檔案，請檢查檔案是否正確或未開放瀏覽。',
            });
        });
    } catch (error) {
        console.error('載入 Google 雲端硬碟 PDF 檔案失敗：', error);
        if (showLoading) {
            Swal.fire({
                icon: 'error',
                title: '載入失敗',
                text: '無法載入 PDF 檔案，請檢查檔案 ID 是否正確或未開放瀏覽。',
            });
        }
    }
}
// 當頁面載入時，檢查網址中的檔案名稱

// 修改頁面初始化部分
window.addEventListener('load', async () => {
    // 從 URL hash 或 localStorage 讀取初始頁數
    currentPage = getPageFromHash();
    
    // 原有的初始化代碼...
    const urlParams = new URLSearchParams(window.location.search);
    const fileParam = urlParams.get('file');
    const previousUrl = sessionStorage.getItem('previousUrl');
    const currentUrl = window.location.href;

    // 判斷是否為頁面重新整理
    const isPageRefresh = previousUrl === currentUrl;

    // 判斷 URL 是否以 .pdf 結尾（本地檔案）
    const isLocalPdfFile = fileParam && fileParam.toLowerCase().endsWith('.pdf');

    if (fileParam) {
        if (fileParam.startsWith('http://') || fileParam.startsWith('https://')) {
            // 處理網路 PDF 檔案
            await clearIndexedDB();
            loadPdfFromUrl(fileParam);
        } else if (isLocalPdfFile) {
            // 處理本地 PDF 檔案
            try {
                const file = await loadFileFromIndexedDB();
                if (file && file.name === fileParam) {
                    console.log('當前檔案與 URL 中的本地檔案相同，從 IndexedDB 載入');
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                            pdfDoc = pdf;
                            renderPage(currentPage);
                        }).catch(error => {
                            console.error('PDF 檔案載入失敗：', error);
                            alert('無法載入 PDF 檔案，請檢查檔案是否正確或未開放瀏覽。');
                        });
                    };
                    fileReader.onerror = function() {
                        console.error('檔案讀取失敗：', fileReader.error);
                        alert('檔案讀取失敗，請重試。');
                    };
                    fileReader.readAsArrayBuffer(file);
                } else {
                    console.log('IndexedDB 中沒有匹配的本地檔案，清除 URL 參數');
                    updateUrl(null);
                }
            } catch (error) {
                console.error('讀取本地檔案失敗：', error);
                updateUrl(null);
            }
        } else {
            // 處理 Google 雲端硬碟檔案
            try {
                const file = await loadFileFromIndexedDB();
                if (file) {
                    if (file.name === fileParam) {
                        console.log('當前檔案與 URL 中的檔案相同，跳過重新載入。');
                        const fileReader = new FileReader();
                        fileReader.onload = function() {
                            const typedarray = new Uint8Array(this.result);
                            pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                                pdfDoc = pdf;
                                renderPage(currentPage);
                            }).catch(error => {
                                console.error('PDF 檔案載入失敗：', error);
                                alert('無法載入 PDF 檔案，請檢查檔案是否正確或未開放瀏覽。');
                            });
                        };
                        fileReader.onerror = function() {
                            console.error('檔案讀取失敗：', fileReader.error);
                            alert('檔案讀取失敗，請重試。');
                        };
                        fileReader.readAsArrayBuffer(file);
                    } else {
                        await clearIndexedDB();
                        await saveFileToIndexedDB(file);
                        updateUrl(file.name);
                    }
                } else {
                    await loadPdfFromDrive(fileParam, !isPageRefresh);
                }
            } catch (error) {
                console.error('讀取檔案失敗：', error);
                await loadPdfFromDrive(fileParam, !isPageRefresh);
            }
        }
    }

    // 更新 sessionStorage 中的 previousUrl
    sessionStorage.setItem('previousUrl', currentUrl);
});

//  監聽頁數變化事件
window.addEventListener('hashchange', function() {
    const newPage = getPageFromHash();
    if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
        currentPage = newPage;
        renderPage(currentPage);
    }
});

// 當使用者選擇檔案時
pdfFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        try {
            await clearIndexedDB(true);
            await saveFileToIndexedDB(file);
            
            // 更新 URL 參數，標記為本地檔案
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('file', file.name);
            window.history.replaceState({}, '', newUrl);
            
            const fileReader = new FileReader();
            fileReader.onload = function() {
                const typedarray = new Uint8Array(this.result);
                pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                    pdfDoc = pdf;
                    currentPage = 1; // 重置為第一頁
                    renderPage(currentPage);
                }).catch(error => {
                    console.error('PDF 檔案載入失敗：', error);
                    alert('無法載入 PDF 檔案，請檢查檔案是否正確或未開放瀏覽。');
                });
            };
            fileReader.onerror = function() {
                console.error('檔案讀取失敗：', fileReader.error);
                alert('檔案讀取失敗，請重試。');
            };
            fileReader.readAsArrayBuffer(file);
        } catch (error) {
            console.error('保存檔案失敗：', error);
            alert('保存檔案失敗，請重試。');
        }
    } else {
        updateUrl(null);
    }
});

// 修改 loadPdfFromDrive 函數，增加對本地檔案的檢查
async function loadPdfFromDrive(fileId, showLoading = true) {
    // 檢查是否是本地檔案名稱（包含 .pdf 結尾）
    if (fileId && fileId.toLowerCase().endsWith('.pdf')) {
        console.log('檢測到本地檔案名稱，跳過 Google 雲端硬碟載入');
        return;
    }

    const url = `${gasUrl}?fileId=${fileId}`;
    
    try {
        if (showLoading) {
            Swal.fire({
                title: '載入中請稍候',
                text: '正在從雲端硬碟載入檔案...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
        }

        const response = await fetch(url);
        if (!response.ok) {
            throw new Error('Failed to fetch file');
        }
        const data = await response.json();
        const fileContent = atob(data.fileContent);
        const arrayBuffer = new ArrayBuffer(fileContent.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < fileContent.length; i++) {
            uint8Array[i] = fileContent.charCodeAt(i);
        }
        const blob = new Blob([uint8Array], { type: 'application/pdf' });
        const file = new File([blob], data.fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        const typedarray = new Uint8Array(arrayBuffer);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
            pdfDoc = pdf;
            renderPage(currentPage);
            updateUrl(fileId);
            if (showLoading) {
                Swal.close();
            }
        }).catch(error => {
            console.error('PDF 檔案載入失敗：', error);
            Swal.fire({
                icon: 'error',
                title: '載入失敗',
                text: '無法載入 PDF 檔案，請檢查檔案是否正確或未開放瀏覽。',
            });
        });
    } catch (error) {
        console.error('載入 Google 雲端硬碟 PDF 檔案失敗：', error);
        if (showLoading) {
            Swal.fire({
                icon: 'error',
                title: '載入失敗',
                text: '無法載入 PDF 檔案，請檢查檔案 ID 是否正確或未開放瀏覽。',
            });
        }
    }
}
// 上一頁和下一頁按鈕的事件監聽
// 修改上一頁/下一頁按鈕事件
prevPageButton.addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        notifyPageChange(currentPage);
    }
});

nextPageButton.addEventListener('click', () => {
    if (pdfDoc && currentPage < pdfDoc.numPages) {
        currentPage++;
        renderPage(currentPage);
        notifyPageChange(currentPage);
    }
});
// 監聽跨網域消息
window.addEventListener('message', function(event) {
    if (event.data?.type === 'pageChange' && event.data.source !== 'pdfViewer') {
        const newPage = event.data.page;
        if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
            currentPage = newPage;
            renderPage(currentPage);
            updateUrlHash(currentPage);
        }
    }
});


// 從 URL 參數中讀取 PDF 檔案的 ID
const urlParams = new URLSearchParams(window.location.search);
const fileId = urlParams.get('file');
if (fileId) {
    loadPdfFromDrive(fileId);
}

</script>
 <script>
  
  let selectedFile = null;  
  let isListening = true; // 初始設置為監聽模式
  let isReading = false; // 初始設置為未閱讀狀態
  let audioPlayer = null;
  document.addEventListener('DOMContentLoaded', () => {
    audioPlayer = document.getElementById('audioPlayer');
    
    const findInput = document.getElementById('findInput'); // 獲取輸入欄位
    const findEntireWord = document.getElementById('findEntireWord'); // 獲取 Whole Words 勾選框
    let isFinding = false; // 用於追蹤是否有未完成的查找操作

    // 函數: 發送選中的文本到新的 TTS API 進行處理

        function getSheetIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('googlesheetid');
        }

        function fetchSheetData(sheetId) {
    const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?`;
    const query = encodeURIComponent('Select B, C'); // 明確只選 B 和 C 欄
    const url = `${base}&tq=${query}`;

    return fetch(url)
        .then(res => res.text())
        .then(rep => {
            const jsonStr = rep.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/)[1];
            const data = JSON.parse(jsonStr);
            console.log("確認欄位對應:", data.table.rows[0].c); // 應為 [B欄, C欄]
            return data;
        })
        .catch(err => {
            console.error('載入失敗:', err);
            return null;
        });
}

function replaceTextWithSheetData(text, data) {
    if (!data) return text;
    data.table.rows.forEach(row => {
        const original = row.c[0]?.v; // B欄 (因為只選了 B 和 C)
        const replacement = row.c[1]?.v; // C欄
        if (original && replacement) {
            text = text.replace(new RegExp(original, "g"), replacement);
        }
    });
    return text;
}
 async function sendTextToTTS(selectedText, callback) {
    const cleanedText = selectedText.replace(/\s+/g, '');
    let filteredText = cleanedText; // Initialize with cleanedText as fallback
    
    const sheetId = getSheetIdFromUrl();
    if (sheetId) {
        const data = await fetchSheetData(sheetId);
        filteredText = replaceTextWithSheetData(cleanedText, data);
    }
    
    console.log("送出給 TTS 的文本:", filteredText);
    // 獲取選擇的聲音和語速
    const voiceName = document.getElementById("voiceSelect").value;
    const ratePercent = parseFloat(document.getElementById('speakSpeed').value); // 使用百分比

    // 生成 SSML
    const ssml = createSSML(filteredText, voiceName, ratePercent);

    // 發送請求到 TTS API
    fetch('/api/ra', {
        method: 'POST',
        headers: {
            'Content-Type': 'text/plain',
            'Format': 'audio-24khz-96kbitrate-mono-mp3',
        },
        body: ssml,
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`請求失敗：${response.statusText}`);
        }
        return response.blob();
    })
    .then(audioBlob => {
        const audioUrl = URL.createObjectURL(audioBlob);
        const audioPlayer = document.getElementById('audioPlayer');
        audioPlayer.src = audioUrl;
        audioPlayer.play(); // 自動播放

        // 設置音頻播放完成後的回調
        audioPlayer.onended = callback;
    })
    .catch(error => {
        console.error('發生錯誤：', error);
        alert('無法播放語音，請檢查網絡連接或稍後重試。');
    });
}

        function createSSML(text, voiceName, ratePercent) {
            return `
                <speak xmlns="http://www.w3.org/2001/10/synthesis" version="1.0" xml:lang="zh-CN">
                  <voice name="${voiceName}">
                    <prosody rate="${ratePercent}%">
                      ${text}
                    </prosody>
                  </voice>
                </speak>
            `;
        }

        const selectAllTextButton = document.getElementById('select-all-text');
        let sentences = [];
        let currentSentenceIndex = 0;
        let isReading = false;

        selectAllTextButton.addEventListener('click', function() {
            clearHighlights();
            if (isReading) {
                // 取消朗讀
                cancelReading();
            } else {
                // 開始朗讀
                const pdfContainer = document.getElementById('pdfContainer');
                const textLayers = pdfContainer.getElementsByClassName('textLayer');
                let fullText = '';

                for (let textLayer of textLayers) {
                    const spans = textLayer.getElementsByTagName('span');
                    for (let span of spans) {
                        fullText += span.textContent + ' ';
                    }
                }

                const cleanedText = fullText.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
                sentences = cleanedText.split(/(?<=[。！？])/); // 根據標點符號分句
                currentSentenceIndex = 0;
                isReading = true;

                // 立即更新按鈕樣式和文本
                selectAllTextButton.textContent = "取消朗讀";
                selectAllTextButton.classList.remove('button-light');
                selectAllTextButton.classList.add('button-danger');

                startReading(); // 直接開始朗讀
            }
        });

function cancelReading() {
  isReading = false;
  audioPlayer.pause();
  audioPlayer.currentTime = 0;
  selectAllTextButton.textContent = "整頁朗讀";
  selectAllTextButton.classList.remove('button-danger');
  selectAllTextButton.classList.add('button-light');
  
  // 清除所有標示
  const textLayerDivs = document.querySelectorAll('#viewerContainer .textLayer my-fra');
  textLayerDivs.forEach(span => {
    span.style.backgroundColor = ''; // 清除標示
  });

  // 清除事件監聽器
  audioPlayer.onended = null;
}

function startReading() {
    if (sentences.length > 0) {
        readNextSentence();
    } else {
        console.error('沒有可朗讀的句子');
    }
}

function readNextSentence() {
    if (isReading && currentSentenceIndex < sentences.length) {
        const sentence = sentences[currentSentenceIndex];
        highlightCurrentSentence(sentence);
        sendTextToTTS(sentence, function() {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                readNextSentence();
            } else {
                isReading = false;
                clearHighlights();
                selectAllTextButton.textContent = "整頁朗讀";
                selectAllTextButton.classList.remove('button-danger');
                selectAllTextButton.classList.add('button-light');
            }
        });
    }
}

function highlightCurrentSentence(sentence) {
    const pdfContainer = document.getElementById('pdfContainer');
    const textLayers = pdfContainer.getElementsByClassName('textLayer');
    let spansArray = []; // 存儲所有 <my-fra> 標籤

    // 將所有 <my-fra> 標籤存儲到數組中，並按順序排列
    for (let textLayer of textLayers) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            spansArray.push(span);
        }
    }

    // 清除前一句的標示
    for (let span of spansArray) {
        span.style.backgroundColor = ''; // 清除背景顏色
    }

    // 按斷句符號分段
    const sentences = sentence.split(/([。！？])/); // 根據句號、問號、驚嘆號分段
    const cleanedSentences = [];
    for (let i = 0; i < sentences.length; i += 2) {
        const sentenceText = sentences[i] + (sentences[i + 1] || ''); // 將斷句符號與句子合併
        const cleanedSentence = sentenceText.replace(/\s+/g, ''); // 去除空白字符
        if (cleanedSentence) {
            cleanedSentences.push(cleanedSentence);
        }
    }

    // 按順序標示每個句子
    let currentIndex = 0; // 當前遍歷到的字符索引
    for (let s = 0; s < cleanedSentences.length; s++) {
        const cleanedSentence = cleanedSentences[s];
        let sentenceIndex = 0; // 用於追蹤當前句子字符位置

        // 從當前索引開始，尋找匹配的字符
        while (currentIndex < spansArray.length && sentenceIndex < cleanedSentence.length) {
            const span = spansArray[currentIndex];
            const char = span.textContent.trim(); // 去除字符前後空白

            // 如果字符是空白字符，則跳過
            if (char === '') {
                currentIndex++;
                continue;
            }

            // 如果字符匹配
            if (char === cleanedSentence[sentenceIndex]) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // 高亮顯示
                sentenceIndex++;
            } else {
                // 如果字符不匹配，則清除當前句子的高亮
                for (let i = currentIndex - sentenceIndex; i < currentIndex; i++) {
                    spansArray[i].style.backgroundColor = ''; // 清除背景顏色
                }
                sentenceIndex = 0; // 重置句子索引
            }

            currentIndex++; // 移動到下一個字符
        }

        // 如果句子標示完成，則繼續下一個句子
        if (sentenceIndex >= cleanedSentence.length) {
            console.log(`句子 ${s + 1} 標示完成: ${cleanedSentence}`);
        } else {
            console.error(`句子 ${s + 1} 標示失敗: ${cleanedSentence}`);
        }
    }
}
// 可移動框的功能
const frame = document.getElementById('movable-frame');
let isDragging = false;
let startX, startY;

// Add CSS styles for frame and resize buttons
const style = document.createElement('style');
style.innerHTML = `
  #movable-frame {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 6px solid red;
    background-color: transparent;
    border-radius: 15px; /* Adjust the value to change the roundness */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */   
    z-index: 2000;
}
 .resize-button {
    position: absolute;
    width: 0;
    height: 0;
    cursor: pointer;
    z-index: 2000;
  } 
  #resize-bottom {
    width: 80px;
    height: 50px;
    background-color: orange;
    border-radius: 0 0 50px 50px; /* Bottom half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */   
    z-index: 2000;
  }
  #resize-right {
    width: 50px;
    height: 80px;
    background-color: orange;
    border-radius: 0 50px 50px 0; /* Right half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */
    white-space: pre-wrap; /* Allow text to wrap */   
    z-index: 2000;
  }
  #read-button {
    position: absolute;
    padding: 5px 10px;
    background-color: orange;
    color: blue;
    border: none;
    cursor: pointer;
    z-index: 2000;
    width: 90px;
    height: 40px;
    font-size:15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    border-top-left-radius: 15px; /* Top-left corner roundness */
    border-top-right-radius: 15px; /* Top-right corner roundness */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Text shadow */    
  }
`;
document.head.appendChild(style);

// Add resize buttons
const buttons = [
  { direction: 'bottom' },
  { direction: 'right' }
];
buttons.forEach(({ direction }) => {
  const button = document.createElement('div');
  button.classList.add('resize-button');
  button.id = `resize-${direction}`;
  document.body.appendChild(button);
});

// Add read button
const readButton = document.createElement('button');
readButton.id = 'read-button';
readButton.textContent = '框選朗讀';
document.body.appendChild(readButton);

function initializeFramePosition() {
  const frame = document.getElementById('movable-frame');
  frame.style.top = `${frame.offsetTop + 90}px`; // 向上移動 40px
  frame.style.left = `${frame.offsetLeft - 20}px`; // 向上移動 40px
}

// 更新按鈕位置
function updateButtonPositions() {
  const frame = document.getElementById('movable-frame');

  document.getElementById('resize-bottom').style.top = `${frame.offsetTop + frame.offsetHeight}px`;
  document.getElementById('resize-bottom').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 40}px`; // Adjusted for new width
  document.getElementById('resize-right').style.top = `${frame.offsetTop + frame.offsetHeight / 2 - 40}px`; // Adjusted for new height
  document.getElementById('resize-right').style.left = `${frame.offsetLeft + frame.offsetWidth}px`;
  document.getElementById('read-button').style.top = `${frame.offsetTop - 40}px`; // Position above the frame
  document.getElementById('read-button').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 45}px`; // Centered above the frame

  // Add text to the buttons
  document.getElementById('resize-bottom').textContent = '↕';
  document.getElementById('resize-right').textContent = '↔';

  // Center the text within the buttons
  document.getElementById('resize-bottom').style.display = 'flex';
  document.getElementById('resize-bottom').style.alignItems = 'center';
  document.getElementById('resize-bottom').style.justifyContent = 'center';
  
  document.getElementById('resize-right').style.display = 'flex';
  document.getElementById('resize-right').style.alignItems = 'center';
  document.getElementById('resize-right').style.justifyContent = 'center';
}

// 初始化框的位置
initializeFramePosition();

frame.addEventListener('mousedown', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  startX = e.clientX - frame.offsetLeft;
  startY = e.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('mousemove', (e) => {
  if (isDragging) {
    frame.style.left = `${e.clientX - startX}px`;
    frame.style.top = `${e.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});

frame.addEventListener('touchstart', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  const touch = e.touches[0];
  startX = touch.clientX - frame.offsetLeft;
  startY = touch.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('touchmove', (e) => {
  if (isDragging) {
    const touch = e.touches[0];
    frame.style.left = `${touch.clientX - startX}px`;
    frame.style.top = `${touch.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('touchend', () => {
  isDragging = false;
});

// Read button click event
readButton.addEventListener('click', readTextInsideFrame);

updateButtonPositions();
 

async function readTextInsideFrame() {
  // 取消所有正在進行的語音朗讀
  window.speechSynthesis.cancel();
  
  // 獲取框選區域和PDF查看器的位置信息
  const frameRect = frame.getBoundingClientRect();
  const viewerContainer = document.getElementById('viewerContainer');
  const textLayerDivs = viewerContainer.getElementsByClassName('textLayer');
  const pdfCanvas = viewerContainer.querySelector('canvas');

  // 清除之前的高亮標記
  for (let textLayer of textLayerDivs) {
    const spans = textLayer.getElementsByTagName('my-fra');
    for (let span of spans) {
      span.style.backgroundColor = '';
    }
  }

  let textInsideFrame = '';
  let hasText = false;

  // 第一步：嘗試從文字層提取文字
  for (let textLayer of textLayerDivs) {
    const spans = textLayer.getElementsByTagName('my-fra');
    for (let span of spans) {
      const spanRect = span.getBoundingClientRect();
      if (isInsideFrame(spanRect, frameRect)) {
        // 標記選中的文字區域
        span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
        textInsideFrame += span.textContent + ' ';
        hasText = true;
      }
    }
  }

  // 第二步：如果沒有找到文字，嘗試使用OCR識別
  if (!hasText && pdfCanvas) {
    try {
      // 顯示載入提示框
      Swal.fire({
    title: '正在識別文字',
    text: '正在處理圖片中的文字內容...',
    allowOutsideClick: false,
    didOpen: () => {
        Swal.showLoading();
        // 直接修改 style
        const popup = Swal.getPopup();
        popup.style.zIndex = '999999';
    }

      });

      // 裁剪選定區域的畫布
      const croppedCanvas = cropCanvas(pdfCanvas, frameRect);
      
      // 使用Tesseract進行OCR識別
      const { data: { text } } = await Tesseract.recognize(
        croppedCanvas,
        'chi_tra+chi_sim', // 使用繁體中文+簡體中文模型
        {
          logger: m => console.log(m),
          tessedit_char_whitelist: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,!?()%+-=/:;', // 限制識別字符集
          preserve_interword_spaces: '1', // 保留單詞間空格
          tessedit_pageseg_mode: '10' // 使用稀疏文字識別模式
        }
      );
      
      textInsideFrame = text;
      // 關閉提示框
      Swal.close();
    } catch (error) {
      console.error('OCR識別失敗:', error);
      Swal.fire({
        icon: 'error',
        title: '識別失敗', 
        text: '無法識別圖片中的文字內容'
      });
      return;
    }
  }

  // 清理識別出的文字內容
  const cleanedText = textInsideFrame
    .trim()
    .replace(/[\r\n]+/g, ' ') // 替換換行符
    .replace(/\s{2,}/g, ' ')  // 合併多餘空格
    .trim();
  
  // 如果有識別到文字，則進行語音朗讀
  if (cleanedText) {
    sendTextToTTS(cleanedText, function() {
      // 朗讀結束後的回調函數
      isReading = false;
      selectAllTextButton.textContent = "整頁朗讀";
      selectAllTextButton.classList.remove('button-danger');
      selectAllTextButton.classList.add('button-light');
    });
    
    // 更新按鈕狀態
    selectAllTextButton.textContent = "取消朗讀";
    selectAllTextButton.classList.remove('button-light');
    selectAllTextButton.classList.add('button-danger'); 
    isReading = true;
  } else {
    // 沒有找到任何文字時的提示
    Swal.fire({
      icon: 'warning',
      title: '未發現文字',
      text: '在選定區域內沒有找到可識別的文字內容'
    });
  }
}

// 輔助函數：判斷元素是否在框選區域內
function isInsideFrame(elementRect, frameRect) {
  return (
    elementRect.top >= frameRect.top &&
    elementRect.bottom <= frameRect.bottom &&
    elementRect.left >= frameRect.left &&
    elementRect.right <= frameRect.right
  );
}

// 輔助函數：裁剪Canvas區域
function cropCanvas(sourceCanvas, cropRect) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // 考慮設備像素比進行精確裁剪
  const dpr = window.devicePixelRatio || 1;
  const cropX = (cropRect.left - sourceCanvas.getBoundingClientRect().left) * dpr;
  const cropY = (cropRect.top - sourceCanvas.getBoundingClientRect().top) * dpr;
  const cropWidth = cropRect.width * dpr;
  const cropHeight = cropRect.height * dpr;
  
  // 設置新Canvas尺寸
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  
  // 執行裁剪操作
  ctx.drawImage(
    sourceCanvas,
    cropX, cropY, cropWidth, cropHeight,
    0, 0, cropWidth, cropHeight
  );
  
  return canvas;
}
  let lastTouchElement = null;

 function wrapTextInFraTags() {
    const markedContentSpans = document.querySelectorAll('span[role="presentation"]');
    
    markedContentSpans.forEach(span => {
        if (!span.dataset.processed) {
            const text = span.textContent;
            const fragment = document.createDocumentFragment();
            
            for (let char of text) {
                const fra = document.createElement('my-fra');
                fra.textContent = char;
                fra.style.cursor = 'pointer'; // 內聯樣式
                fra.addEventListener('touchstart', highlightText);
                fra.addEventListener('touchmove', highlightText);
                fra.addEventListener('mousedown', startHighlight); // 新增滑鼠事件
                fra.addEventListener('mousemove', highlightText); // 新增滑鼠事件
                fragment.appendChild(fra);
            }
            
            span.innerHTML = '';
            span.appendChild(fragment);
            span.dataset.processed = 'true';
        }
    });
}
let isMouseDown = false;

function startHighlight(event) {
    isMouseDown = true;
    highlightText(event);
}

document.addEventListener('mouseup', () => {
    isMouseDown = false;
});
     function highlightText(event) {
     
    if (!document.getElementById('touchSelectCheckbox').checked) return; // 檢查核取方塊是否被選中
    if (event.type === 'mousemove' && !isMouseDown) return; // 只有在按住滑鼠左鍵時才觸發
    
   event.preventDefault(); // 防止平板左右或上下捲動
    
    let element;
    if (event.type === 'touchstart' || event.type === 'touchmove') {
        const touch = event.touches[0];
        element = document.elementFromPoint(touch.clientX, touch.clientY);
    } else if (event.type === 'mousedown' || event.type === 'mousemove') {
        element = event.target;
    }
    
    if (element && element.tagName === 'MY-FRA') {
        if (element !== lastTouchElement) {
            if (element.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                element.style.backgroundColor = ''; // 取消選取
            } else if (element.style.backgroundColor === 'rgba(255, 255, 0, 0.2)') {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // 重新選取
                element.dataset.spoken = ''; // 取消已發音標記
            } else {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // 改變背景顏色
            }
            lastTouchElement = element;
        }
    }
}
        function sendHighlightedText() {
            const highlightedText = [];
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                    if (span.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                        highlightedText.push(span.textContent);
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // 已發音的標示
                        span.dataset.spoken = 'true'; // 標記為已發音
                    }
                }
            }
            
            const cleanedText = highlightedText.join('').trim().replace(/[\r\n]+/g, '').replace(/\s+/g, ' ').trim();
            sendTextToTTS(cleanedText);
        }

        function clearHighlights() {
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                window.speechSynthesis.cancel();
                    span.style.backgroundColor = ''; // 清除背景顏色
                    span.dataset.spoken = ''; // 清除已發音標記
                }
            }
        }

        document.getElementById('sendButton').addEventListener('click', sendHighlightedText);
        document.getElementById('clearButton').addEventListener('click', clearHighlights);
        document.getElementById('touchSelectCheckbox').addEventListener('change', function() {
            const isChecked = this.checked;
            clearHighlights();            
            document.getElementById('sendButton').style.display = isChecked ? 'block' : 'none';
            document.getElementById('clearButton').style.display = isChecked ? 'block' : 'none';                        
            document.getElementById('select-all-text').style.display = isChecked ? 'none' : 'block';            
            document.getElementById('movable-frame').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-bottom').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-right').style.display = isChecked ? 'none' : 'block';
            document.getElementById('read-button').style.display = isChecked ? 'none' : 'block';
            
            if (!isChecked) {
            updateButtonPositions();            
            }
        });
        wrapTextInFraTags();
        
        document.getElementById('sendButton').addEventListener('click', function() {
    if (isReading) {
        // 取消朗讀
        window.speechSynthesis.cancel();
        this.textContent = "朗讀選取文字";
        this.classList.remove('button-danger');
        this.classList.add('button-light');
        isReading = false;
    } else {
        // 開始朗讀
        sendHighlightedText();
        this.textContent = "取消朗讀";
        this.classList.remove('button-light');
        this.classList.add('button-danger');
        isReading = true;
    }
});
  
// 使用 MutationObserver 監聽 DOM 變化
const observer = new MutationObserver((mutationsList, observer) => {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            wrapTextInFraTags();
        }
    }
});

// 配置 MutationObserver 監聽的目標節點和選項
const config = { childList: true, subtree: true };

// 監聽整個 document 的變化
observer.observe(document, config);

// 確保在 DOM 完全加載後執行
document.addEventListener('DOMContentLoaded', wrapTextInFraTags);
document.getElementById('resize-bottom').addEventListener('mousedown', (e) => resizeFrame(e, 'bottom'));
document.getElementById('resize-right').addEventListener('mousedown', (e) => resizeFrame(e, 'right'));

document.getElementById('resize-bottom').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'bottom'));
document.getElementById('resize-right').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'right'));

function resizeFrame(e, direction) {
  e.stopPropagation();
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  let startX = e.clientX;
  let startY = e.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    if (direction === 'bottom') {
      let newHeight = startHeight + (e.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (e.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('mousemove', doDrag);
    document.removeEventListener('mouseup', stopDrag);
  }

  document.addEventListener('mousemove', doDrag);
  document.addEventListener('mouseup', stopDrag);
}

function resizeFrameTouch(e, direction) {
  e.stopPropagation();
  e.preventDefault(); // Prevent scrolling
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  const touch = e.touches[0];
  let startX = touch.clientX;
  let startY = touch.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    const touch = e.touches[0];
    if (direction === 'bottom') {
      let newHeight = startHeight + (touch.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (touch.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('touchmove', doDrag);
    document.removeEventListener('touchend', stopDrag);
  }

  document.addEventListener('touchmove', doDrag);
  document.addEventListener('touchend', stopDrag);
}

updateButtonPositions();
});
// 獲取框元素
const frame = document.getElementById('movable-frame');

function showPage(page_no) {
    __PAGE_RENDERING_IN_PROGRESS = 1;
    __CURRENT_PAGE = page_no;
    $("#pdf-next, #pdf-prev").attr('disabled', 'disabled');
    $("#pdf-canvas").hide();
    $("#page-loader").show();
    $("#pdf-current-page").text(page_no);
    __PDF_DOC.getPage(page_no).then(function (page) {
        let viewport = page.getViewport({ scale: 1 });
        let scale = __CANVAS.width / viewport.width;
        viewport = page.getViewport({ scale: scale });
        __CANVAS.height = viewport.height;
        var renderContext = {
            canvasContext: __CANVAS_CTX,
            viewport: viewport
        };
        page.render(renderContext).promise.then(function () {
            __PAGE_RENDERING_IN_PROGRESS = 0;
            $("#pdf-next, #pdf-prev").removeAttr('disabled');
            $("#pdf-canvas").show();
            $("#page-loader").hide();
            return page.getTextContent();
        }).then(function (textContent) {
            var canvas_offset = $("#pdf-canvas").offset();
            $("#text-layer").html('');
            document.getElementById('text-layer').style.setProperty('--scale-factor', viewport.scale);
            $("#text-layer").css({ left: canvas_offset.left + 'px', top: canvas_offset.top + 'px' });
            PDFJS.renderTextLayer({
                textContentSource: textContent,
                container: $("#text-layer").get(0),
                viewport: viewport,
                textDivs: []
            });
            console.log('Text Layer Content:', textContent);
        });
    });
}




     // 更新語速顯示
function updateRate(value) {
    const adjustedValue = value;
    const speedLabel = document.getElementById('speedLabel');
    const speedPercent = document.getElementById('speedPercent');
    
    if (adjustedValue === 0) {
        speedLabel.textContent = '';
        speedPercent.textContent = '0%';
    } else if (adjustedValue > 0) {
        speedLabel.textContent = '語速加';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    } else {
        speedLabel.textContent = '語速減';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    }
}

// 設置初始語速
document.getElementById('speakSpeed').value = -30;
updateRate(-30);
        
</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@latest/dist/tesseract.min.js"></script>
</body>
</html>
