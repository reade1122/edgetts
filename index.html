<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èªéŸ³å ±è®€ç³»çµ±</title>
    <style>
	    html {
    touch-action: manipulation;
}
	     body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

select, input, button {
  font-size: 18px; /* Increase font size for better readability */
  padding: 15px; /* Increase padding for larger touch targets */
  margin-bottom: 20px;
  border-radius: 8px; /* Add rounded corners for a modern look */
  border: 2px solid #ccc; /* Add border for better visibility */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add subtle shadow for depth */
}

select {
  width: 20%; /* Increase width for better usability */
  z-index: 1900;
  position: fixed;
  right: 20px;
  top:5px;
}
#pdfContainer {
  margin-top: 80px; /* è¨­å®šé ‚éƒ¨é‚Šè·ç‚º 80px */
}
  #prevPage, #nextPage {
    padding: 15px 30px; /* å¢åŠ å…§é‚Šè·ä»¥æ“´å¤§è§¸æ§å€åŸŸ */
    font-size: 18px; /* å¢åŠ å­—é«”å¤§å°ä»¥æé«˜å¯è®€æ€§ */
    cursor: pointer;
    background-color: #007BFF; /* æ·»åŠ èƒŒæ™¯è‰²ä»¥æé«˜å¯è¦‹æ€§ */
    color: white; /* å°‡æ–‡å­—é¡è‰²æ”¹ç‚ºç™½è‰² */
    border: none; /* ç§»é™¤é»˜èªé‚Šæ¡† */
    transition: background-color 0.3s; /* æ·»åŠ éæ¸¡æ•ˆæœä»¥æé«˜äº’å‹•æ€§ */
  }

  #prevPage:hover, #nextPage:hover {
    background-color: #0056b3; /* æ‡¸åœæ™‚æ›´æ”¹èƒŒæ™¯è‰² */
  }
audio {
    width: 50%;
    bottom: 5px;
    z-index: 1000;
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
}
        .pdf-page-container {
            margin-bottom: 20px;
            position: relative;
            display: inline-block;
        }
        .pdf-viewer {
            position: relative;
            display: inline-block;
        }
        /* æ¨™è¨˜æ¨¡å¼ä¸‹çš„æ¸¸æ¨™æ¨£å¼ */
        body.marking-mode-active {
            cursor: crosshair !important;
        }
        body.marking-mode-active .pdf-viewer,
        body.marking-mode-active canvas {
            cursor: crosshair !important;
        }
        /* å€å¡Šæ¨™è¨˜å±¤æ¨£å¼ */
        .mark-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* é»˜èªä¸æ¥æ”¶äº‹ä»¶ */
            z-index: 200; /* æé«˜ z-index ç¢ºä¿åœ¨æ–‡å­—å±¤ä¹‹ä¸Š */
            background-color: transparent; /* ç¢ºä¿èƒŒæ™¯é€æ˜ */
            overflow: visible; /* å…è¨±æ¨™è¨˜æ¡†è¶…å‡ºé‚Šç•Œ */
        }
        .mark-layer.marking-mode {
            pointer-events: auto; /* æ¨™è¨˜æ¨¡å¼æ™‚å…è¨±æ¥æ”¶äº‹ä»¶ */
        }
        .mark-layer .mark-block {
            pointer-events: auto; /* æ¨™è¨˜å€å¡Šå§‹çµ‚å¯é»æ“Š */
        }
        .mark-block {
            position: absolute;
            border: 3px solid #007BFF;
            background-color: rgba(0, 123, 255, 0.1);
            cursor: move;
            pointer-events: auto;
            transition: none;
            box-sizing: border-box;
            min-width: 10px;
            min-height: 10px;
        }
        .mark-block:hover {
            background-color: rgba(0, 123, 255, 0.2);
            border-color: #0056b3;
        }
        .mark-block.active {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.2);
        }
        .mark-block.dragging {
            opacity: 0.8;
            z-index: 1003;
        }
        .mark-block .resize-handle {
            position: absolute;
            background-color: #007BFF;
            border: 2px solid white;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 1020; /* æé«˜ z-indexï¼Œç¢ºä¿åœ¨å·¥å…·æ¬„å’ŒæŒ‰éˆ•ä¸Šæ–¹ */
            pointer-events: auto;
            cursor: nwse-resize;
        }
        .mark-block .resize-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }
        .mark-block .resize-handle.ne {
            top: -6px;
            right: -6px; /* æ”¹å›è§’è½ä½ç½®ï¼Œå› ç‚º z-index å·²æé«˜ */
            cursor: ne-resize;
        }
        .mark-block .resize-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }
        .mark-block .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }
        .mark-block .resize-handle.n {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }
        .mark-block .resize-handle.s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }
        .mark-block .resize-handle.w {
            top: 50%;
            left: -6px;
            transform: translateY(-50%);
            cursor: w-resize;
        }
        .mark-block .resize-handle.e {
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            cursor: e-resize;
        }
        .mark-block .resize-handle:hover {
            background-color: #0056b3;
            width: 14px;
            height: 14px;
        }
        .mark-block .mark-label {
            position: absolute;
            top: -20px;
            left: 0;
            background-color: #007BFF;
            color: white;
            padding: 2px 6px;
            font-size: 12px;
            border-radius: 3px;
            white-space: nowrap;
        }
        .mark-block.active .mark-label {
            background-color: #28a745;
        }
        /* å·¥å…·æ¬„å®¹å™¨ - æ”¾åœ¨æ¨™è¨˜æ¡†å…§éƒ¨å·¦ä¸Šè§’ */
        .mark-block .mark-toolbar {
            position: absolute;
            top: 2px;
            left: 2px;
            display: flex;
            gap: 4px;
            z-index: 1005;
            pointer-events: none; /* å®¹å™¨æœ¬èº«ä¸æ””æˆªäº‹ä»¶ */
            opacity: 0; /* é»˜èªéš±è— */
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        /* æ»‘é¼ æ‡¸åœæ™‚é¡¯ç¤ºå·¥å…·æ¬„ */
        .mark-block:hover .mark-toolbar,
        .mark-block.active .mark-toolbar {
            opacity: 1;
            visibility: visible;
        }
        .mark-block .mark-toolbar > * {
            pointer-events: auto; /* ä½†æŒ‰éˆ•å¯ä»¥æ¥æ”¶äº‹ä»¶ */
        }
        /* å¦‚æœæ¨™è¨˜æ¡†å¤ªå°ï¼Œå·¥å…·æ¬„é¡¯ç¤ºåœ¨å¤–éƒ¨ */
        .mark-block .mark-toolbar.small-box {
            top: -28px; /* é¡¯ç¤ºåœ¨æ¨™è¨˜æ¡†ä¸Šæ–¹ */
            left: 0;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 2px 4px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 1px solid #ddd;
        }
        .mark-block .mark-delete {
            width: 22px;
            height: 22px;
            background-color: #dc3545;
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .mark-block .mark-delete:hover {
            background-color: #c82333;
            transform: scale(1.1);
        }
        .mark-block .mark-edit {
            width: 22px;
            height: 22px;
            background-color: #28a745;
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            line-height: 1;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .mark-block .mark-edit:hover {
            background-color: #218838;
            transform: scale(1.1);
        }
        .mark-block .mark-lock {
            width: 22px;
            height: 22px;
            background-color: #ffc107;
            color: white;
            border: 1px solid white;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            user-select: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .mark-block .mark-lock:hover {
            background-color: #e0a800;
            transform: scale(1.1);
        }
        .mark-block .mark-lock.locked {
            background-color: #dc3545;
        }
        .mark-block .mark-lock.locked:hover {
            background-color: #c82333;
        }
        .mark-block.locked {
            opacity: 0.7;
            pointer-events: none;
        }
        .mark-block.locked .mark-lock {
            pointer-events: auto;
        }
        .mark-layer.hidden {
            display: none !important;
        }
        /* ç¢ºä¿æ¨™è¨˜æ¡†åœ¨æ¨™è¨˜å±¤ä¸­å¯è¦‹ */
        .mark-layer.marking-mode {
            display: block !important;
            visibility: visible !important;
        }
        canvas {
            display: block;
        }
      .textLayer {
            position: absolute;
            text-align: initial;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            -webkit-text-size-adjust: none;
            -webkit-transform-origin: 0% 0%;
            transform-origin: 0% 0%;
        }
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            pointer-events: auto;
        }
        .textLayer > span.highlight {
            background-color: transparent !important;
        }
        .textLayer > span[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer > my-fra {
            background-color: transparent;
        }
        .textLayer > my-fra[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgba(180, 0, 170, 0.2);
            border-radius: 4px;
        }
        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 0, 0.2);
        }
        .textLayer ::-moz-selection {
            background: rgba(0, 0, 255, 0.2);
        }
        .textLayer ::selection {
            background: rgba(0, 0, 255, 0.2);
        }
		  .no-select {
        user-select: none; /* ç¦ç”¨åç™½é¸å– */
        -webkit-user-select: none; /* ç¦ç”¨åç™½é¸å– for Safari */
        -moz-user-select: none; /* ç¦ç”¨åç™½é¸å– for Firefox */
        -ms-user-select: none; /* ç¦ç”¨åç™½é¸å– for Internet Explorer/Edge */
    }
    
    /* æ¨¡æ€çª—å£æ ·å¼ */
    .modal {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      z-index: 900;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }
    
    /* æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®åº•ï¼‰ */
    .marking-toolbar {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      width: 100%;
      background-color: rgba(255, 255, 255, 0.98);
      border-top: 2px solid #007BFF;
      padding: 10px 20px;
      z-index: 2000;
      box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
      flex-direction: row;
      align-items: center;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      min-height: 50px;
    }
    
    .marking-toolbar.show {
      display: flex !important;
      visibility: visible !important;
    }
    
    .marking-toolbar .button {
      margin: 0;
      padding: 8px 16px;
      font-size: 14px;
      white-space: nowrap;
    }
    
    /* ç¢ºä¿å·¥å…·æ¬„é¡¯ç¤ºæ™‚ï¼ŒæŒ‰éˆ•å¯è¦‹ï¼ˆä½¿ç”¨!importantè¦†è“‹å…§è¯æ¨£å¼ï¼‰ */
    .marking-toolbar.show .button {
      display: inline-block !important;
      visibility: visible !important;
      opacity: 1 !important;
      pointer-events: auto !important;
      z-index: 2001 !important;
      position: relative;
    }

    /* é®ç½©å±‚æ ·å¼ */
    .modal-overlay {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.05);
      z-index: 900;
    }

    /* æŒ‰é’®æ ·å¼ */
    .button {
      padding: 10px 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .button-secondary {
      background-color: #6c757d;
    }

    .button-success {
      background-color: #28a745;
    }

    .button-light {
      background-color: #ded520;
    }

    .button-danger {
      background-color: #dc3545;
      
    }
     
   my-fra {
            display: inline; /* ç¢ºä¿ä¸å½±éŸ¿æ’ç‰ˆ */
        }
 input[type=range] {
    -webkit-appearance: none;
    width: 300px;
    height: 20px;
    background: linear-gradient(145deg, #d4d4d4, #f0f0f0);
    border: 1px solid #b0b0b0;
    border-radius: 10px;
    outline: none;
    opacity: 0.9;
    -webkit-transition: .2s;
    transition: opacity .2s;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

input[type=range]::-moz-range-thumb {
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}
   #verticalDiv {
            position: fixed;
            top: 200px; /* è·é›¢é ‚éƒ¨50px */
            right: 15px; /* è·é›¢å³å´0px */
            z-index: 1000;
            display: flex;
            flex-direction: column; /* ä½¿å…§å®¹ç¸±å‘æ’åˆ— */
            align-items: center; /* å…§å®¹ç½®ä¸­ */	
			
        }

        #speakSpeed {
		
            z-index: 1000;
            transform: rotate(-90deg); /* æ—‹è½‰æ»‘è»Œ */
            transform-origin: right center; /* è¨­ç½®æ—‹è½‰ä¸­å¿ƒ */

        }
    
    /* SweetAlert2 é«˜ z-index æ¨£å¼ */
    .swal-high-z-index {
        z-index: 10030 !important;
    }

    /* SweetAlert2 å…¨åŸŸé«˜ z-indexï¼Œç¢ºä¿æ°¸é åœ¨æœ€ä¸Šå±¤ï¼ˆé«˜æ–¼ API KEY æ¨¡æ…‹è¦–çª—çš„ 10020ï¼‰ */
    .swal2-container,
    .swal2-popup,
    .swal2-modal,
    .swal2-backdrop,
    .swal2-shown,
    .swal2-height-auto,
    .swal2-icon,
    .swal2-title,
    .swal2-content,
    .swal2-actions,
    .swal2-styled,
    .swal2-close,
    .swal2-validation-message,
    .swal2-html-container,
    .swal2-loader,
    .swal2-progress-steps,
    .swal2-backdrop-show,
    .swal2-backdrop-hide,
    .swal2-noanimation,
    .swal2-toast {
      z-index: 10030 !important;
    }
    </style>
	  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
</head>
<body tabindex="0">
	 <div class="container">
<div>
    <!-- è²éŸ³é¸æ“‡ -->  
    <select id="voiceSelect">
	é¸æ“‡è²éŸ³ï¼š
      <option value="zh-TW-HsiaoChenNeural">é›²ç«¯ï¼šä¸­æ–‡ æ›‰è‡» (å¥³æ€§)</option>
      <option value="zh-TW-YunJheNeural">é›²ç«¯ï¼šä¸­æ–‡ å…å“² (ç”·æ€§)</option>
      <option value="zh-TW-HsiaoYuNeural">é›²ç«¯ï¼šä¸­æ–‡ æ›‰é›¨ (å¥³æ€§)</option>
      <option value="en-US-JennyNeural">é›²ç«¯ï¼šè‹±æ–‡ Jenny (å¥³æ€§)</option>
      <option value="en-US-GuyNeural">é›²ç«¯ï¼šè‹±æ–‡ Guy (ç”·æ€§)</option>
      <option value="en-US-AriaNeural">é›²ç«¯ï¼šè‹±æ–‡ Aria (å¥³æ€§)</option>
      <option value="en-US-ChristopherNeural">é›²ç«¯ï¼šè‹±æ–‡ Christ (ç”·æ€§)</option> 
      <option value="local-zh-female">æœ¬æ©Ÿï¼šä¸­æ–‡å¥³éŸ³ (ç€è¦½å™¨)</option>
      <option value="local-en-female">æœ¬æ©Ÿï¼šè‹±æ–‡å¥³éŸ³ (ç€è¦½å™¨)</option>
    </select>
</div>
		  <!-- èªé€Ÿèª¿æ•´ -->
 <div id="verticalDiv">	     
      <label for="speakSpeed" style="writing-mode: vertical-lr; position: fixed; top: 120px; right: 5px; color: rgb(134, 101, 224); font-size: 20px; font-weight: bold; text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px; height: 200px; display: flex; align-items: center;">
    <span id="speedLabel">èªé€ŸåŠ </span>
    <span id="speedPercent" style="writing-mode: horizontal-tb; margin-left: 5px;">0%</span>
</label>
      <input type="range" id="speakSpeed" name="rate" min="-50" max="50" value="-30" oninput="updateRate(this.value)" style="  width:20%;  padding: 10px;  margin-bottom: 20px; z-index:1000;right:15px;position: fixed;">
    </div>
    
    <!-- éŸ³é »æ’­æ”¾å™¨ -->
    <audio id="audioPlayer" controls></audio>
  </div>
<div id="movable-frame"></div>
<input type="file" id="pdfFileInput" style=" width: 20%; /* Increase width for better usability */  z-index: 1900;  position: fixed;  left: 20px; top:5px;">
<div id="viewerContainer" tabindex="0">
    <center><div id="pdfContainer"></div></center>
</div>
	
<div class="pagination" style="width: 100%; top: 5px; z-index: 1000;  position: fixed;">
	<center>
    <button id="prevPage">ä¸Šä¸€é </button>
    <span id="pageNumber"></span>
    <button id="nextPage">ä¸‹ä¸€é </button>
	</center>	
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>    
  <button id="select-all-text" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;right: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" >æ•´é æœ—è®€</button>
  <!-- é¡µé¢é®ç½© -->
  <div id="modalOverlay" class="modal-overlay"></div>

   <button id="sendButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;right: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æœ—è®€é¸å–æ–‡å­—</button>
  <button id="clearButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;left: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æ¸…é™¤é¸å–æ–‡å­—</button>
    <label style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; top: 300px;left: 2px; z-index: 1000;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;">
        <input type="checkbox" id="touchSelectCheckbox" style="writing-mode: vertical-rl; text-orientation: upright; width: 30px; height: 30px; position: fixed;left: 1px;top: 260px;">è§¸æ§é¸å–</label>
    <!-- å ±è®€ç³»çµ±é€²éšè¨­å®šæŒ‰éˆ• -->
    <button
        id="apiKeySettingsButton"
        class="button button-secondary"
        style="position: fixed; top: 70px; left: 0px; z-index: 1; width: 40px; height: 40px; border-radius: 50%; padding: 0; font-size: 20px; display: flex; align-items: center; justify-content: center;"
        title="å ±è®€ç³»çµ±é€²éšè¨­å®š"
        aria-label="å ±è®€ç³»çµ±é€²éšè¨­å®š"
    >âš™ï¸</button>

    <!-- API KEY è¨­å®šæ¨¡æ…‹è¦–çª—ï¼ˆåŒ…å«æ¨™è¨˜åŠŸèƒ½ï¼‰ -->
    <div id="apiKeyModal" class="modal" style="display: none; z-index: 10020;">
        <div style="padding: 20px;">
            <h2 style="margin-top: 0; text-align: center;">å ±è®€ç³»çµ±é€²éšè¨­å®š</h2>
            
            <!-- ä¸€ã€API KEY è¨­å®š -->
            <div style="display: flex; align-items: flex-end; margin-top: 10px; margin-bottom: 10px;">
                <h3 style="margin: 0; line-height: 1.2;">ä¸€ã€API KEY è¨­å®š</h3>
                <button
                    id="apiKeyHelpButton"
                    type="button"
                    class="button button-light"
                    style="margin-left: 8px; padding: 2px 8px; font-size: 14px; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; margin-bottom: 2px;"
                    title="å¦‚ä½•å–å¾— API KEYï¼Ÿ"
                >ï¼Ÿ</button>
            </div>
            <div style="margin-bottom: 15px;">
                <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">API KEYï¼šï¼ˆç”¨æ–¼AIåœ–ç‰‡è¾¨è­˜èˆ‡AIæ¨™è¨˜æœ—è®€ç¯„åœï¼‰</label>
                <input type="password" id="apiKeyInput" placeholder="è«‹è¼¸å…¥æˆ–æƒæ QR Code" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 15px;">
                <button id="scanQRButton" class="button button-success" style="width: 100%; margin-bottom: 10px; font-size: 16px;">ğŸ“· æƒæ QR Code</button>
                <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
                    <video id="qrVideo" style="width: 100%; max-width: 400px; border: 2px solid #ccc; border-radius: 5px; display: block; margin: 0 auto;"></video>
                    <canvas id="qrCanvas" style="display: none;"></canvas>
                    <button id="stopScanButton" class="button button-danger" style="width: 100%; margin-top: 10px; font-size: 16px;">åœæ­¢æƒæ</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 15px;">
                <button id="saveApiKeyButton" class="button button-success" style="flex: 1; font-size: 16px;">å„²å­˜</button>
                <button id="deleteApiKeyButton" class="button button-danger" style="flex: 1; font-size: 16px;">åˆªé™¤ API KEY</button>
            </div>
            
            <!-- äºŒã€PDF å¿«å– -->
            <h3 style="margin-top: 0; margin-bottom: 10px;">äºŒã€PDF å¿«å–</h3>
            <!-- æ¸…é™¤å¿«å–æŒ‰éˆ•ï¼ˆç§»å…¥è¨­å®šè¦–çª—ï¼Œé¿å…èª¤è§¸ï¼‰ -->
            <div style="margin-bottom: 15px;">
                <button id="clearCacheButton" class="button button-danger" style="width: 100%; font-size: 16px;">æ¸…é™¤ PDF å¿«å–</button>
            </div>
            
            <!-- ä¸‰ã€PDF æ¨™è¨˜åŠŸèƒ½ -->
            <h3 style="margin-top: 0; margin-bottom: 15px;">ä¸‰ã€PDF æ¨™è¨˜åŠŸèƒ½ï¼ˆé»é¸äº‹å…ˆæ¨™è¨˜çš„ç¯„åœå¯ç›´æ¥ç™¼éŸ³ï¼‰</h3>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px;">
                <button id="markBlockButton" class="button button-success" style="width: 100%; font-size: 16px;">æ¨™è¨˜å€å¡Š</button>
                <button id="saveMarkedPdfButton" class="button button-success" style="width: 100%; font-size: 16px; display: none;">ä¿å­˜æ¨™è¨˜</button>
                <button id="downloadMarkedPdfButton" class="button button-success" style="width: 100%; font-size: 16px; display: none;">åŒ¯å‡ºPDF</button>
                <button id="clearMarksButton" class="button button-danger" style="width: 100%; font-size: 16px; display: none;">æ¸…é™¤æ¨™è¨˜</button>
            </div>
            
            <!-- æ•´å€‹è¦–çª—çš„å–æ¶ˆæŒ‰éˆ•ï¼Œä¸‰å¤§åŠŸèƒ½å…±ç”¨ï¼Œç½®åº•ç½®ä¸­ -->
            <div style="text-align: center; margin-bottom: 10px; margin-top: 5px;">
                <button id="cancelApiKeyButton" class="button button-secondary" style="min-width: 120px; font-size: 16px;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <div id="apiKeyModalOverlay" class="modal-overlay" style="z-index: 10019;"></div>

    <!-- API KEY æ•™å­¸å½ˆçª— -->
    <div id="apiKeyHelpPopup" style="display: none; position: fixed; inset: 0; z-index: 10021; align-items: center; justify-content: center;">
        <div style="background: #fff; max-width: 480px; width: 90%; padding: 20px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">
            <h3 style="margin-top: 0; margin-bottom: 10px; text-align: center;">å¦‚ä½•å–å¾— Gemini API KEY</h3>
            <ol style="padding-left: 20px; margin-top: 0; margin-bottom: 10px; font-size: 14px;">
                <li>
                    ç¬¬ä¸€æ­¥é©Ÿï¼šå…ˆé€£ç·šåˆ°
                    <a href="https://aistudio.google.com/u/2/api-keys" target="_blank" rel="noopener noreferrer">
                        aistudio.google.com/u/2/api-keys
                    </a>
                    ä¸¦ç™»å…¥ä½ çš„ Google å¸³è™Ÿã€‚
                </li>
                <li>ç¬¬äºŒæ­¥é©Ÿï¼šä¾ç…§ä¸‹æ–¹çš„æ•™å­¸åœ–ç‰‡æ­¥é©Ÿå»ºç«‹ä¸¦è¤‡è£½ä½ çš„ API KEYã€‚</li>
            </ol>
            <div style="text-align: center; margin-bottom: 10px;">
                <img
                    id="apiKeyHelpImage"
                    src="./Gemini_APIkey.png"
                    alt="Gemini API KEY å–å¾—æ•™å­¸"
                    style="max-width: 100%; border-radius: 6px; border: 1px solid #ddd; cursor: zoom-in;"
                >
                <div style="font-size: 12px; color: #666; margin-top: 4px;">ï¼ˆé»æ“Šåœ–ç‰‡å¯æ”¾å¤§æª¢è¦–ï¼‰</div>
            </div>
            <div style="text-align: center;">
                <button id="apiKeyHelpCloseButton" type="button" class="button button-secondary" style="min-width: 100px;">é—œé–‰</button>
            </div>
        </div>
    </div>

    <!-- API KEY æ•™å­¸åœ–ç‰‡å…¨è¢å¹•æª¢è¦– -->
    <div id="apiKeyImageFullscreen" style="display: none; position: fixed; inset: 0; z-index: 10022; background-color: rgba(0,0,0,0.8); align-items: center; justify-content: center;">
        <div style="position: relative; max-width: 95%; max-height: 95%;">
            <img
                id="apiKeyHelpImageLarge"
                src="./Gemini_APIkey.png"
                alt="Gemini API KEY å–å¾—æ•™å­¸ï¼ˆæ”¾å¤§ï¼‰"
                style="max-width: 100%; max-height: 100%; border-radius: 6px; box-shadow: 0 4px 16px rgba(0,0,0,0.5);"
            >
            <button
                id="apiKeyImageFullscreenClose"
                type="button"
                class="button button-danger"
                style="position: absolute; top: -10px; right: -10px; min-width: 60px; font-size: 14px;"
            >
                é—œé–‰
            </button>
        </div>
    </div>
    
    <!-- æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®åº•ï¼‰ -->
    <div id="markingToolbar" class="marking-toolbar">
        <button id="cancelMarkingButtonToolbar" class="button button-danger" style="display: none;">å–æ¶ˆæ¨™è¨˜</button>
        <button id="manualMarkButtonToolbar" class="button button-primary" style="display: none;">æ‰‹å‹•æ¨™è¨˜</button>
        <button id="aiMarkButtonToolbar" class="button button-light" style="display: none;">AIæ¨™è¨˜</button>
        <button id="setPasswordButtonToolbar" class="button button-secondary" style="display: none;">è¨­å®šå¯†ç¢¼</button>
        <button id="saveMarkedPdfButtonToolbar" class="button button-success" style="display: none;">ä¿å­˜æ¨™è¨˜</button>
        <button id="downloadMarkedPdfButtonToolbar" class="button button-success" style="display: none;">åŒ¯å‡ºPDF</button>
        <button id="clearMarksButtonToolbar" class="button button-danger" style="display: none;">æ¸…é™¤æ¨™è¨˜</button>
    </div>
<script>
// ç§»é™¤ BroadcastChannel ç›¸é—œä»£ç¢¼ï¼Œæ›¿æ›ç‚ºä»¥ä¸‹å¯¦ç¾

// é æ•¸åŒæ­¥ç›¸é—œè®Šé‡
let pageSyncTimeout = null;
const PAGE_SYNC_DELAY = 300; // é˜²æŠ–å»¶é²(æ¯«ç§’)

// ä¿®æ”¹ notifyPageChange å‡½æ•¸
function notifyPageChange(page) {
    // æ›´æ–° URL hash
    updateUrlHash(page);
    
    // å¦‚æœæ˜¯ iframe å…§åµŒçš„æƒ…æ³ï¼Œé€šçŸ¥çˆ¶çª—å£
    if (window !== window.top) {
        window.parent.postMessage({
            type: 'pageChange',
            page: page,
            source: 'pdfViewer'
        }, '*'); // æ³¨æ„: å¯¦éš›æ‡‰ç”¨ä¸­æ‡‰æŒ‡å®šå…·é«”åŸŸåè€Œé '*'
    }
    
    // æ›´æ–° localStorage
    localStorage.setItem('currentPage', page);
}

//  æ›´æ–°URL hash (ä¸è§¸ç™¼é é¢åˆ·æ–°)
function updateUrlHash(page) {
    const newUrl = new URL(window.location.href);
    newUrl.hash = `page=${page}`;
    window.history.replaceState({}, '', newUrl);
}
// ç²å–ç•¶å‰é æ•¸ (å¾URL hashæˆ–localStorage)
function getPageFromHash() {
    const hash = window.location.hash.substring(1);
    const params = new URLSearchParams(hash);
    const pageFromHash = params.get('page') ? parseInt(params.get('page')) : null;
    
    // å¾ localStorage è®€å–ä½œç‚ºå‚™ç”¨
    const pageFromStorage = localStorage.getItem('currentPage') ? parseInt(localStorage.getItem('currentPage')) : 1;
    
    return pageFromHash || pageFromStorage;
}
// PDF.js åˆå§‹åŒ–
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

const pdfFileInput = document.getElementById('pdfFileInput');
const pdfContainer = document.getElementById('pdfContainer');
const prevPageButton = document.getElementById('prevPage');
const nextPageButton = document.getElementById('nextPage');
const pageNumberSpan = document.getElementById('pageNumber');

let pdfDoc = null;
let currentPage = 1;

// Function to render the page with dynamic width
function renderPage(pageNum) {
    if (!pdfDoc) return;

    pdfDoc.getPage(pageNum).then(page => {
        const screenWidth = window.innerWidth;
        const desiredWidth = screenWidth * 0.95; // Keep 95% width
        const viewport = page.getViewport({ scale: 1 });
        const scale = desiredWidth / viewport.width;
        const scaledViewport = page.getViewport({ scale: scale });

        pdfContainer.innerHTML = '';

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.style.position = 'relative';

        const pdfViewer = document.createElement('div');
        pdfViewer.className = 'pdf-viewer';
        pdfViewer.style.position = 'relative';

        const pdfCanvas = document.createElement('canvas');
        const context = pdfCanvas.getContext('2d');

        const dpi = window.devicePixelRatio || 1;
        pdfCanvas.height = scaledViewport.height * dpi;
        pdfCanvas.width = scaledViewport.width * dpi;
        context.scale(dpi, dpi);

        pdfCanvas.style.height = `${scaledViewport.height}px`;
        pdfCanvas.style.width = `${scaledViewport.width}px`;
        pdfCanvas.style.display = 'block';

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = `${scaledViewport.width}px`;
        textLayerDiv.style.height = `${scaledViewport.height}px`;
        textLayerDiv.style.position = 'absolute';
        textLayerDiv.style.top = '0';
        textLayerDiv.style.left = '0';
        textLayerDiv.style.pointerEvents = 'none';

        // å‰µå»ºæ¨™è¨˜å±¤
        const markLayer = document.createElement('div');
        markLayer.className = 'mark-layer';
        markLayer.style.width = `${scaledViewport.width}px`;
        markLayer.style.height = `${scaledViewport.height}px`;
        markLayer.dataset.pageNum = pageNum;
        markLayer.dataset.scale = scale;

        pageContainer.appendChild(pdfViewer);
        pdfViewer.appendChild(pdfCanvas);
        pdfViewer.appendChild(textLayerDiv);
        pdfViewer.appendChild(markLayer);
        pdfContainer.appendChild(pageContainer);
        
        // å¦‚æœè™•æ–¼æ¨™è¨˜æ¨¡å¼ï¼Œç‚º pdfViewer ç¶å®šäº‹ä»¶ä¸¦è¨­ç½®æ¸¸æ¨™
        if (isMarkingMode) {
            pdfViewer.addEventListener('mousedown', handleViewerMouseDown);
            pdfViewer.addEventListener('touchstart', handleViewerTouchStart);
            pdfViewer.style.setProperty('cursor', 'crosshair', 'important');
            pdfCanvas.style.setProperty('cursor', 'crosshair', 'important');
        }

        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };

        page.render(renderContext).promise.then(() => {
            return page.getTextContent();
        }).then(textContent => {
            textLayerDiv.innerHTML = '';
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: scaledViewport,
                textDivs: [],
                enhanceTextSelection: true
            });

            // ä¿®æ­£æ–‡å­—å±¤çš„ç¸®æ”¾å’Œä½ç½®
            const textElements = textLayerDiv.getElementsByTagName('span');
            for (let span of textElements) {
                const originalTransform = span.style.transform || '';
                span.style.transform = originalTransform.replace(/scale\([^)]+\)/, `scale(${1/dpi})`);
            }
            
            // åœ¨æ–‡å­—å±¤æ¸²æŸ“å®Œæˆå¾Œï¼Œå»¶é²æ¸²æŸ“æ¨™è¨˜
            setTimeout(() => {
                renderMarks();
                // å¦‚æœè™•æ–¼æ¨™è¨˜æ¨¡å¼ï¼Œç¢ºä¿æ¨™è¨˜å±¤äº‹ä»¶å·²å•Ÿç”¨ä¸¦è¨­ç½®æ¸¸æ¨™
                if (isMarkingMode) {
                    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
                    const pdfViewer = document.querySelector('.pdf-viewer');
                    const canvas = pdfViewer ? pdfViewer.querySelector('canvas') : null;
                    if (markLayer) {
                        markLayer.classList.add('marking-mode');
                    }
                    if (pdfViewer) {
                        pdfViewer.addEventListener('mousedown', handleViewerMouseDown);
                        pdfViewer.addEventListener('touchstart', handleViewerTouchStart);
                        pdfViewer.style.setProperty('cursor', 'crosshair', 'important');
                    }
                    if (canvas) {
                        canvas.style.setProperty('cursor', 'crosshair', 'important');
                    }
                }
            }, 300);
        });

        pageNumberSpan.textContent = `Page ${pageNum} of ${pdfDoc.numPages}`;

        const currentHash = window.location.hash;
        const newHash = `page=${pageNum}`;
        if (currentHash !== newHash) {
            const newUrl = new URL(window.location.href);
            newUrl.hash = newHash;
            window.history.replaceState({}, '', newUrl);
        }
    });
}

// Event listener for orientation changes
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        renderPage(currentPage);
    }, 200); // Delay of 200 milliseconds
});

// Initial render
renderPage(currentPage);
	
// Google Apps Script ä»£ç† URL
const gasUrl = 'https://script.google.com/macros/s/AKfycbz22gIlfLOry1KdMW5A2NlcO1o9859zXGP1Yf0GklsNbU4VF-WBRJtW2sGL8rZIE1oq/exec';


// æ‰“é–‹ IndexedDB è³‡æ–™åº«
const openDB = () => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('pdfDB', 3); // å¢åŠ ç‰ˆæœ¬è™Ÿä»¥è§¸ç™¼å‡ç´š
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            // å¦‚æœ objectStore å·²å­˜åœ¨ï¼Œå…ˆåˆªé™¤å†é‡æ–°å‰µå»ºä»¥ç¢ºä¿é…ç½®æ­£ç¢º
            if (db.objectStoreNames.contains('pdfFiles')) {
                db.deleteObjectStore('pdfFiles');
            }
            // é‡æ–°å‰µå»º objectStoreï¼Œç¢ºä¿ä½¿ç”¨ keyPath: 'id'
            db.createObjectStore('pdfFiles', { keyPath: 'id' });
            
            // å‰µå»ºè¨­å®š objectStoreï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!db.objectStoreNames.contains('settings')) {
                db.createObjectStore('settings', { keyPath: 'id' });
            }
        };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
    });
};

// ä¿å­˜æª”æ¡ˆåˆ° IndexedDB
const saveFileToIndexedDB = async (file) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        
        // ç¢ºä¿å°è±¡æœ‰ id å±¬æ€§ï¼Œä¸¦ç­‰å¾… put æ“ä½œå®Œæˆ
        const dataToStore = { id: 'currentPdf', file: file };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                // put æ“ä½œæˆåŠŸï¼Œç­‰å¾… transaction å®Œæˆ
            };
            putRequest.onerror = () => reject(putRequest.error);
            
            // ç›£è½ transaction å®Œæˆ
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('ä¿å­˜æª”æ¡ˆåˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å–æª”æ¡ˆ
const loadFileFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readonly');
        const store = transaction.objectStore('pdfFiles');
        const request = store.get('currentPdf');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.file);
                } else {
                    reject(new Error('IndexedDB ä¸­æœªæ‰¾åˆ°æª”æ¡ˆ'));
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ¸…ç©º IndexedDB ä¸­çš„æª”æ¡ˆ
const clearIndexedDB = async (forceClear = false) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        if (forceClear) {
            store.delete('currentPdf');
        }
        updateUrl(null);
    } catch (error) {
        console.error('æ¸…é™¤ IndexedDB å¤±æ•—ï¼š', error);
    }
};

// ä¿å­˜ API KEY åˆ° IndexedDB
const saveApiKeyToIndexedDB = async (apiKey) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const dataToStore = { id: 'geminiApiKey', value: apiKey };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            putRequest.onerror = () => reject(putRequest.error);
        });
    } catch (error) {
        console.error('ä¿å­˜ API KEY åˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å– API KEY
const loadApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readonly');
        const store = transaction.objectStore('settings');
        const request = store.get('geminiApiKey');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.value);
                } else {
                    resolve(null);
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å– API KEY å¤±æ•—ï¼š', error);
        return null;
    }
};

// åˆªé™¤ API KEY å¾ IndexedDB
const deleteApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const deleteRequest = store.delete('geminiApiKey');
        
        return new Promise((resolve, reject) => {
            deleteRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            deleteRequest.onerror = () => reject(deleteRequest.error);
        });
    } catch (error) {
        console.error('åˆªé™¤ API KEY å¾ IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ›´æ–°ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

function updateUrl(fileName) {
    const newUrl = new URL(window.location.href);
    if (fileName) {
        newUrl.searchParams.set('file', fileName); // ä¸ä½¿ç”¨ encodeURIComponent
    } else {
        newUrl.searchParams.delete('file');
    }
    window.history.replaceState({}, '', newUrl);
}

// å¾ URL è¼‰å…¥ PDF æª”æ¡ˆ
async function loadPdfFromUrl(url) {
    try {
        Swal.fire({
            title: 'è¼‰å…¥ä¸­è«‹ç¨å€™',
            text: 'æ­£åœ¨å¾ç¶²è·¯è¼‰å…¥æª”æ¡ˆ...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
        
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTPéŒ¯èª¤: ${response.status}`);
        }
        
        const arrayBuffer = await response.arrayBuffer();
        originalPdfBytes = new Uint8Array(arrayBuffer);
        
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        const fileName = url.split('/').pop() || 'document.pdf';
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        const typedarray = new Uint8Array(arrayBuffer);
        // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
        originalPdfBytes = typedarray;
        
        pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
            pdfDoc = pdf;
            currentPage = 1;
            renderPage(currentPage);
            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
            setTimeout(async () => {
                await loadMarksFromPdf();
            }, 800);
            updateUrl(url);
            Swal.close();
        }).catch(error => {
            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'è¼‰å…¥å¤±æ•—',
                text: 'ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥URLæ˜¯å¦æ­£ç¢ºã€‚',
            });
        });
    } catch (error) {
        console.error('å¾URLè¼‰å…¥PDFå¤±æ•—ï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'è¼‰å…¥å¤±æ•—',
            text: 'ç„¡æ³•å¾URLè¼‰å…¥PDFæª”æ¡ˆï¼š' + error.message,
        });
    }
}

// å¾ Google é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥ PDF æª”æ¡ˆï¼ˆä½¿ç”¨ GAS ä»£ç†ï¼‰
async function loadPdfFromDrive(fileId, showLoading = true) {
    // æª¢æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼ˆåŒ…å« .pdf çµå°¾ï¼‰
    if (fileId && fileId.toLowerCase().endsWith('.pdf')) {
        // å¦‚æœæ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼Œç›´æ¥è¿”å›ä¸è™•ç†
        return;
    }

    if (showLoading) {
        Swal.fire({
            title: 'è¼‰å…¥ä¸­è«‹ç¨å€™',
            text: 'æ­£åœ¨å¾é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥æª”æ¡ˆ...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
    }

    let fileName = `file_${fileId}.pdf`;
    
    // å‰µå»ºå¸¶è¶…æ™‚çš„ fetch å‡½æ•¸
    const fetchWithTimeout = (url, options = {}, timeout = 10000) => {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('è«‹æ±‚è¶…æ™‚')), timeout)
            )
        ]);
    };
    
    try {
        // ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰
        console.log('ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰æª”æ¡ˆ...');
        const gasResponse = await fetchWithTimeout(
            `${gasUrl}?fileId=${fileId}`, 
            { method: 'GET' }, 
            10000
        );
        
        if (!gasResponse.ok) {
            throw new Error(`GAS ä»£ç†å›æ‡‰éŒ¯èª¤: ${gasResponse.status} ${gasResponse.statusText}`);
        }
        
        const data = await gasResponse.json();
        
        if (!data.fileContent || !data.fileName) {
            throw new Error('GAS ä»£ç†è¿”å›çš„è³‡æ–™æ ¼å¼éŒ¯èª¤');
        }
        
        // GAS è¿”å› base64 ç·¨ç¢¼çš„å…§å®¹
        const fileContent = atob(data.fileContent);
        const arrayBuffer = new ArrayBuffer(fileContent.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < fileContent.length; i++) {
            uint8Array[i] = fileContent.charCodeAt(i);
        }
        fileName = data.fileName;
        
        console.log(`âœ“ ä¸‹è¼‰æˆåŠŸï¼Œä¾†æº: GAS ä»£ç†`);
        
        // å°‡ ArrayBuffer è½‰æ›ç‚º File ä¸¦ä¿å­˜
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        // ä¿å­˜åŸå§‹PDFå­—ç¯€
        originalPdfBytes = new Uint8Array(arrayBuffer);
        
        // è¼‰å…¥ PDF
        const typedarray = new Uint8Array(arrayBuffer);
        // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
        originalPdfBytes = typedarray;
        
        pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
            pdfDoc = pdf;
            renderPage(currentPage);
            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
            setTimeout(async () => {
                await loadMarksFromPdf();
            }, 800);
            updateUrl(fileId);
            if (showLoading) {
                Swal.close();
            }
        }).catch(error => {
            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'è¼‰å…¥å¤±æ•—',
                text: 'ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚',
            });
        });
    } catch (error) {
        console.error('GAS ä»£ç†ä¸‹è¼‰å¤±æ•—ï¼š', error);
        if (showLoading) {
            Swal.fire({
                icon: 'error',
                title: 'ä¸‹è¼‰å¤±æ•—',
                text: 'ç„¡æ³•å¾ Google é›²ç«¯ç¡¬ç¢Ÿä¸‹è¼‰æª”æ¡ˆã€‚\n\n' +
                    'å¯èƒ½çš„åŸå› ï¼š\n' +
                    '1. æª”æ¡ˆæœªå…¬é–‹åˆ†äº«ï¼ˆè«‹ç¢ºèªæª”æ¡ˆåˆ†äº«è¨­å®šç‚ºã€ŒçŸ¥é“é€£çµçš„ä½¿ç”¨è€…ã€ï¼‰\n' +
                    '2. GAS ä»£ç†æœå‹™ç•°å¸¸\n' +
                    '3. ç¶²è·¯é€£ç·šå•é¡Œ\n\n' +
                    'å»ºè­°ï¼š\n' +
                    '- ç¢ºèªæª”æ¡ˆå·²å…¬é–‹åˆ†äº«\n' +
                    '- æª¢æŸ¥ç¶²è·¯é€£ç·š\n' +
                    '- ç¨å¾Œå†è©¦',
            });
        }
    }
}
// ç•¶é é¢è¼‰å…¥æ™‚ï¼Œæª¢æŸ¥ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

// ä¿®æ”¹é é¢åˆå§‹åŒ–éƒ¨åˆ†
window.addEventListener('load', async () => {
    // å¾ URL hash æˆ– localStorage è®€å–åˆå§‹é æ•¸
    currentPage = getPageFromHash();
    
    // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç¢¼...
    const urlParams = new URLSearchParams(window.location.search);
    const fileParam = urlParams.get('file');
    const previousUrl = sessionStorage.getItem('previousUrl');
    const currentUrl = window.location.href;

    // åˆ¤æ–·æ˜¯å¦ç‚ºé é¢é‡æ–°æ•´ç†
    const isPageRefresh = previousUrl === currentUrl;

    // åˆ¤æ–· URL æ˜¯å¦ä»¥ .pdf çµå°¾ï¼ˆæœ¬åœ°æª”æ¡ˆï¼‰
    const isLocalPdfFile = fileParam && fileParam.toLowerCase().endsWith('.pdf');

    if (fileParam) {
        if (fileParam.startsWith('http://') || fileParam.startsWith('https://')) {
            // è™•ç†ç¶²è·¯ PDF æª”æ¡ˆ
            await clearIndexedDB();
            loadPdfFromUrl(fileParam);
        } else if (isLocalPdfFile) {
            // è™•ç†æœ¬åœ° PDF æª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file && file.name === fileParam) {
                    console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æœ¬åœ°æª”æ¡ˆç›¸åŒï¼Œå¾ IndexedDB è¼‰å…¥');
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        originalPdfBytes = typedarray;
                        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                            pdfDoc = pdf;
                            renderPage(currentPage);
                            // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                            setTimeout(() => {
                                loadMarksFromPdf();
                            }, 800);
                        }).catch(error => {
                            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                            alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                        });
                    };
                    fileReader.onerror = function() {
                        console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                        alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                    };
                    fileReader.readAsArrayBuffer(file);
                } else {
                    console.log('IndexedDB ä¸­æ²’æœ‰åŒ¹é…çš„æœ¬åœ°æª”æ¡ˆï¼Œæ¸…é™¤ URL åƒæ•¸');
                    updateUrl(null);
                }
            } catch (error) {
                console.error('è®€å–æœ¬åœ°æª”æ¡ˆå¤±æ•—ï¼š', error);
                updateUrl(null);
            }
        } else {
            // è™•ç† Google é›²ç«¯ç¡¬ç¢Ÿæª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file) {
                    if (file.name === fileParam) {
                        console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æª”æ¡ˆç›¸åŒï¼Œè·³éé‡æ–°è¼‰å…¥ã€‚');
                        const fileReader = new FileReader();
                        fileReader.onload = async function() {
                            const typedarray = new Uint8Array(this.result);
                            originalPdfBytes = typedarray;
                            pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
                                pdfDoc = pdf;
                                renderPage(currentPage);
                                // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                                setTimeout(async () => {
                                    await loadMarksFromPdf();
                                }, 800);
                            }).catch(error => {
                                console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                                alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                            });
                        };
                        fileReader.onerror = function() {
                            console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                            alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                        };
                        fileReader.readAsArrayBuffer(file);
                    } else {
                        await clearIndexedDB();
                        await saveFileToIndexedDB(file);
                        updateUrl(file.name);
                    }
                } else {
                    await loadPdfFromDrive(fileParam, !isPageRefresh);
                }
            } catch (error) {
                console.error('è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
                await loadPdfFromDrive(fileParam, !isPageRefresh);
            }
        }
    }

    // æ›´æ–° sessionStorage ä¸­çš„ previousUrl
    sessionStorage.setItem('previousUrl', currentUrl);
});

//  ç›£è½é æ•¸è®ŠåŒ–äº‹ä»¶
window.addEventListener('hashchange', function() {
    const newPage = getPageFromHash();
    if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
        currentPage = newPage;
        renderPage(currentPage);
    }
});

// ç•¶ä½¿ç”¨è€…é¸æ“‡æª”æ¡ˆæ™‚
pdfFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        try {
            await clearIndexedDB(true);
            await saveFileToIndexedDB(file);
            
            // æ›´æ–° URL åƒæ•¸ï¼Œæ¨™è¨˜ç‚ºæœ¬åœ°æª”æ¡ˆ
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('file', file.name);
            window.history.replaceState({}, '', newUrl);
            
            const fileReader = new FileReader();
            fileReader.onload = async function() {
                const typedarray = new Uint8Array(this.result);
                // ä¿å­˜åŸå§‹PDFå­—ç¯€ï¼ˆç”¨æ–¼ä¿å­˜æ¨™è¨˜ï¼‰
                originalPdfBytes = typedarray;
                
                pdfjsLib.getDocument(typedarray).promise.then(async pdf => {
                    pdfDoc = pdf;
                    currentPage = 1; // é‡ç½®ç‚ºç¬¬ä¸€é 
                    renderPage(currentPage);
                    // å»¶é²è¼‰å…¥æ¨™è¨˜ï¼Œç¢ºä¿æ¨™è¨˜å±¤å·²å‰µå»º
                    setTimeout(async () => {
                        await loadMarksFromPdf();
                    }, 800);
                }).catch(error => {
                    console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                    alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                });
            };
            fileReader.onerror = function() {
                console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
            };
            fileReader.readAsArrayBuffer(file);
        } catch (error) {
            console.error('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼š', error);
            alert('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
        }
    } else {
        updateUrl(null);
    }
});

// ä¸Šä¸€é å’Œä¸‹ä¸€é æŒ‰éˆ•çš„äº‹ä»¶ç›£è½
// ä¿®æ”¹ä¸Šä¸€é /ä¸‹ä¸€é æŒ‰éˆ•äº‹ä»¶
prevPageButton.addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        setTimeout(() => {
            renderMarks();
        }, 500);
        notifyPageChange(currentPage);
    }
});

nextPageButton.addEventListener('click', () => {
    if (pdfDoc && currentPage < pdfDoc.numPages) {
        currentPage++;
        renderPage(currentPage);
        setTimeout(() => {
            renderMarks();
        }, 500);
        notifyPageChange(currentPage);
    }
});
// ç›£è½è·¨ç¶²åŸŸæ¶ˆæ¯
window.addEventListener('message', function(event) {
    if (event.data?.type === 'pageChange' && event.data.source !== 'pdfViewer') {
        const newPage = event.data.page;
        if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
            currentPage = newPage;
            renderPage(currentPage);
            updateUrlHash(currentPage);
        }
    }
});


// å¾ URL åƒæ•¸ä¸­è®€å– PDF æª”æ¡ˆçš„ ID
const urlParams = new URLSearchParams(window.location.search);
const fileId = urlParams.get('file');
if (fileId) {
    loadPdfFromDrive(fileId);
}
// æ–°å¢ï¼šæ‰‹å‹•æ¸…é™¤å¿«å–æŒ‰éˆ•åŠŸèƒ½
const clearCacheButton = document.getElementById('clearCacheButton');
if (clearCacheButton) {
    clearCacheButton.addEventListener('click', async () => {
        await clearIndexedDB(true);
        Swal.fire({
            icon: 'success',
            title: 'å·²æ¸…é™¤PDFå¿«å–',
            text: 'PDF å¿«å–å·²æ¸…é™¤ï¼Œè«‹é‡æ–°è¼‰å…¥æª”æ¡ˆã€‚',
            timer: 1500,
            showConfirmButton: false
        });
    });
}
</script>
 <script>
  
  // API é…ç½®
  const API_CONFIG = {
    BASE_URL: 'https://readetts-tts.hf.space', // Hugging Face Spaces TTS API
    TTS_ENDPOINT: '/tts',
    VOICES_ENDPOINT: '/voices'
  };
  
  // API å¥åº·æª¢æŸ¥
  async function checkAPIHealth() {
    try {
      const response = await fetch(`${API_CONFIG.BASE_URL}/health`);
      if (response.ok) {
        console.log('âœ… Edge TTS API æœå‹™æ­£å¸¸é‹è¡Œ');
        return true;
      } else {
        console.warn('âš ï¸ Edge TTS API æœå‹™å¯èƒ½æœªæ­£å¸¸é‹è¡Œ');
        return false;
      }
    } catch (error) {
      console.error('âŒ ç„¡æ³•é€£æ¥åˆ° Edge TTS API æœå‹™:', error);
      return false;
    }
  }
  
  let selectedFile = null;
  let isListening = true; // åˆå§‹è¨­ç½®ç‚ºç›£è½æ¨¡å¼
  let isReading = false; // åˆå§‹è¨­ç½®ç‚ºæœªé–±è®€ç‹€æ…‹
  let audioPlayer = null;
  let browserVoices = [];

  // åˆå§‹åŒ–ç€è¦½å™¨èªéŸ³åˆ—è¡¨
  function initBrowserVoices() {
      if (!('speechSynthesis' in window)) {
          console.warn('æ­¤ç€è¦½å™¨ä¸æ”¯æ´æœ¬æ©ŸèªéŸ³ (speechSynthesis)');
          return;
      }
      browserVoices = window.speechSynthesis.getVoices();
  }

  // ä¾èªç³»å°‹æ‰¾æœ¬æ©Ÿå¥³è²ï¼Œæ‰¾ä¸åˆ°å°±é€€å›åŒèªç³» / ä»»æ„ voice
  function findLocalVoice(langPrefix) {
      if (!('speechSynthesis' in window)) {
          return null;
      }
      if (!browserVoices || browserVoices.length === 0) {
          browserVoices = window.speechSynthesis.getVoices();
      }
      if (!browserVoices || browserVoices.length === 0) {
          return null;
      }
      const lowerLang = (langPrefix || '').toLowerCase();
      // å„ªå…ˆï¼šæŒ‡å®šèªç³» + åç¨±åƒå¥³è²
      const femaleLike = browserVoices.find(v =>
          v.lang && v.lang.toLowerCase().startsWith(lowerLang) &&
          v.name && /female|å¥³|woman|girl|Jenny|Zira|Aria/i.test(v.name)
      );
      if (femaleLike) return femaleLike;
      // æ¬¡å„ªå…ˆï¼šæŒ‡å®šèªç³»ä»»ä¸€ voice
      const sameLang = browserVoices.find(v =>
          v.lang && v.lang.toLowerCase().startsWith(lowerLang)
      );
      if (sameLang) return sameLang;
      // æœ€å¾Œå‚™æ´ï¼šåˆ—è¡¨ç¬¬ä¸€å€‹
      return browserVoices[0];
  }

  // ä½¿ç”¨ç€è¦½å™¨æœ¬æ©ŸèªéŸ³æœ—è®€
  function speakWithLocalTTS(text, ratePercent, langPrefix, callback) {
      if (!('speechSynthesis' in window)) {
          console.warn('æ­¤ç€è¦½å™¨ä¸æ”¯æ´æœ¬æ©ŸèªéŸ³ (speechSynthesis)');
          if (callback) callback();
          return;
      }

      try {
          window.speechSynthesis.cancel();
      } catch (e) {
          console.warn('å–æ¶ˆæœ¬æ©ŸèªéŸ³æ™‚ç™¼ç”Ÿä¾‹å¤–ï¼š', e);
      }

      const voice = findLocalVoice(langPrefix);
      if (!voice) {
          console.warn('æ‰¾ä¸åˆ°å°æ‡‰çš„æœ¬æ©ŸèªéŸ³ï¼Œç„¡æ³•æœ—è®€');
          if (callback) callback();
          return;
      }

      const utterance = new SpeechSynthesisUtterance(text);
      utterance.voice = voice;

      // å°‡ -50% ~ +50% æ˜ å°„æˆç´„ 0.5 ~ 1.5 å€é–“
      const rate = Math.min(3, Math.max(0.1, 1 + (ratePercent / 100)));
      utterance.rate = rate;

      utterance.onend = () => {
          if (callback) callback();
      };
      utterance.onerror = (e) => {
          console.error('æœ¬æ©ŸèªéŸ³æœ—è®€éŒ¯èª¤ï¼š', e);
          if (callback) callback();
      };

      window.speechSynthesis.speak(utterance);
  }

  if ('speechSynthesis' in window) {
      // æŸäº›ç€è¦½å™¨éœ€è¦ç­‰ voices è¼‰å…¥å®Œæˆæ‰æ‹¿å¾—åˆ°
      window.speechSynthesis.onvoiceschanged = initBrowserVoices;
      initBrowserVoices();
  }
          document.addEventListener('DOMContentLoaded', async () => {
    audioPlayer = document.getElementById('audioPlayer');
    
    // æª¢æŸ¥ API å¥åº·ç‹€æ…‹
    const isAPIHealthy = await checkAPIHealth();
    if (!isAPIHealthy) {
        console.warn('Edge TTS API æœå‹™æœªé‹è¡Œï¼ŒèªéŸ³åŠŸèƒ½å¯èƒ½ç„¡æ³•ä½¿ç”¨');
    }
    
    const findInput = document.getElementById('findInput'); // ç²å–è¼¸å…¥æ¬„ä½
    const findEntireWord = document.getElementById('findEntireWord'); // ç²å– Whole Words å‹¾é¸æ¡†
    let isFinding = false; // ç”¨æ–¼è¿½è¹¤æ˜¯å¦æœ‰æœªå®Œæˆçš„æŸ¥æ‰¾æ“ä½œ

    // å‡½æ•¸: ç™¼é€é¸ä¸­çš„æ–‡æœ¬åˆ°æ–°çš„ TTS API é€²è¡Œè™•ç†

        function getSheetIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('googlesheetid');
        }

        function fetchSheetData(sheetId) {
    const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?`;
    const query = encodeURIComponent('Select B, C format B "", C ""'); // ä½¿ç”¨ format å¼·åˆ¶è½‰æ›ç‚ºç´”æ–‡å­—
    const url = `${base}&tq=${query}`;

    return fetch(url)
        .then(res => res.text())
        .then(rep => {
            const jsonStr = rep.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/)[1];
            const data = JSON.parse(jsonStr);
            console.log("ç¢ºèªæ¬„ä½å°æ‡‰ï¼ˆç¬¬ä¸€è¡Œæ¨™é¡Œï¼Œå°‡è¢«è·³éï¼‰:", data.table.rows[0]?.c); // ç¬¬ä¸€è¡Œæ˜¯æ¨™é¡Œï¼Œå°‡å¾ç¬¬äºŒè¡Œé–‹å§‹å–å€¼
            return data;
        })
        .catch(err => {
            console.error('è¼‰å…¥å¤±æ•—:', err);
            return null;
        });
}

function replaceTextWithSheetData(text, data) {
    if (!data || !data.table || !data.table.rows) return text;
    
    // Google Sheets API çš„ Select æŸ¥è©¢æœƒè‡ªå‹•è·³éæ¨™é¡Œè¡Œ
    // æ‰€ä»¥ rows[0] å°±æ˜¯è©¦ç®—è¡¨çš„ç¬¬äºŒè¡Œï¼ˆç¬¬ä¸€è¡Œæ•¸æ“šï¼‰
    // ç›´æ¥å¾ rows[0] é–‹å§‹è®€å–ï¼Œä¸éœ€è¦å†è·³é
    const dataRows = data.table.rows;
    console.log("ç¸½è¡Œæ•¸ï¼ˆAPI å·²è‡ªå‹•è·³éæ¨™é¡Œè¡Œï¼‰:", dataRows.length);
    
    dataRows.forEach((row, index) => {
        // ç¢ºä¿è³‡æ–™å­˜åœ¨ä¸”è½‰æ›ç‚ºå­—ä¸²
        const original = row.c[0]?.v?.toString() || ''; // Bæ¬„ï¼ˆåŸå§‹æ–‡å­—ï¼‰
        const replacement = row.c[1]?.v?.toString() || ''; // Cæ¬„ï¼ˆæ›¿æ›æ–‡å­—ï¼‰
        if (original && replacement) {
            // index + 2 å› ç‚ºï¼šindex å¾ 0 é–‹å§‹ï¼Œè©¦ç®—è¡¨ç¬¬ä¸€è¡Œæ˜¯æ¨™é¡Œï¼Œæ‰€ä»¥ index+2 æ˜¯è©¦ç®—è¡¨çš„è¡Œè™Ÿ
            console.log(`è™•ç†ç¬¬ ${index + 2} è¡Œï¼ˆè©¦ç®—è¡¨ç¬¬ ${index + 2} è¡Œï¼‰: "${original}" -> "${replacement}"`);
            // ä½¿ç”¨å­—ä¸²æ›¿æ›ï¼Œç¢ºä¿éƒ½æ˜¯ç´”æ–‡å­—è™•ç†
            text = text.replace(new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g"), replacement);
        }
    });
    return text;
}

// å°‡ sendTextToTTS å®šç¾©åœ¨å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–å‡½æ•¸å¯ä»¥è¨ªå•
async function sendTextToTTS(selectedText, callback) {
    // æ¯æ¬¡æ–°çš„ç™¼éŸ³è«‹æ±‚ï¼Œä¸€é–‹å§‹å…ˆã€Œå¾¹åº•æ¸…é™¤ã€ä¹‹å‰çš„æ‰€æœ‰ç™¼éŸ³ç‹€æ…‹
    try {
        // 1. åœæ­¢ä¸¦æ¸…ç©ºç€è¦½å™¨æœ¬æ©ŸèªéŸ³ä½‡åˆ—
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }

        // 2. åœæ­¢ä¸¦é‡è¨­è‡ªè¨‚éŸ³é »æ’­æ”¾å™¨
        const audioPlayerEl = document.getElementById('audioPlayer');
        if (audioPlayerEl) {
            // åœæ­¢ç›®å‰æ’­æ”¾
            audioPlayerEl.pause();
            audioPlayerEl.currentTime = 0;

            // æ¸…é™¤äº‹ä»¶ç›£è½èˆ‡ä¾†æºï¼Œé¿å…èˆŠçš„ oncanplay / onended åœ¨èƒŒæ™¯è§¸ç™¼
            audioPlayerEl.oncanplay = null;
            audioPlayerEl.onended = null;
            audioPlayerEl.onerror = null;
            audioPlayerEl.onloadstart = null;
            audioPlayerEl.onloadeddata = null;
            audioPlayerEl.onprogress = null;
            audioPlayerEl.onabort = null;
            audioPlayerEl.onstalled = null;
            audioPlayerEl.onsuspend = null;

            // æ¸…ç©ºä¾†æºä¸¦å¼·åˆ¶é‡æ–°è¼‰å…¥ï¼Œä»¥åˆ‡æ–·èˆŠéŸ³æª”
            audioPlayerEl.removeAttribute('src');
            try {
                audioPlayerEl.load();
            } catch (e) {
                console.warn('é‡è¼‰ audioPlayer æ™‚ç™¼ç”Ÿä¾‹å¤–ï¼š', e);
            }
        }
    } catch (e) {
        console.error('é‡ç½®ç™¼éŸ³ç‹€æ…‹æ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š', e);
    }

    // åŠ å¼·æ–‡å­—æ¸…ç†ï¼Œç§»é™¤å¯èƒ½å°è‡´ SSML è§£æéŒ¯èª¤çš„ç‰¹æ®Šå­—ç¬¦
    const cleanedText = selectedText
        .replace(/[\r\n]+/g, ' ')
        .replace(/\s+/g, ' ')
        .replace(/[<>&]/g, '') // ç§»é™¤ SSML ç‰¹æ®Šå­—ç¬¦
        .trim();
    
    let filteredText = cleanedText; // Initialize with cleanedText as fallback
    
    const sheetId = getSheetIdFromUrl();
    if (sheetId) {
        const data = await fetchSheetData(sheetId);
        filteredText = replaceTextWithSheetData(cleanedText, data);
    }
    
    console.log("é€å‡ºçµ¦ TTS çš„æ–‡æœ¬:", filteredText);
    console.log("æ–‡æœ¬é•·åº¦:", filteredText.length);
    
    // æª¢æŸ¥æ–‡æœ¬æ˜¯å¦ç‚ºç©º
    if (!filteredText || filteredText.length === 0) {
        console.error('TTS æ–‡æœ¬ç‚ºç©ºï¼Œç„¡æ³•æœ—è®€');
        if (callback) callback();
        return;
    }
    
    // ç²å–é¸æ“‡çš„è²éŸ³å’Œèªé€Ÿ
    const voiceName = document.getElementById("voiceSelect").value;
    const rateValueRaw = parseFloat(document.getElementById('speakSpeed').value);
    const rateValue = Math.max(-50, Math.min(50, isNaN(rateValueRaw) ? 0 : rateValueRaw));

    // è‹¥é¸æ“‡æœ¬æ©ŸèªéŸ³ï¼Œæ”¹ç”¨ç€è¦½å™¨ speechSynthesis ç™¼éŸ³ï¼Œä¸å‘¼å«é›²ç«¯ API
    if (voiceName === 'local-zh-female' || voiceName === 'local-en-female') {
        const langPrefix = voiceName === 'local-zh-female' ? 'zh' : 'en';
        speakWithLocalTTS(filteredText, rateValue, langPrefix, callback);
        return;
    }

    const rateString = `${rateValue >= 0 ? '+' : ''}${rateValue}%`;

    // æ§‹å»º API è«‹æ±‚åƒæ•¸
    const requestData = {
        text: filteredText,
        voice: voiceName,
        rate: rateString,
        volume: "+0%",
        pitch: "+0Hz"
    };

    // ç™¼é€è«‹æ±‚åˆ° Edge TTS API
    fetch(`${API_CONFIG.BASE_URL}/tts`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
    })
    .then(response => {
        console.log('TTS API å›æ‡‰ç‹€æ…‹:', response.status);
        if (!response.ok) {
            throw new Error(`è«‹æ±‚å¤±æ•—ï¼š${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('TTS API å›æ‡‰:', data);
        if (data.success) {
            // æˆåŠŸç”ŸæˆèªéŸ³ï¼Œç›´æ¥ä½¿ç”¨éŸ³é »URL
            const audioUrl = `${API_CONFIG.BASE_URL}${data.audio_url}`;
            console.log('éŸ³é »URL:', audioUrl);
            
            // è¨­ç½®éŸ³é »æ’­æ”¾å™¨
            const audioPlayer = document.getElementById('audioPlayer');
            
            // æ·»åŠ éŒ¯èª¤è™•ç†
            audioPlayer.onerror = (e) => {
                console.error('éŸ³é »è¼‰å…¥éŒ¯èª¤:', e);
                console.error('éŸ³é »å…ƒç´ éŒ¯èª¤:', audioPlayer.error);
                // è¼‰å…¥éŒ¯èª¤æ™‚èª¿ç”¨å›èª¿
                if (callback) callback();
            };
            
            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢é‡è¤‡æ’­æ”¾
            audioPlayer.oncanplay = null;
            audioPlayer.onended = null;
            audioPlayer.onerror = null;
            
            // è¨­ç½®è¼‰å…¥è¶…æ™‚
            let loadTimeout = setTimeout(() => {
                console.error('éŸ³é »è¼‰å…¥è¶…æ™‚');
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                if (callback) callback();
            }, 10000); // 10ç§’è¶…æ™‚
            
            // æ·»åŠ è¼‰å…¥äº‹ä»¶ï¼ˆåªè¨­ç½®ä¸€æ¬¡ï¼‰
            audioPlayer.onloadstart = () => console.log('é–‹å§‹è¼‰å…¥éŸ³é »...');
            audioPlayer.oncanplay = () => {
                // æ¸…é™¤è¶…æ™‚
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                
                console.log('éŸ³é »å¯ä»¥æ’­æ”¾');
                // éŸ³é »æº–å‚™å¥½å¾Œè‡ªå‹•æ’­æ”¾
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('éŸ³é »æ’­æ”¾æˆåŠŸ');
                            // æ’­æ”¾æˆåŠŸå¾Œè¨­ç½®å®Œæˆå›èª¿
                            audioPlayer.onended = callback;
                        })
                        .catch(error => {
                            console.error('éŸ³é »æ’­æ”¾å¤±æ•—:', error);
                            // æ’­æ”¾å¤±æ•—æ™‚ä¹Ÿè¦èª¿ç”¨å›èª¿
                            if (callback) callback();
                        });
                } else {
                    // å¦‚æœæ²’æœ‰æ’­æ”¾Promiseï¼Œç›´æ¥è¨­ç½®å›èª¿
                    audioPlayer.onended = callback;
                }
            };
            
            // æ·»åŠ æ›´å¤šäº‹ä»¶ç›£è½å™¨
            audioPlayer.onloadeddata = () => console.log('éŸ³é »æ•¸æ“šå·²è¼‰å…¥');
            audioPlayer.onprogress = () => console.log('éŸ³é »è¼‰å…¥é€²åº¦ä¸­...');
            audioPlayer.onabort = () => console.log('éŸ³é »è¼‰å…¥è¢«ä¸­æ­¢');
            audioPlayer.onstalled = () => console.log('éŸ³é »è¼‰å…¥åœæ»¯');
            audioPlayer.onsuspend = () => console.log('éŸ³é »è¼‰å…¥æš«åœ');
            
            // è¨­ç½®éŸ³é »æº
            audioPlayer.src = audioUrl;
        } else {
            throw new Error(data.error || 'èªéŸ³ç”Ÿæˆå¤±æ•—');
        }
    })
    .catch(error => {
        console.error('TTS ç™¼ç”ŸéŒ¯èª¤ï¼š', error);
        // ä¸è¦å½ˆå‡ºè­¦å‘Šï¼Œéœé»˜è™•ç†éŒ¯èª¤
        console.warn('TTS éŒ¯èª¤å·²è™•ç†ï¼Œç¹¼çºŒåŸ·è¡Œ');
        if (callback) callback();
    });
}

// å°‡ sendTextToTTS æš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿å…¶ä»–å‡½æ•¸å¯ä»¥è¨ªå•
window.sendTextToTTS = sendTextToTTS;

        // createSSML å‡½æ•¸å·²ç§»é™¤ï¼Œç¾åœ¨ç›´æ¥ä½¿ç”¨ JSON æ ¼å¼ç™¼é€è«‹æ±‚

        const selectAllTextButton = document.getElementById('select-all-text');
        let sentences = [];
        let currentSentenceIndex = 0;
        let isReading = false;

        selectAllTextButton.addEventListener('click', function() {
            clearHighlights();
            if (isReading) {
                // å–æ¶ˆæœ—è®€
                cancelReading();
            } else {
                // æ¸…é™¤æ¨™è¨˜æ›¿æ›ç·©å­˜
                clearMarkReplacementCache();
                
                // é–‹å§‹æœ—è®€
                const pdfContainer = document.getElementById('pdfContainer');
                const textLayers = pdfContainer.getElementsByClassName('textLayer');
                let fullText = '';

                for (let textLayer of textLayers) {
                    const spans = textLayer.getElementsByTagName('my-fra');
                    for (let span of spans) {
                        // æª¢æŸ¥æ˜¯å¦åœ¨æ¨™è¨˜å€åŸŸå…§ï¼Œå¦‚æœåœ¨ä¸”æ¨™è¨˜æœ‰æ›¿æ›æ–‡å­—ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—
                        const textToAdd = getTextWithMarkReplacement(span, textLayer);
                        // ç›´æ¥é€£æ¥ï¼Œä¸åŠ ç©ºæ ¼ï¼Œä¿æŒåŸå§‹æ–‡æœ¬æ ¼å¼
                        fullText += textToAdd;
                    }
                }

                // æ¸…ç†æ–‡æœ¬ï¼šç§»é™¤æ›è¡Œç¬¦ï¼Œå°‡å¤šå€‹é€£çºŒç©ºæ ¼åˆä½µç‚ºå–®å€‹ç©ºæ ¼ï¼Œä½†ä¿ç•™åŸæœ¬å°±å­˜åœ¨çš„ç©ºæ ¼ï¼ˆå¦‚è‹±æ–‡å–®è©ä¹‹é–“ï¼‰
                const cleanedText = fullText.replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
                sentences = cleanedText.split(/(?<=[ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šæ¨™é»ç¬¦è™Ÿåˆ†å¥
                currentSentenceIndex = 0;
                isReading = true;

                // ç«‹å³æ›´æ–°æŒ‰éˆ•æ¨£å¼å’Œæ–‡æœ¬
                selectAllTextButton.textContent = "å–æ¶ˆæœ—è®€";
                selectAllTextButton.classList.remove('button-light');
                selectAllTextButton.classList.add('button-danger');

                startReading(); // ç›´æ¥é–‹å§‹æœ—è®€
            }
        });

function cancelReading() {
  isReading = false;
  
  // åœæ­¢æœ¬æ©ŸèªéŸ³
  try {
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
    }
  } catch (e) {
    console.warn('å–æ¶ˆæœ¬æ©ŸèªéŸ³æ™‚ç™¼ç”Ÿä¾‹å¤–ï¼š', e);
  }
  
  // åœæ­¢ä¸¦é‡è¨­è‡ªè¨‚éŸ³é »æ’­æ”¾å™¨
  const audioPlayerEl = document.getElementById('audioPlayer');
  if (audioPlayerEl) {
    audioPlayerEl.pause();
    audioPlayerEl.currentTime = 0;
    
    // æ¸…é™¤æ‰€æœ‰äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢å›èª¿ç¹¼çºŒåŸ·è¡Œ
    audioPlayerEl.oncanplay = null;
    audioPlayerEl.onended = null;
    audioPlayerEl.onerror = null;
    audioPlayerEl.onloadstart = null;
    audioPlayerEl.onloadeddata = null;
    audioPlayerEl.onprogress = null;
    audioPlayerEl.onabort = null;
    audioPlayerEl.onstalled = null;
    audioPlayerEl.onsuspend = null;
    
    // æ¸…ç©ºä¾†æºä¸¦å¼·åˆ¶é‡æ–°è¼‰å…¥ï¼Œä»¥åˆ‡æ–·èˆŠéŸ³æª”
    audioPlayerEl.removeAttribute('src');
    try {
      audioPlayerEl.load();
    } catch (e) {
      console.warn('é‡è¼‰ audioPlayer æ™‚ç™¼ç”Ÿä¾‹å¤–ï¼š', e);
    }
  }
  
  // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
  selectAllTextButton.textContent = "æ•´é æœ—è®€";
  selectAllTextButton.classList.remove('button-danger');
  selectAllTextButton.classList.add('button-light');
  
  // æ¸…é™¤æ‰€æœ‰æ¨™ç¤º
  const textLayerDivs = document.querySelectorAll('#viewerContainer .textLayer my-fra');
  textLayerDivs.forEach(span => {
    span.style.backgroundColor = ''; // æ¸…é™¤æ¨™ç¤º
  });
  
  // é‡ç½®å¥å­ç´¢å¼•ï¼Œé˜²æ­¢ç¹¼çºŒæœ—è®€
  currentSentenceIndex = 0;
  sentences = [];
}

function startReading() {
    if (sentences.length > 0) {
        readNextSentence();
    } else {
        console.error('æ²’æœ‰å¯æœ—è®€çš„å¥å­');
    }
}

function readNextSentence() {
    // æª¢æŸ¥æ˜¯å¦ä»åœ¨æœ—è®€ç‹€æ…‹ï¼Œå¦‚æœå·²å–æ¶ˆå‰‡ä¸ç¹¼çºŒ
    if (!isReading) {
        return;
    }
    
    if (currentSentenceIndex < sentences.length) {
        const sentence = sentences[currentSentenceIndex];
        highlightCurrentSentence(sentence);
        sendTextToTTS(sentence, function() {
            // å†æ¬¡æª¢æŸ¥æ˜¯å¦ä»åœ¨æœ—è®€ç‹€æ…‹ï¼Œé˜²æ­¢åœ¨æ’­æ”¾éç¨‹ä¸­å–æ¶ˆ
            if (!isReading) {
                return;
            }
            
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length && isReading) {
                readNextSentence();
            } else {
                isReading = false;
                clearHighlights();
                selectAllTextButton.textContent = "æ•´é æœ—è®€";
                selectAllTextButton.classList.remove('button-danger');
                selectAllTextButton.classList.add('button-light');
            }
        });
    }
}

function highlightCurrentSentence(sentence) {
    const pdfContainer = document.getElementById('pdfContainer');
    const textLayers = pdfContainer.getElementsByClassName('textLayer');
    let spansArray = []; // å­˜å„²æ‰€æœ‰ <my-fra> æ¨™ç±¤

    // å°‡æ‰€æœ‰ <my-fra> æ¨™ç±¤å­˜å„²åˆ°æ•¸çµ„ä¸­ï¼Œä¸¦æŒ‰é †åºæ’åˆ—
    for (let textLayer of textLayers) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            spansArray.push(span);
        }
    }

    // æ¸…é™¤å‰ä¸€å¥çš„æ¨™ç¤º
    for (let span of spansArray) {
        span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
    }

    // æŒ‰æ–·å¥ç¬¦è™Ÿåˆ†æ®µ
    const sentences = sentence.split(/([ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šå¥è™Ÿã€å•è™Ÿã€é©šå˜†è™Ÿåˆ†æ®µ
    const cleanedSentences = [];
    for (let i = 0; i < sentences.length; i += 2) {
        const sentenceText = sentences[i] + (sentences[i + 1] || ''); // å°‡æ–·å¥ç¬¦è™Ÿèˆ‡å¥å­åˆä½µ
        const cleanedSentence = sentenceText.replace(/\s+/g, ''); // å»é™¤ç©ºç™½å­—ç¬¦
        if (cleanedSentence) {
            cleanedSentences.push(cleanedSentence);
        }
    }

    // æŒ‰é †åºæ¨™ç¤ºæ¯å€‹å¥å­
    let currentIndex = 0; // ç•¶å‰éæ­·åˆ°çš„å­—ç¬¦ç´¢å¼•
    for (let s = 0; s < cleanedSentences.length; s++) {
        const cleanedSentence = cleanedSentences[s];
        let sentenceIndex = 0; // ç”¨æ–¼è¿½è¹¤ç•¶å‰å¥å­å­—ç¬¦ä½ç½®

        // å¾ç•¶å‰ç´¢å¼•é–‹å§‹ï¼Œå°‹æ‰¾åŒ¹é…çš„å­—ç¬¦
        while (currentIndex < spansArray.length && sentenceIndex < cleanedSentence.length) {
            const span = spansArray[currentIndex];
            const char = span.textContent.trim(); // å»é™¤å­—ç¬¦å‰å¾Œç©ºç™½

            // å¦‚æœå­—ç¬¦æ˜¯ç©ºç™½å­—ç¬¦ï¼Œå‰‡è·³é
            if (char === '') {
                currentIndex++;
                continue;
            }

            // å¦‚æœå­—ç¬¦åŒ¹é…
            if (char === cleanedSentence[sentenceIndex]) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // é«˜äº®é¡¯ç¤º
                sentenceIndex++;
            } else {
                // å¦‚æœå­—ç¬¦ä¸åŒ¹é…ï¼Œå‰‡æ¸…é™¤ç•¶å‰å¥å­çš„é«˜äº®
                for (let i = currentIndex - sentenceIndex; i < currentIndex; i++) {
                    spansArray[i].style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                }
                sentenceIndex = 0; // é‡ç½®å¥å­ç´¢å¼•
            }

            currentIndex++; // ç§»å‹•åˆ°ä¸‹ä¸€å€‹å­—ç¬¦
        }

        // å¦‚æœå¥å­æ¨™ç¤ºå®Œæˆï¼Œå‰‡ç¹¼çºŒä¸‹ä¸€å€‹å¥å­
        if (sentenceIndex >= cleanedSentence.length) {
            console.log(`å¥å­ ${s + 1} æ¨™ç¤ºå®Œæˆ: ${cleanedSentence}`);
        } else {
            console.error(`å¥å­ ${s + 1} æ¨™ç¤ºå¤±æ•—: ${cleanedSentence}`);
        }
    }
}
// å¯ç§»å‹•æ¡†çš„åŠŸèƒ½
const frame = document.getElementById('movable-frame');
let isDragging = false;
let startX, startY;

// Add CSS styles for frame and resize buttons
const style = document.createElement('style');
style.innerHTML = `
  #movable-frame {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 6px solid red;
    background-color: transparent;
    border-radius: 15px; /* Adjust the value to change the roundness */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */   
    z-index: 2000;
}
 .resize-button {
    position: absolute;
    width: 0;
    height: 0;
    cursor: pointer;
    z-index: 2000;
  } 
  #resize-bottom {
    width: 80px;
    height: 50px;
    background-color: orange;
    border-radius: 0 0 50px 50px; /* Bottom half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */   
    z-index: 2000;
  }
  #resize-right {
    width: 50px;
    height: 80px;
    background-color: orange;
    border-radius: 0 50px 50px 0; /* Right half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */
    white-space: pre-wrap; /* Allow text to wrap */   
    z-index: 2000;
  }
  #read-button {
    position: absolute;
    padding: 5px 10px;
    background-color: orange;
    color: blue;
    border: none;
    cursor: pointer;
    z-index: 2000;
    width: 90px;
    height: 40px;
    font-size:15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    border-top-left-radius: 15px; /* Top-left corner roundness */
    border-top-right-radius: 15px; /* Top-right corner roundness */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Text shadow */    
  }
`;
document.head.appendChild(style);

// Add resize buttons
const buttons = [
  { direction: 'bottom' },
  { direction: 'right' }
];
buttons.forEach(({ direction }) => {
  const button = document.createElement('div');
  button.classList.add('resize-button');
  button.id = `resize-${direction}`;
  document.body.appendChild(button);
});

// Add read button
const readButton = document.createElement('button');
readButton.id = 'read-button';
readButton.textContent = 'æ¡†é¸æœ—è®€';
document.body.appendChild(readButton);

function initializeFramePosition() {
  const frame = document.getElementById('movable-frame');
  frame.style.top = `${frame.offsetTop + 90}px`; // å‘ä¸Šç§»å‹• 40px
  frame.style.left = `${frame.offsetLeft - 20}px`; // å‘ä¸Šç§»å‹• 40px
}

// æ›´æ–°æŒ‰éˆ•ä½ç½®
function updateButtonPositions() {
  const frame = document.getElementById('movable-frame');

  document.getElementById('resize-bottom').style.top = `${frame.offsetTop + frame.offsetHeight}px`;
  document.getElementById('resize-bottom').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 40}px`; // Adjusted for new width
  document.getElementById('resize-right').style.top = `${frame.offsetTop + frame.offsetHeight / 2 - 40}px`; // Adjusted for new height
  document.getElementById('resize-right').style.left = `${frame.offsetLeft + frame.offsetWidth}px`;
  document.getElementById('read-button').style.top = `${frame.offsetTop - 40}px`; // Position above the frame
  document.getElementById('read-button').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 45}px`; // Centered above the frame

  // Add text to the buttons
  document.getElementById('resize-bottom').textContent = 'â†•';
  document.getElementById('resize-right').textContent = 'â†”';

  // Center the text within the buttons
  document.getElementById('resize-bottom').style.display = 'flex';
  document.getElementById('resize-bottom').style.alignItems = 'center';
  document.getElementById('resize-bottom').style.justifyContent = 'center';
  
  document.getElementById('resize-right').style.display = 'flex';
  document.getElementById('resize-right').style.alignItems = 'center';
  document.getElementById('resize-right').style.justifyContent = 'center';
}

// åˆå§‹åŒ–æ¡†çš„ä½ç½®
initializeFramePosition();

frame.addEventListener('mousedown', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  startX = e.clientX - frame.offsetLeft;
  startY = e.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('mousemove', (e) => {
  if (isDragging) {
    frame.style.left = `${e.clientX - startX}px`;
    frame.style.top = `${e.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});

frame.addEventListener('touchstart', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  const touch = e.touches[0];
  startX = touch.clientX - frame.offsetLeft;
  startY = touch.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('touchmove', (e) => {
  if (isDragging) {
    const touch = e.touches[0];
    frame.style.left = `${touch.clientX - startX}px`;
    frame.style.top = `${touch.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('touchend', () => {
  isDragging = false;
});

// Read button click event
readButton.addEventListener('click', readTextInsideFrame);

updateButtonPositions();
 

// åˆ¤æ–· canvas æ˜¯å¦ç‚ºå…¨ç™½
function isCanvasAllWhite(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    for (let i = 0; i < imageData.length; i += 4) {
        if (!(imageData[i] === 255 && imageData[i+1] === 255 && imageData[i+2] === 255 && imageData[i+3] === 255)) {
            return false;
        }
    }
    return true;
}

// è¼”åŠ©å‡½æ•¸ï¼šcanvas è½‰ base64ï¼Œä¾› Gemini åœ–ç‰‡è¾¨è­˜ç”¨
function canvasToBase64(canvas) {
    return canvas.toDataURL("image/png").split(',')[1];
}

// è¼”åŠ©å‡½æ•¸ï¼šGemini åœ–ç‰‡è¾¨è­˜
async function geminiImageDescribe(base64Image) {
    try {
        // å¾ IndexedDB è®€å– API KEYï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨é è¨­å€¼
        let apiKey = await loadApiKeyFromIndexedDB();
        if (!apiKey) {
            apiKey = ''; // é è¨­ API KEY
        }
        
        console.log('é–‹å§‹èª¿ç”¨ Gemini APIï¼ŒAPI KEY é•·åº¦:', apiKey.length);
        
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: "ä½ æ˜¯ä¸€å€‹çµ¦å­¸ç¿’éšœç¤™å­¸ç”Ÿå ±è®€è€ƒé¡Œçš„å ±è®€å“¡ï¼Œä¸è¦ç”¢ç”Ÿ markdown çš„ * ç¬¦è™Ÿï¼Œè«‹å…ˆè®€å‡ºåœ–ç‰‡ä¸­çš„æ‰€æœ‰æ–‡å­—ï¼Œé‡åˆ°ç§‘å­¸æˆ–æ•¸å­¸ç¬¦è™Ÿè«‹è½‰æˆä¸­æ–‡æ–‡å­—çš„è®€æ³•ï¼Œé‡åˆ°æ•¸å­¸åˆ†æ•¸æ™‚ä»¥ä¸­æ–‡è®€æ³•è¡¨ç¤ºï¼Œå¦‚:å¹¾åˆ†ä¹‹å¹¾ï¼Œæ•¸å­¸å¼å­ç„¡é ˆå†ç‰¹åˆ¥èªªæ˜å®ƒæ˜¯ä¸€å€‹å…¬å¼ï¼Œå¦‚æœé€™äº›æ–‡å­—èˆ‡åœ–ç‰‡å…§å®¹æœ‰é—œï¼Œè«‹åˆä½µæè¿°ã€‚ç„¶å¾Œç”¨ç°¡å–®å¥å­æè¿°åœ–ç‰‡ä¸­çš„ç‰©ä»¶ï¼Œä¸è¦è´…è¿°ï¼Œä¸è¦æè¿°å ´æ™¯ã€æ•´é«”ä½ˆå±€æˆ–é¢¨æ ¼ï¼Œä¸è¦ä½¿ç”¨ã€Œåœ–ç‰‡ä¸­ã€ã€ã€Œé¡¯ç¤ºäº†ã€ã€ã€Œåœ–ç‰‡é¡¯ç¤ºã€ç­‰è¡¨è¿°ï¼Œç›´æ¥æè¿°å…§å®¹å³å¯ã€‚å¦‚æœæ–‡å­—éƒ¨åˆ†å·²èƒ½å‘ˆç¾å…¨éƒ¨ï¼Œæè¿°å®Œä¸è¦å†é‡è¤‡é™³è¿°åœ–ç‰‡å…ƒç´ ï¼Œå¦‚:å¼Ÿå¼Ÿåƒäº†å…«åˆ†ä¹‹äº”ç›’é›å¡Šï¼Œä¸è¦å†èªªã€Œåœ–ç‰‡ä¸­é¡¯ç¤ºäº†ä¸€è¡Œä¸­æ–‡å­—å’Œä¸€å€‹åˆ†æ•¸ã€ç­‰è´…è¿°ã€‚é‡åˆ°è‹±æ–‡å­—è«‹å¦‚å¯¦å‘ˆç¾ï¼Œä¸è¦æŠŠXè®€æˆè‰¾å…‹æ–¯ã€‚" },
                            { inline_data: { mime_type: "image/png", data: base64Image } }
                        ]
                    }
                ]
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Gemini API å›æ‡‰éŒ¯èª¤:', response.status, errorText);
            throw new Error(`API è«‹æ±‚å¤±æ•— (${response.status}): ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Gemini API å›æ‡‰:', data);
        
        if (data.error) {
            console.error('Gemini API éŒ¯èª¤:', data.error);
            throw new Error(data.error.message || 'API è¿”å›éŒ¯èª¤');
        }
        
        if (data.candidates && data.candidates.length > 0) {
            const text = data.candidates[0].content.parts[0].text;
            console.log('è¾¨è­˜çµæœ:', text);
            return text;
        } else {
            throw new Error('API å›æ‡‰ä¸­æ²’æœ‰è¾¨è­˜çµæœ');
        }
    } catch (error) {
        console.error('Gemini åœ–ç‰‡è¾¨è­˜éŒ¯èª¤:', error);
        throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“èª¿ç”¨è€…è™•ç†
    }
}

async function readTextInsideFrame() {
    // å¦‚æœæ­£åœ¨é€²è¡Œåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
    if (isImageRecognizing) {
        console.log('åœ–ç‰‡è¾¨è­˜æ­£åœ¨é€²è¡Œä¸­ï¼Œå¿½ç•¥é‡è¤‡è«‹æ±‚');
        return;
    }
    
    // æ¸…é™¤æ¨™è¨˜æ›¿æ›ç·©å­˜
    clearMarkReplacementCache();
    
    // æ¯æ¬¡æ¡†é¸æœ—è®€å‰ï¼Œå…ˆæ¸…é™¤ä¹‹å‰çš„æœ—è®€æ¨™ç¤ºèˆ‡ç™¼éŸ³ç‹€æ…‹
    try {
        // åœæ­¢ç€è¦½å™¨èªéŸ³
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }
        // åœæ­¢è‡ªè¨‚æ’­æ”¾å™¨
        const audioPlayer = document.getElementById('audioPlayer');
        if (audioPlayer) {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
        }
        // æ¸…æ‰æ‰€æœ‰ my-fra ä¸Šçš„èƒŒæ™¯è‰²èˆ‡ spoken æ¨™è¨˜
        const allFraSpans = document.querySelectorAll('#viewerContainer .textLayer my-fra');
        allFraSpans.forEach(span => {
            span.style.backgroundColor = '';
            span.dataset.spoken = '';
        });
    } catch (e) {
        console.error('æ¡†é¸æœ—è®€å‰æ¸…é™¤å…ˆå‰æ¨™ç¤ºæ™‚ç™¼ç”ŸéŒ¯èª¤:', e);
    }
    const frameRect = frame.getBoundingClientRect();
    const viewerContainer = document.getElementById('viewerContainer');
    const pdfCanvas = viewerContainer.querySelector('canvas');

    // å…ˆæŠ“ PDF æ–‡å­—å±¤
    const textLayerDivs = viewerContainer.getElementsByClassName('textLayer');
    let textInsideFrame = '';
    for (let textLayer of textLayerDivs) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            const spanRect = span.getBoundingClientRect();
            if (isInsideFrame(spanRect, frameRect)) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
                // æª¢æŸ¥æ˜¯å¦åœ¨æ¨™è¨˜å€åŸŸå…§ï¼Œå¦‚æœåœ¨ä¸”æ¨™è¨˜æœ‰æ›¿æ›æ–‡å­—ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—
                const textToAdd = getTextWithMarkReplacement(span, textLayer);
                textInsideFrame += textToAdd + '';
            }
        }
    }
    const cleanedText = textInsideFrame.trim().replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    // å–å¾—åœ–ç‰‡ base64
    let base64Image = null;
    let croppedCanvas = null;
    if (pdfCanvas) {
        croppedCanvas = cropCanvas(pdfCanvas, frameRect);
        base64Image = canvasToBase64(croppedCanvas);
    }
    // åˆ¤æ–·æ˜¯å¦æœ‰åœ–ç‰‡å…§å®¹
    let hasImageContent = false;
    if (croppedCanvas && !isCanvasAllWhite(croppedCanvas)) {
        hasImageContent = true;
    }
    // åˆ¤æ–·å…§å®¹
    if (!hasImageContent && cleanedText.length === 0) {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ¡†é¸å€åŸŸå…§æ²’æœ‰æ–‡å­—æˆ–åœ–ç‰‡'
        });
        return;
    }
    // åªè¦æœ‰ PDF æ–‡å­—å±¤ï¼Œå°±åªæœ—è®€ç´”æ–‡å­—ï¼Œä¸é€åœ–ç‰‡çµ¦ AI
    if (cleanedText.length > 0) {
        await new Promise((resolve, reject) => {
            sendTextToTTS(cleanedText, () => {
                resolve();
            });
        });
        return;
    }
    // æ²’æœ‰ PDF æ–‡å­—å±¤ï¼Œæ‰é€åœ–ç‰‡çµ¦ AI
    if (hasImageContent) {
        // æª¢æŸ¥æ¡†é¸å€åŸŸæ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Šï¼Œå¦‚æœé‡ç–Šä¸”æ¨™è¨˜æœ‰æ›¿æ›æ–‡å­—ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—
        const pageMarks = marks[currentPage] || [];
        for (const mark of pageMarks) {
            if (!mark.replacementText || !mark.replacementText.trim()) continue;
            
            // ç²å–æ¨™è¨˜å±¤
            const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
            if (!markLayer) continue;
            
            const markLayerRect = markLayer.getBoundingClientRect();
            const markRect = {
                left: markLayerRect.left + mark.x,
                top: markLayerRect.top + mark.y,
                right: markLayerRect.left + mark.x + mark.width,
                bottom: markLayerRect.top + mark.y + mark.height
            };
            
            // æª¢æŸ¥æ¡†é¸å€åŸŸæ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Š
            const isOverlapping = !(frameRect.right < markRect.left || 
                                    frameRect.left > markRect.right ||
                                    frameRect.bottom < markRect.top ||
                                    frameRect.top > markRect.bottom);
            
            if (isOverlapping) {
                // æ‰¾åˆ°é‡ç–Šçš„æ¨™è¨˜ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—ï¼Œä¸éœ€è¦é€²è¡Œåœ–ç‰‡è¾¨è­˜
                await new Promise((resolve, reject) => {
                    sendTextToTTS(mark.replacementText.trim(), () => {
                        resolve();
                    });
                });
                return;
            }
        }
        
        // æ²’æœ‰æ‰¾åˆ°é‡ç–Šçš„æ¨™è¨˜æˆ–æ¨™è¨˜æ²’æœ‰æ›¿æ›æ–‡å­—ï¼Œæ‰é€²è¡Œåœ–ç‰‡è¾¨è­˜
        // è¨­ç½®æ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        isImageRecognizing = true;
        
        try {
            Swal.fire({
                title: 'æ­£åœ¨è¾¨è­˜åœ–ç‰‡',
                text: 'æ­£åœ¨ä½¿ç”¨ AI è¾¨è­˜åœ–ç‰‡å…§å®¹...ï¼ˆGeminiï¼‰',
                allowOutsideClick: false,
                customClass: {
                    popup: 'swal-high-z-index'
                },
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            const aiDescription = await geminiImageDescribe(base64Image);
            Swal.close();
            //console.log('Gemini åŸå§‹å›å‚³:', aiDescription);
            if (aiDescription && aiDescription.length > 0) {
                // ç›´æ¥ä½¿ç”¨ Gemini åŸå§‹å›å‚³ï¼Œä¸é€²è¡Œä»»ä½•æ¸…ç†
                sendTextToTTS(aiDescription, () => {
                    console.log('åœ–ç‰‡è¾¨è­˜æ–‡å­—æœ—è®€å®Œæˆ');
                    // è¾¨è­˜å®Œæˆï¼Œé‡ç½®æ¨™è¨˜
                    isImageRecognizing = false;
                    isPlayingWaitingMessage = false;
                });
            } else {
                console.error('Gemini å›å‚³çš„å…§å®¹ç‚ºç©º');
                Swal.fire({
                    icon: 'warning',
                    title: 'è¾¨è­˜çµæœç‚ºç©º',
                    text: 'AI ç„¡æ³•è¾¨è­˜åœ–ç‰‡å…§å®¹'
                });
                // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
                isImageRecognizing = false;
                isPlayingWaitingMessage = false;
            }
        } catch (error) {
            console.error('Gemini è¾¨è­˜å¤±æ•—:', error);
            Swal.fire({
                icon: 'error',
                title: 'è¾¨è­˜å¤±æ•—',
                text: 'AI è¾¨è­˜éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚'
            });
            // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
            isImageRecognizing = false;
            isPlayingWaitingMessage = false;
        }
        return;
    }
}

// è¼”åŠ©å‡½æ•¸ï¼šåˆ¤æ–·å…ƒç´ æ˜¯å¦åœ¨æ¡†é¸å€åŸŸå…§
function isInsideFrame(elementRect, frameRect) {
  return (
    elementRect.top >= frameRect.top &&
    elementRect.bottom <= frameRect.bottom &&
    elementRect.left >= frameRect.left &&
    elementRect.right <= frameRect.right
  );
}

// è¼”åŠ©å‡½æ•¸ï¼šæª¢æŸ¥ span æ˜¯å¦åœ¨æ¨™è¨˜å€åŸŸå…§ï¼Œå¦‚æœåœ¨ä¸”æ¨™è¨˜æœ‰æ›¿æ›æ–‡å­—ï¼Œè¿”å›æ›¿æ›æ–‡å­—ï¼›å¦å‰‡è¿”å›åŸå§‹æ–‡å­—
// ä½¿ç”¨ä¸€å€‹ Map ä¾†è¿½è¹¤æ¯å€‹æ¨™è¨˜æ˜¯å¦å·²ç¶“è™•ç†éï¼Œé¿å…é‡è¤‡
const markReplacementCache = new Map();

function getTextWithMarkReplacement(span, textLayer) {
    if (!span || !textLayer) return span ? span.textContent : '';
    
    const spanRect = span.getBoundingClientRect();
    const textLayerRect = textLayer.getBoundingClientRect();
    const spanX = spanRect.left - textLayerRect.left;
    const spanY = spanRect.top - textLayerRect.top;
    const spanRight = spanRect.right - textLayerRect.left;
    const spanBottom = spanRect.bottom - textLayerRect.top;
    
    // ç²å–ç•¶å‰é é¢çš„æ¨™è¨˜
    const pageMarks = marks[currentPage] || [];
    
    // æª¢æŸ¥æ˜¯å¦èˆ‡ä»»ä½•æ¨™è¨˜é‡ç–Š
    for (const mark of pageMarks) {
        if (!mark.replacementText || !mark.replacementText.trim()) continue;
        
        // ç²å–æ¨™è¨˜å±¤
        const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
        if (!markLayer) continue;
        
        const markLayerRect = markLayer.getBoundingClientRect();
        
        // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„ä½ç½®
        const markInTextLayer = {
            left: mark.x + (markLayerRect.left - textLayerRect.left),
            top: mark.y + (markLayerRect.top - textLayerRect.top),
            right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
            bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
        };
        
        // æª¢æŸ¥æ˜¯å¦é‡ç–Š
        const isOverlapping = !(spanRight < markInTextLayer.left || 
                                spanX > markInTextLayer.right ||
                                spanBottom < markInTextLayer.top ||
                                spanY > markInTextLayer.bottom);
        
        if (isOverlapping) {
            // å‰µå»ºæ¨™è¨˜çš„å”¯ä¸€éµ
            const markKey = `${currentPage}_${mark.id}`;
            
            // æª¢æŸ¥é€™å€‹æ¨™è¨˜æ˜¯å¦å·²ç¶“è™•ç†é
            if (!markReplacementCache.has(markKey)) {
                // ç¬¬ä¸€æ¬¡é‡åˆ°é€™å€‹æ¨™è¨˜ï¼Œè¿”å›æ›¿æ›æ–‡å­—ä¸¦æ¨™è¨˜ç‚ºå·²è™•ç†
                markReplacementCache.set(markKey, true);
                return mark.replacementText.trim();
            } else {
                // é€™å€‹æ¨™è¨˜å·²ç¶“è™•ç†éï¼Œè¿”å›ç©ºå­—ç¬¦ä¸²ï¼ˆé¿å…é‡è¤‡ï¼‰
                return '';
            }
        }
    }
    
    // æ²’æœ‰é‡ç–Šçš„æ¨™è¨˜ï¼Œè¿”å›åŸå§‹æ–‡å­—
    return span.textContent;
}

// æ¸…é™¤æ¨™è¨˜æ›¿æ›ç·©å­˜ï¼ˆåœ¨é–‹å§‹æ–°çš„æœ—è®€æ™‚èª¿ç”¨ï¼‰
function clearMarkReplacementCache() {
    markReplacementCache.clear();
}

// è¼”åŠ©å‡½æ•¸ï¼šè£å‰ªCanvaså€åŸŸ
function cropCanvas(sourceCanvas, cropRect) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // è€ƒæ…®è¨­å‚™åƒç´ æ¯”é€²è¡Œç²¾ç¢ºè£å‰ª
  const dpr = window.devicePixelRatio || 1;
  const cropX = (cropRect.left - sourceCanvas.getBoundingClientRect().left) * dpr;
  const cropY = (cropRect.top - sourceCanvas.getBoundingClientRect().top) * dpr;
  const cropWidth = cropRect.width * dpr;
  const cropHeight = cropRect.height * dpr;
  
  // è¨­ç½®æ–°Canvaså°ºå¯¸
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  
  // åŸ·è¡Œè£å‰ªæ“ä½œ
  ctx.drawImage(
    sourceCanvas,
    cropX, cropY, cropWidth, cropHeight,
    0, 0, cropWidth, cropHeight
  );
  
  return canvas;
}

// ç¢ºä¿è¼”åŠ©å‡½æ•¸åœ¨å…¨å±€ä½œç”¨åŸŸå¯ç”¨
if (typeof window !== 'undefined') {
    window.cropCanvas = cropCanvas;
    window.canvasToBase64 = canvasToBase64;
    window.isCanvasAllWhite = isCanvasAllWhite;
    window.geminiImageDescribe = geminiImageDescribe;
}

  let lastTouchElement = null;
  let isImageRecognizing = false; // é˜²æ­¢åœ–ç‰‡è¾¨è­˜é‡è¤‡åŸ·è¡Œ
  let isPlayingWaitingMessage = false; // é˜²æ­¢"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™"èªéŸ³é‡è¤‡æ’­æ”¾

 function wrapTextInFraTags() {
    const markedContentSpans = document.querySelectorAll('span[role="presentation"]');
    
    markedContentSpans.forEach(span => {
        if (!span.dataset.processed) {
            const text = span.textContent;
            const fragment = document.createDocumentFragment();
            
            for (let char of text) {
                const fra = document.createElement('my-fra');
                fra.textContent = char;
                fra.style.cursor = 'pointer'; // å…§è¯æ¨£å¼
                fra.addEventListener('touchstart', highlightText);
                fra.addEventListener('touchmove', highlightText);
                fra.addEventListener('mousedown', startHighlight); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fra.addEventListener('mousemove', highlightText); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fragment.appendChild(fra);
            }
            
            span.innerHTML = '';
            span.appendChild(fragment);
            span.dataset.processed = 'true';
        }
    });
}
let isMouseDown = false;

function startHighlight(event) {
    isMouseDown = true;
    highlightText(event);
}

document.addEventListener('mouseup', () => {
    isMouseDown = false;
});
     function highlightText(event) {
     
    if (!document.getElementById('touchSelectCheckbox').checked) return; // æª¢æŸ¥æ ¸å–æ–¹å¡Šæ˜¯å¦è¢«é¸ä¸­
    if (event.type === 'mousemove' && !isMouseDown) return; // åªæœ‰åœ¨æŒ‰ä½æ»‘é¼ å·¦éµæ™‚æ‰è§¸ç™¼
    
   event.preventDefault(); // é˜²æ­¢å¹³æ¿å·¦å³æˆ–ä¸Šä¸‹æ²å‹•
    
    let element;
    if (event.type === 'touchstart' || event.type === 'touchmove') {
        const touch = event.touches[0];
        element = document.elementFromPoint(touch.clientX, touch.clientY);
    } else if (event.type === 'mousedown' || event.type === 'mousemove') {
        element = event.target;
    }
    
    if (element && element.tagName === 'MY-FRA') {
        if (element !== lastTouchElement) {
            if (element.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                element.style.backgroundColor = ''; // å–æ¶ˆé¸å–
            } else if (element.style.backgroundColor === 'rgba(255, 255, 0, 0.2)') {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // é‡æ–°é¸å–
                element.dataset.spoken = ''; // å–æ¶ˆå·²ç™¼éŸ³æ¨™è¨˜
            } else {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // æ”¹è®ŠèƒŒæ™¯é¡è‰²
            }
            lastTouchElement = element;
        }
    }
}
        function sendHighlightedText() {
            // æ¸…é™¤æ¨™è¨˜æ›¿æ›ç·©å­˜
            clearMarkReplacementCache();

            // æ¯æ¬¡è§¸æ§é¸å–æœ—è®€å‰ï¼Œå…ˆæ¸…é™¤ã€Œä¸Šä¸€è¼ªæœ—è®€ã€ç•™ä¸‹çš„æ¨™è¨˜èˆ‡ç™¼éŸ³ï¼Œä¿ç•™é€™ä¸€æ¬¡ç´…è‰²é¸å–
            try {
                // åœæ­¢ç€è¦½å™¨èªéŸ³
                if (window.speechSynthesis) {
                    window.speechSynthesis.cancel();
                }
                // åœæ­¢è‡ªè¨‚æ’­æ”¾å™¨
                const audioPlayer = document.getElementById('audioPlayer');
                if (audioPlayer) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
                // åƒ…æ¸…é™¤å…ˆå‰æœ—è®€ï¼ˆé»ƒè‰² / spokenï¼‰çš„æ¨™ç¤ºï¼Œä¿ç•™ç›®å‰ä½¿ç”¨è€…ä»¥ç´…è‰²é¸å–çš„å€åŸŸ
                const allFraSpans = document.querySelectorAll('#viewerContainer .textLayer my-fra');
                allFraSpans.forEach(span => {
                    if (span.style.backgroundColor === 'rgba(255, 255, 0, 0.2)' || span.dataset.spoken === 'true') {
                        span.style.backgroundColor = '';
                        span.dataset.spoken = '';
                    }
                });
            } catch (e) {
                console.error('è§¸æ§é¸å–æœ—è®€å‰æ¸…é™¤å…ˆå‰æ¨™ç¤ºæ™‚ç™¼ç”ŸéŒ¯èª¤:', e);
            }
            
            const highlightedText = [];
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                    if (span.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                        // æª¢æŸ¥æ˜¯å¦åœ¨æ¨™è¨˜å€åŸŸå…§ï¼Œå¦‚æœåœ¨ä¸”æ¨™è¨˜æœ‰æ›¿æ›æ–‡å­—ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—
                        const textToAdd = getTextWithMarkReplacement(span, textLayer);
                        highlightedText.push(textToAdd);
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // å·²ç™¼éŸ³çš„æ¨™ç¤º
                        span.dataset.spoken = 'true'; // æ¨™è¨˜ç‚ºå·²ç™¼éŸ³
                    }
                }
            }
            
            const cleanedText = highlightedText.join('').replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
            sendTextToTTS(cleanedText, () => {
                // æœ—è®€å®Œæˆå¾Œçš„å›èª¿
                document.getElementById('sendButton').textContent = "æœ—è®€é¸å–æ–‡å­—";
                document.getElementById('sendButton').classList.remove('button-danger');
                document.getElementById('sendButton').classList.add('button-light');
                isReading = false;
            });
        }

        function clearHighlights() {
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                window.speechSynthesis.cancel();
                    span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                    span.dataset.spoken = ''; // æ¸…é™¤å·²ç™¼éŸ³æ¨™è¨˜
                }
            }
        }

        document.getElementById('sendButton').addEventListener('click', sendHighlightedText);
        document.getElementById('clearButton').addEventListener('click', clearHighlights);
        document.getElementById('touchSelectCheckbox').addEventListener('change', function() {
            const isChecked = this.checked;
            clearHighlights();
            document.getElementById('sendButton').style.display = isChecked ? 'block' : 'none';
            document.getElementById('clearButton').style.display = isChecked ? 'block' : 'none';                        
            document.getElementById('select-all-text').style.display = isChecked ? 'none' : 'block';            
            document.getElementById('movable-frame').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-bottom').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-right').style.display = isChecked ? 'none' : 'block';
            document.getElementById('read-button').style.display = isChecked ? 'none' : 'block';
            
            if (!isChecked) {
            updateButtonPositions();            
            }
        });
        wrapTextInFraTags();
        
        document.getElementById('sendButton').addEventListener('click', function() {
    if (isReading) {
        // å–æ¶ˆæœ—è®€
        window.speechSynthesis.cancel();
        this.textContent = "æœ—è®€é¸å–æ–‡å­—";
        this.classList.remove('button-danger');
        this.classList.add('button-light');
        isReading = false;
    } else {
        // é–‹å§‹æœ—è®€
        sendHighlightedText();
        this.textContent = "å–æ¶ˆæœ—è®€";
        this.classList.remove('button-light');
        this.classList.add('button-danger');
        isReading = true;
    }
});
  
// ä½¿ç”¨ MutationObserver ç›£è½ DOM è®ŠåŒ–
const observer = new MutationObserver((mutationsList, observer) => {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            wrapTextInFraTags();
        }
    }
});

// é…ç½® MutationObserver ç›£è½çš„ç›®æ¨™ç¯€é»å’Œé¸é …
const config = { childList: true, subtree: true };

// ç›£è½æ•´å€‹ document çš„è®ŠåŒ–
observer.observe(document, config);

// ç¢ºä¿åœ¨ DOM å®Œå…¨åŠ è¼‰å¾ŒåŸ·è¡Œ
document.addEventListener('DOMContentLoaded', wrapTextInFraTags);
document.getElementById('resize-bottom').addEventListener('mousedown', (e) => resizeFrame(e, 'bottom'));
document.getElementById('resize-right').addEventListener('mousedown', (e) => resizeFrame(e, 'right'));

document.getElementById('resize-bottom').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'bottom'));
document.getElementById('resize-right').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'right'));

function resizeFrame(e, direction) {
  e.stopPropagation();
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  let startX = e.clientX;
  let startY = e.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    if (direction === 'bottom') {
      let newHeight = startHeight + (e.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (e.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('mousemove', doDrag);
    document.removeEventListener('mouseup', stopDrag);
  }

  document.addEventListener('mousemove', doDrag);
  document.addEventListener('mouseup', stopDrag);
}

function resizeFrameTouch(e, direction) {
  e.stopPropagation();
  e.preventDefault(); // Prevent scrolling
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  const touch = e.touches[0];
  let startX = touch.clientX;
  let startY = touch.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    const touch = e.touches[0];
    if (direction === 'bottom') {
      let newHeight = startHeight + (touch.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (touch.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('touchmove', doDrag);
    document.removeEventListener('touchend', stopDrag);
  }

  document.addEventListener('touchmove', doDrag);
  document.addEventListener('touchend', stopDrag);
}

updateButtonPositions();
});
// ç²å–æ¡†å…ƒç´ 
const frame = document.getElementById('movable-frame');

function showPage(page_no) {
    __PAGE_RENDERING_IN_PROGRESS = 1;
    __CURRENT_PAGE = page_no;
    $("#pdf-next, #pdf-prev").attr('disabled', 'disabled');
    $("#pdf-canvas").hide();
    $("#page-loader").show();
    $("#pdf-current-page").text(page_no);
    __PDF_DOC.getPage(page_no).then(function (page) {
        let viewport = page.getViewport({ scale: 1 });
        let scale = __CANVAS.width / viewport.width;
        viewport = page.getViewport({ scale: scale });
        __CANVAS.height = viewport.height;
        var renderContext = {
            canvasContext: __CANVAS_CTX,
            viewport: viewport
        };
        page.render(renderContext).promise.then(function () {
            __PAGE_RENDERING_IN_PROGRESS = 0;
            $("#pdf-next, #pdf-prev").removeAttr('disabled');
            $("#pdf-canvas").show();
            $("#page-loader").hide();
            return page.getTextContent();
        }).then(function (textContent) {
            var canvas_offset = $("#pdf-canvas").offset();
            $("#text-layer").html('');
            document.getElementById('text-layer').style.setProperty('--scale-factor', viewport.scale);
            $("#text-layer").css({ left: canvas_offset.left + 'px', top: canvas_offset.top + 'px' });
            PDFJS.renderTextLayer({
                textContentSource: textContent,
                container: $("#text-layer").get(0),
                viewport: viewport,
                textDivs: []
            });
            console.log('Text Layer Content:', textContent);
        });
    });
}




     // æ›´æ–°èªé€Ÿé¡¯ç¤º
function updateRate(value) {
    const adjustedValue = Math.max(-50, Math.min(50, Number(value)));
    const speedLabel = document.getElementById('speedLabel');
    const speedPercent = document.getElementById('speedPercent');
    
    if (adjustedValue === 0) {
        speedLabel.textContent = '';
        speedPercent.textContent = '0%';
    } else if (adjustedValue > 0) {
        speedLabel.textContent = 'èªé€ŸåŠ ';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    } else {
        speedLabel.textContent = 'èªé€Ÿæ¸›';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    }
}

// è¨­ç½®åˆå§‹èªé€Ÿ
document.getElementById('speakSpeed').value = -30;
updateRate(-30);

// API KEY ç®¡ç†åŠŸèƒ½
let qrStream = null;
let qrScanInterval = null;

// æ‰“é–‹ API KEY è¨­å®šæ¨¡æ…‹è¦–çª—
document.getElementById('apiKeySettingsButton').addEventListener('click', async () => {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const apiKeyInput = document.getElementById('apiKeyInput');
    
    // è¼‰å…¥ç¾æœ‰çš„ API KEYï¼ˆä¸é¡¯ç¤ºå®Œæ•´ï¼Œåªé¡¯ç¤ºå‰å¾Œå¹¾ä½ï¼‰
    const existingKey = await loadApiKeyFromIndexedDB();
    if (existingKey) {
        const maskedKey = existingKey.length > 8 
            ? existingKey.substring(0, 4) + '...' + existingKey.substring(existingKey.length - 4)
            : '***';
        apiKeyInput.placeholder = `å·²è¨­å®šï¼š${maskedKey}`;
    } else {
        apiKeyInput.placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
    }
    apiKeyInput.value = '';
    
    modal.style.display = 'block';
    overlay.style.display = 'block';
});

// API KEY æ•™å­¸å½ˆçª—é–‹é—œ
const apiKeyHelpButton = document.getElementById('apiKeyHelpButton');
const apiKeyHelpPopup = document.getElementById('apiKeyHelpPopup');
const apiKeyHelpCloseButton = document.getElementById('apiKeyHelpCloseButton');
const apiKeyHelpImage = document.getElementById('apiKeyHelpImage');
const apiKeyImageFullscreen = document.getElementById('apiKeyImageFullscreen');
const apiKeyImageFullscreenClose = document.getElementById('apiKeyImageFullscreenClose');

if (apiKeyHelpButton && apiKeyHelpPopup && apiKeyHelpCloseButton) {
    apiKeyHelpButton.addEventListener('click', () => {
        apiKeyHelpPopup.style.display = 'flex';
    });

    apiKeyHelpCloseButton.addEventListener('click', () => {
        apiKeyHelpPopup.style.display = 'none';
    });

    // é»æ“ŠèƒŒæ™¯ä¹Ÿå¯ä»¥é—œé–‰
    apiKeyHelpPopup.addEventListener('click', (event) => {
        if (event.target === apiKeyHelpPopup) {
            apiKeyHelpPopup.style.display = 'none';
        }
    });
}

// API KEY æ•™å­¸åœ–ç‰‡æ”¾å¤§æª¢è¦–
if (apiKeyHelpImage && apiKeyImageFullscreen && apiKeyImageFullscreenClose) {
    apiKeyHelpImage.addEventListener('click', () => {
        apiKeyImageFullscreen.style.display = 'flex';
    });

    apiKeyImageFullscreenClose.addEventListener('click', () => {
        apiKeyImageFullscreen.style.display = 'none';
    });

    apiKeyImageFullscreen.addEventListener('click', (event) => {
        if (event.target === apiKeyImageFullscreen) {
            apiKeyImageFullscreen.style.display = 'none';
        }
    });
}

// é—œé–‰æ¨¡æ…‹è¦–çª—
function closeApiKeyModal() {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const qrContainer = document.getElementById('qrScannerContainer');
    
    modal.style.display = 'none';
    overlay.style.display = 'none';
    qrContainer.style.display = 'none';
    
    // åœæ­¢ QR code æƒæ
    stopQRScan();
}

document.getElementById('cancelApiKeyButton').addEventListener('click', closeApiKeyModal);
document.getElementById('apiKeyModalOverlay').addEventListener('click', closeApiKeyModal);

// å„²å­˜ API KEY
document.getElementById('saveApiKeyButton').addEventListener('click', async () => {
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKey = apiKeyInput.value.trim();
    
    if (!apiKey) {
        Swal.fire({
            icon: 'warning',
            title: 'è¼¸å…¥ç‚ºç©º',
            text: 'è«‹è¼¸å…¥ API KEY æˆ–æƒæ QR Code'
        });
        return;
    }
    
    try {
        await saveApiKeyToIndexedDB(apiKey);
        Swal.fire({
            icon: 'success',
            title: 'å„²å­˜æˆåŠŸ',
            text: 'API KEY å·²å„²å­˜',
            timer: 1500,
            showConfirmButton: false
        });
        closeApiKeyModal();
    } catch (error) {
        console.error('å„²å­˜ API KEY å¤±æ•—ï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'å„²å­˜å¤±æ•—',
            text: 'ç„¡æ³•å„²å­˜ API KEYï¼Œè«‹é‡è©¦'
        });
    }
});

// åˆªé™¤ API KEY
document.getElementById('deleteApiKeyButton').addEventListener('click', async () => {
    // ç¢ºèªåˆªé™¤
    const result = await Swal.fire({
        icon: 'warning',
        title: 'ç¢ºèªåˆªé™¤',
        text: 'ç¢ºå®šè¦åˆªé™¤ç¾æœ‰çš„ API KEY å—ï¼Ÿ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®šåˆªé™¤',
        cancelButtonText: 'å–æ¶ˆ',
        confirmButtonColor: '#dc3545',
        cancelButtonColor: '#6c757d',
        customClass: {
            popup: 'swal-high-z-index',
            container: 'swal-high-z-index'
        }
    });
    
    if (result.isConfirmed) {
        try {
            await deleteApiKeyFromIndexedDB();
            // æ¸…ç©ºè¼¸å…¥æ¡†å’Œæç¤º
            document.getElementById('apiKeyInput').value = '';
            document.getElementById('apiKeyInput').placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
            
            Swal.fire({
                icon: 'success',
                title: 'åˆªé™¤æˆåŠŸ',
                text: 'API KEY å·²åˆªé™¤',
                timer: 1500,
                showConfirmButton: false,
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
            closeApiKeyModal();
        } catch (error) {
            console.error('åˆªé™¤ API KEY å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'åˆªé™¤å¤±æ•—',
                text: 'ç„¡æ³•åˆªé™¤ API KEYï¼Œè«‹é‡è©¦',
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
        }
    }
});

// åœæ­¢ QR code æƒæ
function stopQRScan() {
    if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
    }
    if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
    }
    const qrVideo = document.getElementById('qrVideo');
    const qrContainer = document.getElementById('qrScannerContainer');
    qrVideo.srcObject = null;
    qrContainer.style.display = 'none';
}

// é–‹å§‹ QR code æƒæ
document.getElementById('scanQRButton').addEventListener('click', async () => {
    const qrContainer = document.getElementById('qrScannerContainer');
    const qrVideo = document.getElementById('qrVideo');
    const qrCanvas = document.getElementById('qrCanvas');
    
    try {
        // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
        qrStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: 'environment' // å„ªå…ˆä½¿ç”¨å¾Œç½®ç›¸æ©Ÿ
            } 
        });
        
        qrVideo.srcObject = qrStream;
        qrVideo.setAttribute('playsinline', true);
        qrContainer.style.display = 'block';
        
        await qrVideo.play();
        
        const videoWidth = qrVideo.videoWidth;
        const videoHeight = qrVideo.videoHeight;
        qrCanvas.width = videoWidth;
        qrCanvas.height = videoHeight;
        
        const ctx = qrCanvas.getContext('2d');
        
        // é–‹å§‹æƒæ
        qrScanInterval = setInterval(() => {
            if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                ctx.drawImage(qrVideo, 0, 0, videoWidth, videoHeight);
                const imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code) {
                    // æ‰¾åˆ° QR codeï¼Œå¡«å…¥ API KEY
                    document.getElementById('apiKeyInput').value = code.data;
                    stopQRScan();
                    Swal.fire({
                        icon: 'success',
                        title: 'æƒææˆåŠŸ',
                        text: 'QR Code å·²è®€å–',
                        timer: 1500,
                        showConfirmButton: false
                    });
                }
            }
        }, 100);
        
    } catch (error) {
        console.error('ç„¡æ³•è¨ªå•ç›¸æ©Ÿï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'ç„¡æ³•è¨ªå•ç›¸æ©Ÿ',
            text: 'è«‹å…è¨±ç€è¦½å™¨è¨ªå•ç›¸æ©Ÿæ¬Šé™ï¼Œæˆ–æ‰‹å‹•è¼¸å…¥ API KEY'
        });
    }
});

// åœæ­¢æƒææŒ‰éˆ•
document.getElementById('stopScanButton').addEventListener('click', stopQRScan);

// ========== å€å¡Šæ¨™è¨˜åŠŸèƒ½ ==========
let isMarkingMode = false;
let isManualMarkingEnabled = false; // è¿½è¹¤æ‰‹å‹•æ¨™è¨˜æ˜¯å¦å·²ç¶“å•Ÿç”¨
let currentMark = null;
let marks = {}; // å­˜å„²æ‰€æœ‰æ¨™è¨˜ {pageNum: [{id, x, y, width, height, text}]}
let markIdCounter = 0;
let originalPdfBytes = null; // ä¿å­˜åŸå§‹PDFå­—ç¯€
let pdfPasswordHash = null; // PDFå¯†ç¢¼å“ˆå¸Œï¼ˆç”¨æ–¼é©—è­‰ï¼‰
let currentSessionPassword = null; // ç•¶å‰æœƒè©±çš„å¯†ç¢¼ï¼ˆé¿å…é‡è¤‡è¼¸å…¥ï¼‰

// å¯†ç¢¼å“ˆå¸Œå‡½æ•¸ï¼ˆä½¿ç”¨ç°¡å–®çš„å“ˆå¸Œç®—æ³•ï¼‰
async function hashPassword(password) {
    if (!password) return null;
    const encoder = new TextEncoder();
    const data = encoder.encode(password);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

// é©—è­‰å¯†ç¢¼
async function verifyPassword(inputPassword) {
    if (!pdfPasswordHash) return true; // æ²’æœ‰å¯†ç¢¼ä¿è­·ï¼Œç›´æ¥é€šé
    if (!inputPassword) return false;
    const inputHash = await hashPassword(inputPassword);
    return inputHash === pdfPasswordHash;
}

// è¦æ±‚è¼¸å…¥å¯†ç¢¼
async function promptPassword(title = 'è¼¸å…¥å¯†ç¢¼', text = 'æ­¤PDFæ¨™è¨˜å·²å—å¯†ç¢¼ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ä»¥ç¹¼çºŒ') {
    const result = await Swal.fire({
        title: title,
        text: text,
        input: 'password',
        inputPlaceholder: 'è«‹è¼¸å…¥å¯†ç¢¼',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®š',
        cancelButtonText: 'å–æ¶ˆ',
        customClass: {
            popup: 'swal-high-z-index'
        },
        inputValidator: (value) => {
            if (!value) {
                return 'è«‹è¼¸å…¥å¯†ç¢¼';
            }
        }
    });
    
    if (result.isConfirmed && result.value) {
        return result.value;
    }
    return null;
}

// æª¢æŸ¥ä¸¦é©—è­‰å¯†ç¢¼ï¼ˆå¦‚æœéœ€è¦ï¼‰
async function checkPasswordProtection() {
    // å¦‚æœæ²’æœ‰å¯†ç¢¼ä¿è­·ï¼Œç›´æ¥é€šé
    if (!pdfPasswordHash) {
        return true;
    }
    
    // å¦‚æœç•¶å‰æœƒè©±å·²ç¶“é©—è­‰éå¯†ç¢¼ï¼Œç›´æ¥é€šé
    if (currentSessionPassword) {
        const isValid = await verifyPassword(currentSessionPassword);
        if (isValid) {
            return true;
        }
        // æœƒè©±å¯†ç¢¼ç„¡æ•ˆï¼Œæ¸…é™¤ä¸¦é‡æ–°é©—è­‰
        currentSessionPassword = null;
    }
    
    // è¦æ±‚è¼¸å…¥å¯†ç¢¼
    const password = await promptPassword('è¼¸å…¥å¯†ç¢¼', 'æ­¤PDFæ¨™è¨˜å·²å—å¯†ç¢¼ä¿è­·ï¼Œè«‹è¼¸å…¥å¯†ç¢¼ä»¥ç·¨è¼¯æ¨™è¨˜');
    if (!password) {
        return false; // ç”¨æˆ¶å–æ¶ˆ
    }
    
    // é©—è­‰å¯†ç¢¼
    const isValid = await verifyPassword(password);
    if (isValid) {
        // ä¿å­˜ç•¶å‰æœƒè©±å¯†ç¢¼
        currentSessionPassword = password;
        return true;
    } else {
        Swal.fire({
            icon: 'error',
            title: 'å¯†ç¢¼éŒ¯èª¤',
            text: 'è¼¸å…¥çš„å¯†ç¢¼ä¸æ­£ç¢º',
            timer: 2000,
            showConfirmButton: false,
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return false;
    }
}

// è¨­å®šPDFæ¨™è¨˜å¯†ç¢¼ï¼ˆç¨ç«‹å‡½æ•¸ï¼‰
async function setPasswordForPdf() {
    if (!pdfDoc || !originalPdfBytes) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•è¨­å®š',
            text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return;
    }
    
    // æª¢æŸ¥ PDFLib æ˜¯å¦å·²è¼‰å…¥
    if (typeof PDFLib === 'undefined') {
        Swal.fire({
            icon: 'error',
            title: 'åº«æœªè¼‰å…¥',
            text: 'PDF-lib åº«å°šæœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return;
    }
    
    // è©¢å•æ˜¯å¦è¦è¨­ç½®å¯†ç¢¼ä¿è­·
    const passwordResult = await Swal.fire({
        title: 'è¨­å®šå¯†ç¢¼ä¿è­·',
        html: `
            <div style="text-align: left; margin-bottom: 15px;">
                <p style="font-size: 13px; color: #666; margin-bottom: 15px;">è¨­å®šå¯†ç¢¼å¾Œï¼Œæ—¥å¾Œç·¨è¼¯ã€åˆªé™¤æˆ–å¢åŠ æ¨™è¨˜æ™‚éœ€è¦è¼¸å…¥å¯†ç¢¼</p>
            </div>
            <div style="text-align: left; width: 100%; box-sizing: border-box;">
                <label for="passwordInput" style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 18px; color: #333;">å¯†ç¢¼ï¼ˆç•™ç©ºå‰‡ç§»é™¤å¯†ç¢¼ä¿è­·ï¼‰ï¼š</label>
                <input type="password" id="passwordInput" class="swal2-input" placeholder="è¼¸å…¥å¯†ç¢¼" style="width: 95%; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="text-align: left; margin-top: 15px; width: 100%; box-sizing: border-box;">
                <label for="confirmPasswordInput" style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 18px; color: #333;">ç¢ºèªå¯†ç¢¼ï¼š</label>
                <input type="password" id="confirmPasswordInput" class="swal2-input" placeholder="å†æ¬¡è¼¸å…¥å¯†ç¢¼" style="width: 95%; font-size: 14px; box-sizing: border-box;">
            </div>
        `,
        width: '70%',
        maxWidth: '450px',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®š',
        cancelButtonText: 'å–æ¶ˆ',
        customClass: {
            popup: 'swal-high-z-index'
        },
        didOpen: () => {
            const passwordInput = document.getElementById('passwordInput');
            if (passwordInput) {
                passwordInput.focus();
            }
        },
        preConfirm: () => {
            const passwordInput = document.getElementById('passwordInput');
            const confirmPasswordInput = document.getElementById('confirmPasswordInput');
            const password = passwordInput ? passwordInput.value : '';
            const confirmPassword = confirmPasswordInput ? confirmPasswordInput.value : '';
            
            if (password && password !== confirmPassword) {
                Swal.showValidationMessage('å…©æ¬¡è¼¸å…¥çš„å¯†ç¢¼ä¸ä¸€è‡´');
                return false;
            }
            
            return password;
        }
    });
    
    if (!passwordResult.isConfirmed) {
        return; // ç”¨æˆ¶å–æ¶ˆ
    }
    
    try {
        Swal.fire({
            title: 'æ­£åœ¨è¨­å®š',
            text: 'æ­£åœ¨è¨­å®šå¯†ç¢¼ä¿è­·...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            },
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        
        const { PDFDocument } = PDFLib;
        const pdfDocLib = await PDFDocument.load(originalPdfBytes);
        
        let passwordHash = null;
        if (passwordResult.value && passwordResult.value.trim()) {
            passwordHash = await hashPassword(passwordResult.value.trim());
            // ä¿å­˜ç•¶å‰æœƒè©±å¯†ç¢¼
            currentSessionPassword = passwordResult.value.trim();
        } else {
            // æ¸…é™¤å¯†ç¢¼
            currentSessionPassword = null;
        }
        
        // è™•ç† keywords é™£åˆ—
        let keywordsArray = pdfDocLib.getKeywords() || [];
        if (typeof keywordsArray === 'string') {
            keywordsArray = keywordsArray ? [keywordsArray] : [];
        } else if (!Array.isArray(keywordsArray)) {
            keywordsArray = [];
        }
        
        if (passwordHash) {
            // ç§»é™¤èˆŠçš„å¯†ç¢¼æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            keywordsArray = keywordsArray.filter(k => !k.includes('PDF_MARKS_PASSWORD:'));
            // æ·»åŠ æ–°çš„å¯†ç¢¼æ¨™è¨˜
            keywordsArray.push(`PDF_MARKS_PASSWORD:${passwordHash}`);
            pdfDocLib.setKeywords(keywordsArray);
            // æ›´æ–°ç•¶å‰æœƒè©±çš„å¯†ç¢¼å“ˆå¸Œ
            pdfPasswordHash = passwordHash;
        } else {
            // æ¸…é™¤å¯†ç¢¼ï¼ˆå¦‚æœä¹‹å‰æœ‰è¨­ç½®ï¼‰
            keywordsArray = keywordsArray.filter(k => !k.includes('PDF_MARKS_PASSWORD:'));
            pdfDocLib.setKeywords(keywordsArray);
            // æ¸…é™¤å¯†ç¢¼å“ˆå¸Œ
            pdfPasswordHash = null;
            currentSessionPassword = null;
        }
        
        // ä¿å­˜æ›´æ–°å¾Œçš„PDFå­—ç¯€
        const pdfBytes = await pdfDocLib.save();
        originalPdfBytes = pdfBytes;
        
        // æ›´æ–°IndexedDBä¸­çš„PDF
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        const fileName = fileParam || 'marked_document.pdf';
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        Swal.fire({
            icon: 'success',
            title: 'è¨­å®šæˆåŠŸ',
            text: passwordHash ? 'å¯†ç¢¼ä¿è­·å·²è¨­å®š' : 'å¯†ç¢¼ä¿è­·å·²ç§»é™¤',
            timer: 1500,
            showConfirmButton: false,
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
    } catch (error) {
        console.error('è¨­å®šå¯†ç¢¼å¤±æ•—:', error);
        Swal.fire({
            icon: 'error',
            title: 'è¨­å®šå¤±æ•—',
            text: 'ç„¡æ³•è¨­å®šå¯†ç¢¼ä¿è­·: ' + error.message,
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
    }
}

// AIæ¨™è¨˜åŠŸèƒ½
async function aiMarkPdf() {
    if (!pdfDoc || !originalPdfBytes) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•æ¨™è¨˜',
            text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return;
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰API KEY
    const apiKey = await loadApiKeyFromIndexedDB();
    if (!apiKey) {
        Swal.fire({
            icon: 'warning',
            title: 'éœ€è¦API KEY',
            text: 'è«‹å…ˆè¨­å®šGemini API KEYæ‰èƒ½ä½¿ç”¨AIæ¨™è¨˜åŠŸèƒ½',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return;
    }
    
    // æª¢æŸ¥æ˜¯å¦å·²æœ‰æ¨™è¨˜
    const hasExistingMarks = Object.keys(marks).length > 0 && 
        Object.values(marks).some(pageMarks => Array.isArray(pageMarks) && pageMarks.length > 0);
    
    let isSupplementMode = false; // æ˜¯å¦ç‚ºè£œå……æ¨¡å¼
    if (hasExistingMarks) {
        const confirmResult = await Swal.fire({
            icon: 'info',
            title: 'é¸æ“‡æ¨™è¨˜æ¨¡å¼',
            html: `
                <p>PDFä¸­å·²æœ‰æ¨™è¨˜ï¼Œè«‹é¸æ“‡ï¼š</p>
                <p style="margin-top: 15px;">
                    <strong>è£œå……æ¨¡å¼</strong>ï¼šAIå°‡æ¨¡ä»¿ç¾æœ‰æ¨™è¨˜é¢¨æ ¼ï¼Œåªè£œå……æœªæ¨™è¨˜çš„å€åŸŸï¼Œä¿ç•™æ‰€æœ‰ç¾æœ‰æ¨™è¨˜<br>
                    <strong>é‡æ–°æ¨™è¨˜</strong>ï¼šåˆªé™¤æ‰€æœ‰ç¾æœ‰æ¨™è¨˜ï¼Œé‡æ–°é€²è¡ŒAIæ¨™è¨˜
                </p>
            `,
            showCancelButton: true,
            confirmButtonText: 'è£œå……æ¨¡å¼',
            cancelButtonText: 'é‡æ–°æ¨™è¨˜',
            confirmButtonColor: '#28a745',
            cancelButtonColor: '#dc3545',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        
        if (confirmResult.isConfirmed) {
            // ç”¨æˆ¶é¸æ“‡è£œå……æ¨¡å¼
            isSupplementMode = true;
        } else if (confirmResult.dismiss === Swal.DismissReason.cancel) {
            // ç”¨æˆ¶é¸æ“‡é‡æ–°æ¨™è¨˜ï¼Œæ¸…é™¤ç¾æœ‰æ¨™è¨˜
            // å°‡åœ¨å¾Œé¢æ¸…é™¤
        } else {
            // ç”¨æˆ¶é—œé–‰å°è©±æ¡†
            return;
        }
    }
    
    // ç”¨æ–¼è¿½è¹¤æ˜¯å¦è¢«å–æ¶ˆ
    let isCancelled = false;
    
    try {
        const swalInstance = Swal.fire({
            title: 'AIæ¨™è¨˜ä¸­',
            text: 'æ­£åœ¨ä½¿ç”¨AIåˆ†æPDFå…§å®¹ä¸¦ç”Ÿæˆæ¨™è¨˜...',
            allowOutsideClick: false,
            showCancelButton: true,
            cancelButtonText: 'å–æ¶ˆ',
            confirmButtonText: '',
            showConfirmButton: false,
            didOpen: () => {
                Swal.showLoading();
                // ç›£è½å–æ¶ˆæŒ‰éˆ•é»æ“Š
                const cancelButton = document.querySelector('.swal2-cancel');
                if (cancelButton) {
                    cancelButton.addEventListener('click', () => {
                        isCancelled = true;
                    });
                }
            },
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        
        // ä¹Ÿç›£è½Swalçš„å–æ¶ˆäº‹ä»¶
        swalInstance.then((result) => {
            // å¦‚æœç”¨æˆ¶é»æ“Šå–æ¶ˆ
            if (result.dismiss === Swal.DismissReason.cancel) {
                isCancelled = true;
            }
        });
        
        // å¦‚æœä¸æ˜¯è£œå……æ¨¡å¼ï¼Œæ¸…é™¤ç¾æœ‰æ¨™è¨˜
        if (!isSupplementMode) {
            marks = {};
            markIdCounter = 0;
        }
        
        // ä¿å­˜ç¾æœ‰æ¨™è¨˜ä¿¡æ¯ï¼ˆç”¨æ–¼è£œå……æ¨¡å¼ï¼‰
        const existingMarksInfo = {};
        if (isSupplementMode) {
            // æ”¶é›†ç¾æœ‰æ¨™è¨˜çš„ä¿¡æ¯ï¼Œä½œç‚ºç¤ºä¾‹å‚³çµ¦AI
            for (const pageNum in marks) {
                if (marks[pageNum] && Array.isArray(marks[pageNum]) && marks[pageNum].length > 0) {
                    existingMarksInfo[pageNum] = marks[pageNum].map(mark => ({
                        text: mark.text || '',
                        description: mark.replacementText ? `æ›¿æ›ç‚ºï¼š${mark.replacementText}` : 'åŸå§‹æ–‡å­—'
                    }));
                }
            }
        }
        
        // éæ­·æ‰€æœ‰é é¢é€²è¡Œæ¨™è¨˜
        const totalPages = pdfDoc.numPages;
        let totalCreatedMarksCount = 0;
        
        // ä¿å­˜ç•¶å‰é é¢ï¼Œæ¨™è¨˜å®Œæˆå¾Œæ¢å¾©
        const originalCurrentPage = currentPage;
        
        // é€é è™•ç†
        for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
            // æª¢æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (isCancelled) {
                Swal.close();
                // æ¢å¾©åˆ°åŸå§‹é é¢
                currentPage = originalCurrentPage;
                renderPage(currentPage);
                Swal.fire({
                    icon: 'info',
                    title: 'å·²å–æ¶ˆ',
                    text: `å·²å–æ¶ˆAIæ¨™è¨˜ï¼Œå·²è™•ç† ${pageNum - 1} / ${totalPages} é `,
                    timer: 2000,
                    showConfirmButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    }
                });
                return;
            }
            
            // æ›´æ–°é€²åº¦é¡¯ç¤ºï¼ˆåŒ…å«å–æ¶ˆæŒ‰éˆ•ï¼‰
            Swal.update({
                title: 'AIæ¨™è¨˜ä¸­',
                text: `æ­£åœ¨è™•ç†ç¬¬ ${pageNum} / ${totalPages} é ...`,
                allowOutsideClick: false,
                showCancelButton: true,
                cancelButtonText: 'å–æ¶ˆ',
                showConfirmButton: false
            });
            
            // æ¸²æŸ“ç•¶å‰é é¢ä»¥ç²å–æ–‡å­—å±¤å’Œæ¨™è¨˜å±¤
            await new Promise((resolve) => {
                const oldPage = currentPage;
                currentPage = pageNum;
                renderPage(pageNum);
                // ç­‰å¾…é é¢æ¸²æŸ“å®Œæˆ
                setTimeout(() => {
                    resolve();
                }, 500);
            });
            
            // ç²å–ç•¶å‰é é¢çš„æ–‡å­—å…§å®¹
            const page = await pdfDoc.getPage(pageNum);
            const textContent = await page.getTextContent();
            
            // æå–æ‰€æœ‰æ–‡å­—
            let fullText = '';
            textContent.items.forEach(item => {
                if (item.str) {
                    fullText += item.str + ' ';
                }
            });
            
            // æª¢æŸ¥æ˜¯å¦è¢«å–æ¶ˆ
            if (isCancelled) {
                Swal.close();
                // æ¢å¾©åˆ°åŸå§‹é é¢
                currentPage = originalCurrentPage;
                renderPage(currentPage);
                Swal.fire({
                    icon: 'info',
                    title: 'å·²å–æ¶ˆ',
                    text: `å·²å–æ¶ˆAIæ¨™è¨˜ï¼Œå·²è™•ç† ${pageNum - 1} / ${totalPages} é `,
                    timer: 2000,
                    showConfirmButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    }
                });
                return;
            }
            
            // å¦‚æœé é¢æ²’æœ‰æ–‡å­—ï¼Œè·³é
            if (!fullText.trim()) {
                console.log(`ç¬¬ ${pageNum} é æ²’æœ‰æ–‡å­—å…§å®¹ï¼Œè·³é`);
                continue;
            }
            
            // èª¿ç”¨Gemini APIåˆ†ææ–‡å­—ä¸¦ç”Ÿæˆæ¨™è¨˜å»ºè­°
            const prompt = `è«‹åˆ†æä»¥ä¸‹PDFé é¢çš„æ–‡å­—å…§å®¹ï¼Œæ ¹æ“šèªæ„å’Œé‚è¼¯çµæ§‹ï¼Œè­˜åˆ¥å‡ºæ‡‰è©²è¢«æ¨™è¨˜çš„é‡è¦å€å¡Šã€‚

**æ¨™è¨˜è¦å‰‡ï¼š**

1. **è€ƒå·é¡å…§å®¹è­˜åˆ¥**ï¼š
   - å¦‚æœå…§å®¹åŒ…å«é¡Œè™Ÿï¼ˆå¦‚ã€Œ1.ã€ã€Œ2.ã€ã€Œç¬¬1é¡Œã€ç­‰ï¼‰å’Œé¸æ“‡é¡Œé¸é …ï¼ˆå¦‚ã€Œ(A)ã€ã€Œ(B)ã€ã€Œ(C)ã€ã€Œ(D)ã€æˆ–ã€ŒA.ã€ã€ŒB.ã€ã€ŒC.ã€ã€ŒD.ã€æˆ–ã€Œâ‘ ã€ã€Œâ‘¡ã€ã€Œâ‘¢ã€ã€Œâ‘£ã€ç­‰ï¼‰ï¼Œå‰‡åˆ¤å®šç‚ºè€ƒå·é¡å…§å®¹
   
2. **è€ƒå·é¡å…§å®¹çš„æ¨™è¨˜æ–¹å¼**ï¼š
   - å°‡æ¯ä¸€é¡Œçš„**é¡Œå¹¹å’Œæ‰€æœ‰é¸é …**æ¨™è¨˜ç‚º**åŒä¸€å€‹å€å¡Š**
   - ä¾‹å¦‚ï¼šç¬¬1é¡ŒåŒ…å«é¡Œå¹¹ã€Œä¸‹åˆ—å“ªå€‹é¸é …æ­£ç¢ºï¼Ÿã€å’Œé¸é …ã€Œ(A)é¸é …1 (B)é¸é …2 (C)é¸é …3 (D)é¸é …4ã€ï¼Œå‰‡å°‡æ•´å€‹å…§å®¹ï¼ˆå¾é¡Œè™Ÿåˆ°æœ€å¾Œä¸€å€‹é¸é …ï¼‰æ¨™è¨˜ç‚ºä¸€å€‹å€å¡Š
   - æ¯é¡Œç¨ç«‹æ¨™è¨˜ï¼Œä¸è¦å°‡å¤šé¡Œåˆä½µæˆä¸€å€‹å€å¡Š
   - ç¢ºä¿é¡Œå¹¹å’Œæ‰€æœ‰é¸é …éƒ½åœ¨åŒä¸€å€‹å€å¡Šå…§

3. **ä¸€èˆ¬å…§å®¹çš„æ¨™è¨˜æ–¹å¼**ï¼ˆéè€ƒå·é¡ï¼Œå¦‚æ–‡ç« ã€èªªæ˜ã€æ®µè½ç­‰ï¼‰ï¼š
   - ä»¥æ­£å¸¸æ®µè½ç‚ºå–®ä½æ¨™è¨˜
   - æ¯å€‹å®Œæ•´çš„æ®µè½ã€æ¨™é¡Œã€é‡è¦èªªæ˜ç­‰æ¨™è¨˜ç‚ºä¸€å€‹å€å¡Š
   - ä¿æŒèªæ„å®Œæ•´æ€§

è«‹ä»¥JSONæ ¼å¼è¿”å›æ¨™è¨˜å»ºè­°ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{
  "marks": [
    {
      "text": "è¦æ¨™è¨˜çš„æ–‡å­—å…§å®¹ï¼ˆè€ƒå·ï¼šå®Œæ•´åŒ…å«é¡Œå¹¹å’Œæ‰€æœ‰é¸é …ï¼›ä¸€èˆ¬å…§å®¹ï¼šå®Œæ•´æ®µè½ï¼‰",
      "description": "é€™å€‹æ¨™è¨˜çš„èªªæ˜"
    }
  ]
}

æ–‡å­—å…§å®¹ï¼š
${fullText.trim()}

è«‹åªè¿”å›JSONæ ¼å¼ï¼Œä¸è¦åŒ…å«å…¶ä»–èªªæ˜æ–‡å­—ã€‚`;
            
            // æª¢æŸ¥æ˜¯å¦è¢«å–æ¶ˆï¼ˆåœ¨APIèª¿ç”¨å‰ï¼‰
            if (isCancelled) {
                Swal.close();
                // æ¢å¾©åˆ°åŸå§‹é é¢
                currentPage = originalCurrentPage;
                renderPage(currentPage);
                Swal.fire({
                    icon: 'info',
                    title: 'å·²å–æ¶ˆ',
                    text: `å·²å–æ¶ˆAIæ¨™è¨˜ï¼Œå·²è™•ç† ${pageNum - 1} / ${totalPages} é `,
                    timer: 2000,
                    showConfirmButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    }
                });
                return;
            }
            
            try {
                const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        contents: [
                            {
                                role: "user",
                                parts: [
                                    { text: prompt }
                                ]
                            }
                        ]
                    })
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`ç¬¬ ${pageNum} é  Gemini API å›æ‡‰éŒ¯èª¤:`, response.status, errorText);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                const data = await response.json();
                
                if (data.error) {
                    console.error(`ç¬¬ ${pageNum} é  Gemini API éŒ¯èª¤:`, data.error);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                if (!data.candidates || data.candidates.length === 0) {
                    console.warn(`ç¬¬ ${pageNum} é  API å›æ‡‰ä¸­æ²’æœ‰çµæœ`);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                // æª¢æŸ¥æ˜¯å¦è¢«å–æ¶ˆï¼ˆåœ¨è™•ç†AIå›æ‡‰å‰ï¼‰
                if (isCancelled) {
                    Swal.close();
                    // æ¢å¾©åˆ°åŸå§‹é é¢
                    currentPage = originalCurrentPage;
                    renderPage(currentPage);
                    Swal.fire({
                        icon: 'info',
                        title: 'å·²å–æ¶ˆ',
                        text: `å·²å–æ¶ˆAIæ¨™è¨˜ï¼Œå·²è™•ç† ${pageNum - 1} / ${totalPages} é `,
                        timer: 2000,
                        showConfirmButton: false,
                        customClass: {
                            popup: 'swal-high-z-index'
                        }
                    });
                    return;
                }
                
                const aiResponse = data.candidates[0].content.parts[0].text;
                console.log(`ç¬¬ ${pageNum} é  AIå›æ‡‰:`, aiResponse);
                
                // è§£æAIå›æ‡‰ï¼ˆå˜—è©¦æå–JSONï¼‰
                let markSuggestions = [];
                try {
                    // å˜—è©¦æå–JSONéƒ¨åˆ†
                    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const jsonData = JSON.parse(jsonMatch[0]);
                        if (jsonData.marks && Array.isArray(jsonData.marks)) {
                            markSuggestions = jsonData.marks;
                        }
                    }
                } catch (parseError) {
                    console.error(`ç¬¬ ${pageNum} é  è§£æAIå›æ‡‰å¤±æ•—:`, parseError);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                if (markSuggestions.length === 0) {
                    console.log(`ç¬¬ ${pageNum} é  AIç„¡æ³•è­˜åˆ¥å‡ºéœ€è¦æ¨™è¨˜çš„å…§å®¹`);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                // æ ¹æ“šAIå»ºè­°å‰µå»ºæ¨™è¨˜
                // éœ€è¦åœ¨æ–‡å­—å±¤ä¸­æ‰¾åˆ°å°æ‡‰çš„æ–‡å­—ä½ç½®
                const textLayer = document.querySelector('.textLayer');
                if (!textLayer) {
                    console.warn(`ç¬¬ ${pageNum} é  æ‰¾ä¸åˆ°æ–‡å­—å±¤`);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                const textLayerRect = textLayer.getBoundingClientRect();
                const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
                if (!markLayer) {
                    console.warn(`ç¬¬ ${pageNum} é  æ‰¾ä¸åˆ°æ¨™è¨˜å±¤`);
                    continue; // è·³éé€™ä¸€é ï¼Œç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                }
                
                const markLayerRect = markLayer.getBoundingClientRect();
                const spans = textLayer.getElementsByTagName('my-fra');
                
                // ç‚ºæ¯å€‹AIå»ºè­°å‰µå»ºæ¨™è¨˜
                let pageCreatedMarksCount = 0;
                
                // å…ˆæ”¶é›†æ‰€æœ‰spançš„æ–‡å­—å’Œä½ç½®ä¿¡æ¯ï¼ˆä¿æŒåŸå§‹é †åºç”¨æ–¼æ–‡å­—åŒ¹é…ï¼‰
                const spanData = [];
                for (let span of spans) {
                    const rect = span.getBoundingClientRect();
                    spanData.push({
                        span: span,
                        text: span.textContent,
                        x: rect.left - textLayerRect.left,
                        y: rect.top - textLayerRect.top,
                        right: rect.right - textLayerRect.left,
                        bottom: rect.bottom - textLayerRect.top,
                        centerX: (rect.left + rect.right) / 2 - textLayerRect.left,
                        centerY: (rect.top + rect.bottom) / 2 - textLayerRect.top
                    });
                }
                
                // æ§‹å»ºå®Œæ•´æ–‡å­—å’Œä½ç½®æ˜ å°„ï¼ˆä½¿ç”¨åŸå§‹é †åºï¼Œç¢ºä¿èˆ‡AIè¿”å›çš„æ–‡å­—åŒ¹é…ï¼‰
                let fullTextFromSpans = '';
                spanData.forEach(data => {
                    fullTextFromSpans += data.text;
                });
                
                // æª¢æ¸¬æ˜¯å¦ç‚ºç›´æ›¸ï¼ˆç”¨æ–¼å¾ŒçºŒåº§æ¨™è¨ˆç®—å„ªåŒ–ï¼‰
                let verticalTextDetected = false;
                if (spanData.length > 10) {
                    let narrowSpans = 0;
                    let xVariance = 0;
                    let avgX = 0;
                    let avgWidth = 0;
                    
                    spanData.forEach(data => {
                        const width = data.right - data.x;
                        const height = data.bottom - data.y;
                        avgX += data.centerX;
                        avgWidth += width;
                        if (width < height * 0.8) {
                            narrowSpans++;
                        }
                    });
                    
                    avgX /= spanData.length;
                    avgWidth /= spanData.length;
                    
                    spanData.forEach(data => {
                        xVariance += Math.pow(data.centerX - avgX, 2);
                    });
                    xVariance = Math.sqrt(xVariance / spanData.length);
                    
                    // å¦‚æœå¤§éƒ¨åˆ†spanæ˜¯çª„çš„ï¼ˆå¯¬åº¦å°æ–¼é«˜åº¦ï¼‰ï¼Œä¸”Xåº§æ¨™è®ŠåŒ–è¼ƒå°ï¼Œåˆ¤å®šç‚ºç›´æ›¸
                    if (narrowSpans > spanData.length * 0.6 && xVariance < avgWidth * 3) {
                        verticalTextDetected = true;
                    }
                }
                
                for (const suggestion of markSuggestions) {
                    const targetText = suggestion.text.trim();
                    if (!targetText) continue;
                    
                    // åœ¨å®Œæ•´æ–‡å­—ä¸­æŸ¥æ‰¾ç›®æ¨™æ–‡å­—çš„ä½ç½®
                    const targetIndex = fullTextFromSpans.indexOf(targetText);
                    if (targetIndex === -1) {
                        // å˜—è©¦æ¨¡ç³ŠåŒ¹é…ï¼ˆç§»é™¤ç©ºæ ¼ï¼‰
                        const targetTextNoSpace = targetText.replace(/\s+/g, '');
                        const fullTextNoSpace = fullTextFromSpans.replace(/\s+/g, '');
                        const fuzzyIndex = fullTextNoSpace.indexOf(targetTextNoSpace);
                        if (fuzzyIndex === -1) continue;
                        
                        // ä½¿ç”¨æ¨¡ç³ŠåŒ¹é…çš„ä½ç½®ï¼ˆè¿‘ä¼¼ï¼‰
                        let charCount = 0;
                        let startSpanIndex = -1;
                        let endSpanIndex = -1;
                        
                        for (let i = 0; i < spanData.length; i++) {
                            const prevCount = charCount;
                            charCount += spanData[i].text.replace(/\s+/g, '').length;
                            if (startSpanIndex === -1 && charCount > fuzzyIndex) {
                                startSpanIndex = i;
                            }
                            if (charCount >= fuzzyIndex + targetTextNoSpace.length) {
                                endSpanIndex = i;
                                break;
                            }
                        }
                        
                        if (startSpanIndex !== -1 && endSpanIndex !== -1) {
                            // æ”¶é›†æ‰€æœ‰ç›¸é—œçš„spanæ•¸æ“š
                            const relevantSpans = [];
                            for (let i = startSpanIndex; i <= endSpanIndex; i++) {
                                relevantSpans.push(spanData[i]);
                            }
                            
                            // è¨ˆç®—é‚Šç•Œæ¡†ï¼ˆè€ƒæ…®ç›´æ›¸å’Œæ©«æ›¸ï¼‰
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            relevantSpans.forEach(data => {
                                minX = Math.min(minX, data.x);
                                minY = Math.min(minY, data.y);
                                maxX = Math.max(maxX, data.right);
                                maxY = Math.max(maxY, data.bottom);
                            });
                            
                            const x = minX;
                            const y = minY;
                            const width = maxX - minX;
                            const height = maxY - minY;
                            
                            // è½‰æ›ç‚ºç›¸å°æ–¼æ¨™è¨˜å±¤çš„åº§æ¨™
                            const markX = x + (textLayerRect.left - markLayerRect.left);
                            const markY = y + (textLayerRect.top - markLayerRect.top);
                            
                            if (width > 10 && height > 10) {
                                // æª¢æŸ¥æ˜¯å¦èˆ‡ç¾æœ‰æ¨™è¨˜é‡ç–Šï¼ˆè£œå……æ¨¡å¼ï¼‰
                                if (isSupplementMode && marks[pageNum]) {
                                    let overlaps = false;
                                    for (const existingMark of marks[pageNum]) {
                                        // è¨ˆç®—é‡ç–Šå€åŸŸ
                                        const overlapX = Math.max(0, Math.min(markX + width, existingMark.x + existingMark.width) - Math.max(markX, existingMark.x));
                                        const overlapY = Math.max(0, Math.min(markY + height, existingMark.y + existingMark.height) - Math.max(markY, existingMark.y));
                                        const overlapArea = overlapX * overlapY;
                                        const newMarkArea = width * height;
                                        const existingMarkArea = existingMark.width * existingMark.height;
                                        
                                        // å¦‚æœé‡ç–Šé¢ç©è¶…éæ–°æ¨™è¨˜æˆ–ç¾æœ‰æ¨™è¨˜çš„30%ï¼Œèªç‚ºæ˜¯é‡ç–Š
                                        if (overlapArea > newMarkArea * 0.3 || overlapArea > existingMarkArea * 0.3) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                    
                                    if (overlaps) {
                                        console.log(`ç¬¬ ${pageNum} é  è·³éèˆ‡ç¾æœ‰æ¨™è¨˜é‡ç–Šçš„æ¨™è¨˜:`, targetText.substring(0, 20));
                                        continue; // è·³éé‡ç–Šçš„æ¨™è¨˜
                                    }
                                }
                                
                                if (!marks[pageNum]) {
                                    marks[pageNum] = [];
                                }
                                
                                const mark = {
                                    id: markIdCounter++,
                                    x: markX,
                                    y: markY,
                                    width: width,
                                    height: height,
                                    text: targetText,
                                    replacementText: ''
                                };
                                
                                marks[pageNum].push(mark);
                                pageCreatedMarksCount++;
                            }
                        }
                    } else {
                        // ç²¾ç¢ºåŒ¹é…
                        let charCount = 0;
                        let startSpanIndex = -1;
                        let endSpanIndex = -1;
                        
                        for (let i = 0; i < spanData.length; i++) {
                            const prevCount = charCount;
                            charCount += spanData[i].text.length;
                            if (startSpanIndex === -1 && charCount > targetIndex) {
                                startSpanIndex = i;
                            }
                            if (charCount >= targetIndex + targetText.length) {
                                endSpanIndex = i;
                                break;
                            }
                        }
                        
                        if (startSpanIndex !== -1 && endSpanIndex !== -1) {
                            // æ”¶é›†æ‰€æœ‰ç›¸é—œçš„spanæ•¸æ“š
                            const relevantSpans = [];
                            for (let i = startSpanIndex; i <= endSpanIndex; i++) {
                                relevantSpans.push(spanData[i]);
                            }
                            
                            // è¨ˆç®—é‚Šç•Œæ¡†ï¼ˆè€ƒæ…®ç›´æ›¸å’Œæ©«æ›¸ï¼‰
                            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                            relevantSpans.forEach(data => {
                                minX = Math.min(minX, data.x);
                                minY = Math.min(minY, data.y);
                                maxX = Math.max(maxX, data.right);
                                maxY = Math.max(maxY, data.bottom);
                            });
                            
                            const x = minX;
                            const y = minY;
                            const width = maxX - minX;
                            const height = maxY - minY;
                            
                            // è½‰æ›ç‚ºç›¸å°æ–¼æ¨™è¨˜å±¤çš„åº§æ¨™
                            const markX = x + (textLayerRect.left - markLayerRect.left);
                            const markY = y + (textLayerRect.top - markLayerRect.top);
                            
                            if (width > 10 && height > 10) {
                                // æª¢æŸ¥æ˜¯å¦èˆ‡ç¾æœ‰æ¨™è¨˜é‡ç–Šï¼ˆè£œå……æ¨¡å¼ï¼‰
                                if (isSupplementMode && marks[pageNum]) {
                                    let overlaps = false;
                                    for (const existingMark of marks[pageNum]) {
                                        // è¨ˆç®—é‡ç–Šå€åŸŸ
                                        const overlapX = Math.max(0, Math.min(markX + width, existingMark.x + existingMark.width) - Math.max(markX, existingMark.x));
                                        const overlapY = Math.max(0, Math.min(markY + height, existingMark.y + existingMark.height) - Math.max(markY, existingMark.y));
                                        const overlapArea = overlapX * overlapY;
                                        const newMarkArea = width * height;
                                        const existingMarkArea = existingMark.width * existingMark.height;
                                        
                                        // å¦‚æœé‡ç–Šé¢ç©è¶…éæ–°æ¨™è¨˜æˆ–ç¾æœ‰æ¨™è¨˜çš„30%ï¼Œèªç‚ºæ˜¯é‡ç–Š
                                        if (overlapArea > newMarkArea * 0.3 || overlapArea > existingMarkArea * 0.3) {
                                            overlaps = true;
                                            break;
                                        }
                                    }
                                    
                                    if (overlaps) {
                                        console.log(`ç¬¬ ${pageNum} é  è·³éèˆ‡ç¾æœ‰æ¨™è¨˜é‡ç–Šçš„æ¨™è¨˜:`, targetText.substring(0, 20));
                                        continue; // è·³éé‡ç–Šçš„æ¨™è¨˜
                                    }
                                }
                                
                                if (!marks[pageNum]) {
                                    marks[pageNum] = [];
                                }
                                
                                const mark = {
                                    id: markIdCounter++,
                                    x: markX,
                                    y: markY,
                                    width: width,
                                    height: height,
                                    text: targetText,
                                    replacementText: ''
                                };
                                
                                marks[pageNum].push(mark);
                                pageCreatedMarksCount++;
                            }
                        }
                    }
                }
                
                totalCreatedMarksCount += pageCreatedMarksCount;
                console.log(`ç¬¬ ${pageNum} é å‰µå»ºäº† ${pageCreatedMarksCount} å€‹æ¨™è¨˜`);
            } catch (pageError) {
                console.error(`ç¬¬ ${pageNum} é è™•ç†å¤±æ•—:`, pageError);
                // ç¹¼çºŒè™•ç†ä¸‹ä¸€é 
                continue;
            }
        }
        
        // æ¢å¾©åˆ°åŸå§‹é é¢
        currentPage = originalCurrentPage;
        renderPage(currentPage);
        
        // æª¢æŸ¥æ˜¯å¦è¢«å–æ¶ˆï¼ˆåœ¨æœ€å¾Œæª¢æŸ¥ä¸€æ¬¡ï¼‰
        if (isCancelled) {
            // æ¢å¾©åˆ°åŸå§‹é é¢
            currentPage = originalCurrentPage;
            renderPage(currentPage);
            return;
        }
        
        Swal.close();
        
        if (totalCreatedMarksCount > 0) {
            // æ¸²æŸ“æ¨™è¨˜
            renderMarks();
            
            // ä¿å­˜æ¨™è¨˜åˆ°PDF
            await saveMarksToPdf();
            
            Swal.fire({
                icon: 'success',
                title: isSupplementMode ? 'AIè£œå……æ¨™è¨˜å®Œæˆ' : 'AIæ¨™è¨˜å®Œæˆ',
                text: isSupplementMode 
                    ? `å·²æˆåŠŸè™•ç† ${totalPages} é ï¼Œå…±è£œå…… ${totalCreatedMarksCount} å€‹æ–°æ¨™è¨˜ï¼Œç¾æœ‰æ¨™è¨˜å·²ä¿ç•™ï¼Œæ‚¨å¯ä»¥æ‰‹å‹•ç·¨è¼¯æˆ–èª¿æ•´é€™äº›æ¨™è¨˜`
                    : `å·²æˆåŠŸè™•ç† ${totalPages} é ï¼Œå…±å‰µå»º ${totalCreatedMarksCount} å€‹æ¨™è¨˜ï¼Œæ‚¨å¯ä»¥æ‰‹å‹•ç·¨è¼¯æˆ–èª¿æ•´é€™äº›æ¨™è¨˜`,
                timer: 2000,
                showConfirmButton: false,
                customClass: {
                    popup: 'swal-high-z-index'
                }
            });
        } else {
            Swal.fire({
                icon: 'warning',
                title: 'ç„¡æ³•å‰µå»ºæ¨™è¨˜',
                text: `å·²è™•ç† ${totalPages} é ï¼Œä½†ç„¡æ³•å‰µå»ºä»»ä½•æ¨™è¨˜`,
                timer: 2000,
                showConfirmButton: false,
                customClass: {
                    popup: 'swal-high-z-index'
                }
            });
        }
    } catch (error) {
        console.error('AIæ¨™è¨˜å¤±æ•—:', error);
        Swal.close();
        Swal.fire({
            icon: 'error',
            title: 'AIæ¨™è¨˜å¤±æ•—',
            text: 'ç„¡æ³•å®ŒæˆAIæ¨™è¨˜: ' + error.message,
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
    }
}

// å•Ÿç”¨æ‰‹å‹•æ¨™è¨˜åŠŸèƒ½ï¼ˆç¨ç«‹å‡½æ•¸ï¼Œä¸ä¾è³´ toggleMarkingModeï¼‰
function enableManualMarking() {
    console.log('enableManualMarking è¢«èª¿ç”¨, isMarkingMode:', isMarkingMode, 'isManualMarkingEnabled:', isManualMarkingEnabled);
    
    // å¦‚æœå·²ç¶“å•Ÿç”¨ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡é»æ“Š
    if (isManualMarkingEnabled) {
        console.log('æ‰‹å‹•æ¨™è¨˜å·²ç¶“å•Ÿç”¨ï¼Œè·³éé‡è¤‡èª¿ç”¨');
        return;
    }
    
    if (!pdfDoc) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•æ¨™è¨˜',
            text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ',
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
        return;
    }
    
    // ç¢ºä¿æ¨™è¨˜æ¨¡å¼å·²å•Ÿç”¨ï¼ˆå¦‚æœæ²’æœ‰ï¼Œç›´æ¥è¿”å›ï¼Œå› ç‚ºæ‡‰è©²ç”± toggleMarkingMode ä¾†è¨­ç½®ï¼‰
    if (!isMarkingMode) {
        console.log('æ¨™è¨˜æ¨¡å¼æœªå•Ÿç”¨ï¼Œè·³é enableManualMarking');
        return;
    }
    
    // ä½¿ç”¨CSSé¡ä¾†è¨­ç½®åå­—æ¸¸æ¨™ï¼ˆç«‹å³è¨­ç½®ï¼Œç¢ºä¿æ¸¸æ¨™ç«‹å³é¡¯ç¤ºï¼‰
    document.body.classList.add('marking-mode-active');
    document.body.style.cursor = 'crosshair';
    console.log('å·²è¨­ç½® body åå­—æ¸¸æ¨™');
    
    // ç¢ºä¿ PDF viewer å’Œ canvas ä¹Ÿé¡¯ç¤ºåå­—æ¸¸æ¨™ï¼ˆä½¿ç”¨!importantç¢ºä¿å„ªå…ˆç´šï¼‰
    let pdfViewersForCursor = document.querySelectorAll('.pdf-viewer');
    console.log('æ‰¾åˆ° PDF viewers:', pdfViewersForCursor.length);
    pdfViewersForCursor.forEach(viewer => {
        viewer.style.setProperty('cursor', 'crosshair', 'important');
        viewer.style.cursor = 'crosshair';
    });
    let canvasesForCursor = document.querySelectorAll('canvas');
    console.log('æ‰¾åˆ° canvases:', canvasesForCursor.length);
    canvasesForCursor.forEach(canvas => {
        canvas.style.setProperty('cursor', 'crosshair', 'important');
        canvas.style.cursor = 'crosshair';
    });
    
    // å•Ÿç”¨æ¨™è¨˜å±¤çš„äº‹ä»¶å’Œé¡¯ç¤º
    const markLayers = document.querySelectorAll('.mark-layer');
    console.log('æ‰¾åˆ°æ¨™è¨˜å±¤:', markLayers.length);
    markLayers.forEach(layer => {
        layer.classList.add('marking-mode');
        layer.classList.remove('hidden');
        layer.style.display = 'block';
        layer.style.visibility = 'visible';
        layer.style.pointerEvents = 'auto';
        // ç¢ºä¿æ¨™è¨˜å±¤åœ¨æœ€ä¸Šå±¤ï¼Œä¸è¢« textLayer é®æ“‹
        layer.style.zIndex = '201';
        console.log('å·²è¨­ç½®æ¨™è¨˜å±¤æ¨£å¼:', layer.dataset.pageNum);
    });
    
    // ç¢ºä¿ textLayer ä¸æœƒé®æ“‹æ¨™è¨˜å±¤ï¼ˆåœ¨æ¨™è¨˜æ¨¡å¼ä¸‹ï¼‰
    const textLayers = document.querySelectorAll('.textLayer');
    textLayers.forEach(textLayer => {
        // åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹ï¼ŒtextLayer æ‡‰è©²åœ¨æ¨™è¨˜å±¤ä¸‹æ–¹
        textLayer.style.pointerEvents = 'none'; // è®“é»æ“Šäº‹ä»¶ç©¿é€åˆ°æ¨™è¨˜å±¤
        console.log('å·²è¨­ç½® textLayer pointer-events: none');
    });
    
    // åœ¨ PDF viewer å’Œæ¨™è¨˜å±¤ä¸Šç¶å®šäº‹ä»¶ï¼ˆç«‹å³ç¶å®šï¼‰
    let pdfViewersForEvents = document.querySelectorAll('.pdf-viewer');
    console.log('æ‰¾åˆ° PDF viewers ç”¨æ–¼äº‹ä»¶ç¶å®š:', pdfViewersForEvents.length);
    pdfViewersForEvents.forEach(viewer => {
        viewer.removeEventListener('mousedown', handleViewerMouseDown);
        viewer.removeEventListener('touchstart', handleViewerTouchStart);
        viewer.addEventListener('mousedown', handleViewerMouseDown);
        viewer.addEventListener('touchstart', handleViewerTouchStart);
        console.log('å·²ç‚º PDF viewer ç¶å®šäº‹ä»¶');
    });
    
    const markLayersForEvents = document.querySelectorAll('.mark-layer');
    console.log('æ‰¾åˆ°æ¨™è¨˜å±¤ ç”¨æ–¼äº‹ä»¶ç¶å®š:', markLayersForEvents.length);
    markLayersForEvents.forEach(layer => {
        layer.removeEventListener('mousedown', handleViewerMouseDown);
        layer.removeEventListener('touchstart', handleViewerTouchStart);
        layer.addEventListener('mousedown', handleViewerMouseDown);
        layer.addEventListener('touchstart', handleViewerTouchStart);
        console.log('å·²ç‚ºæ¨™è¨˜å±¤ç¶å®šäº‹ä»¶');
    });
    
    // å¦‚æœç•¶å‰æ²’æœ‰ PDF viewerï¼Œç­‰å¾…é é¢æ¸²æŸ“å®Œæˆå¾Œå†ç¶å®š
    if (pdfViewersForEvents.length === 0) {
        console.log('ç•¶å‰æ²’æœ‰ PDF viewerï¼Œç­‰å¾…é é¢æ¸²æŸ“...');
        setTimeout(() => {
            pdfViewersForEvents = document.querySelectorAll('.pdf-viewer');
            pdfViewersForEvents.forEach(viewer => {
                viewer.removeEventListener('mousedown', handleViewerMouseDown);
                viewer.removeEventListener('touchstart', handleViewerTouchStart);
                viewer.addEventListener('mousedown', handleViewerMouseDown);
                viewer.addEventListener('touchstart', handleViewerTouchStart);
                console.log('å»¶é²ç¶å®š PDF viewer äº‹ä»¶');
            });
        }, 100);
    }
    
    // æ¸²æŸ“ç¾æœ‰æ¨™è¨˜
    renderMarks();
    
    // æ¨™è¨˜æ‰‹å‹•æ¨™è¨˜å·²å•Ÿç”¨
    isManualMarkingEnabled = true;
    
    // ç¢ºä¿æ¨™è¨˜å€å¡Šæ¨£å¼æ­£ç¢º
    requestAnimationFrame(() => {
        const markBlocks = document.querySelectorAll('.mark-block');
        console.log('æ‰¾åˆ°æ¨™è¨˜å€å¡Š:', markBlocks.length);
        markBlocks.forEach(block => {
            block.style.display = 'block';
            block.style.visibility = 'visible';
            block.style.opacity = '1';
            block.style.border = '3px solid #007BFF';
            block.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
        });
    });
    
    // ä¸é¡¯ç¤ºæç¤ºè¨Šæ¯ï¼Œå› ç‚ºå·²ç¶“åœ¨ toggleMarkingMode ä¸­è™•ç†äº†
    console.log('æ‰‹å‹•æ¨™è¨˜åŠŸèƒ½å·²å•Ÿç”¨');
}

// åˆå§‹åŒ–æ¨™è¨˜åŠŸèƒ½
function initMarkingFeature() {
    // æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
    const markButton = document.getElementById('markBlockButton');
    const saveButton = document.getElementById('saveMarkedPdfButton');
    const downloadButton = document.getElementById('downloadMarkedPdfButton');
    const clearButton = document.getElementById('clearMarksButton');
    
    // å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
    const cancelMarkingButtonToolbar = document.getElementById('cancelMarkingButtonToolbar');
    const manualMarkButtonToolbar = document.getElementById('manualMarkButtonToolbar');
    const aiMarkButtonToolbar = document.getElementById('aiMarkButtonToolbar');
    const setPasswordButtonToolbar = document.getElementById('setPasswordButtonToolbar');
    const saveButtonToolbar = document.getElementById('saveMarkedPdfButtonToolbar');
    const downloadButtonToolbar = document.getElementById('downloadMarkedPdfButtonToolbar');
    const clearButtonToolbar = document.getElementById('clearMarksButtonToolbar');
    
    // ç¶å®šæ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•äº‹ä»¶
    if (markButton) markButton.addEventListener('click', toggleMarkingMode);
    if (saveButton) saveButton.addEventListener('click', saveMarksToPdf);
    if (downloadButton) downloadButton.addEventListener('click', downloadMarkedPdf);
    if (clearButton) clearButton.addEventListener('click', clearAllMarks);
    
    // ç¶å®šå·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•äº‹ä»¶
    if (cancelMarkingButtonToolbar) cancelMarkingButtonToolbar.addEventListener('click', toggleMarkingMode);
    if (manualMarkButtonToolbar) {
        manualMarkButtonToolbar.addEventListener('click', function(e) {
            console.log('æ‰‹å‹•æ¨™è¨˜æŒ‰éˆ•è¢«é»æ“Š', e);
            e.preventDefault();
            e.stopPropagation();
            enableManualMarking();
        });
        console.log('å·²ç¶å®šæ‰‹å‹•æ¨™è¨˜æŒ‰éˆ•');
    } else {
        console.error('æ‰¾ä¸åˆ°æ‰‹å‹•æ¨™è¨˜æŒ‰éˆ•å…ƒç´ ');
    }
    if (aiMarkButtonToolbar) aiMarkButtonToolbar.addEventListener('click', aiMarkPdf);
    if (setPasswordButtonToolbar) setPasswordButtonToolbar.addEventListener('click', setPasswordForPdf);
    if (saveButtonToolbar) saveButtonToolbar.addEventListener('click', saveMarksToPdf);
    if (downloadButtonToolbar) downloadButtonToolbar.addEventListener('click', downloadMarkedPdf);
    if (clearButtonToolbar) clearButtonToolbar.addEventListener('click', clearAllMarks);
    
    // è¼‰å…¥å·²ä¿å­˜çš„æ¨™è¨˜ï¼ˆå„ªå…ˆå¾PDFæ–‡ä»¶è¼‰å…¥ï¼‰
    loadMarksFromPdf();
}

// åˆ‡æ›æ¨™è¨˜æ¨¡å¼
async function toggleMarkingMode() {
    console.log('toggleMarkingMode è¢«èª¿ç”¨ï¼Œç•¶å‰ isMarkingMode:', isMarkingMode);
    
    // å¦‚æœé€²å…¥æ¨™è¨˜æ¨¡å¼ï¼Œå…ˆæª¢æŸ¥æ˜¯å¦ç‚ºæœ¬åœ°æª”æ¡ˆ
    if (!isMarkingMode) {
        // æª¢æŸ¥æ˜¯å¦ç‚ºæœ¬åœ°æª”æ¡ˆ
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        
        // åˆ¤æ–·æª”æ¡ˆé¡å‹
        if (fileParam) {
            const isLocalPdfFile = fileParam.toLowerCase().endsWith('.pdf');
            const isNetworkFile = fileParam.startsWith('http://') || fileParam.startsWith('https://');
            
            // å¦‚æœä¸æ˜¯æœ¬åœ°PDFæª”æ¡ˆï¼ˆæ˜¯é›²ç«¯æª”æ¡ˆæˆ–ç¶²è·¯æª”æ¡ˆï¼‰ï¼Œé¡¯ç¤ºè­¦å‘Š
            if (!isLocalPdfFile || isNetworkFile) {
                await Swal.fire({
                    icon: 'warning',
                    title: 'æ¨™è¨˜åŠŸèƒ½é™åˆ¶',
                    html: `
                        <div style="text-align: left;">
                            <p style="margin-bottom: 15px; font-size: 16px; line-height: 1.6;">
                                <strong>æ¨™è¨˜åŠŸèƒ½åƒ…é™æœ¬åœ°PDFæª”æ¡ˆä½¿ç”¨</strong>
                            </p>
                            <p style="margin-bottom: 10px; font-size: 14px; line-height: 1.6; color: #666;">
                                â€¢ ç›®å‰é–‹å•Ÿçš„æ˜¯é›²ç«¯æª”æ¡ˆï¼Œç„¡æ³•é€²è¡Œæ¨™è¨˜ç·¨è¼¯
                            </p>
                            <p style="margin-bottom: 15px; font-size: 14px; line-height: 1.6; color: #666;">
                                â€¢ å¦‚éœ€ä½¿ç”¨æ¨™è¨˜åŠŸèƒ½ï¼Œå¿…é ˆåœ¨å·¦ä¸Šè§’é¸æ“‡æœ¬åœ°æª”æ¡ˆï¼Œæ‰èƒ½é€²è¡Œæ¨™è¨˜
                            </p>
                            <p style="margin-bottom: 0; font-size: 14px; line-height: 1.6; color: #666;">
                                â€¢ æ¨™è¨˜å®Œæˆå¾Œï¼Œå¿…é ˆå…ˆã€ŒåŒ¯å‡ºPDFã€æ‰èƒ½ä¿å­˜æ¨™è¨˜
                            </p>
							<p style="margin-bottom: 0; font-size: 14px; line-height: 1.6; color: #666;">
                                â€¢ ä½¿ç”¨æœ¬ç³»çµ±å¯è®€å–æœ¬åœ°æˆ–é›²ç«¯å·²æ¨™è¨˜çš„PDFæª”æ¡ˆé€²è¡Œç™¼éŸ³
                            </p>
                        </div>
                    `,
                    confirmButtonText: 'æˆ‘çŸ¥é“äº†',
                    showCancelButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    },
                    width: '500px'
                });
                return; // ä¸é€²å…¥æ¨™è¨˜æ¨¡å¼
            }
        }
        
        // å¦‚æœæ²’æœ‰ fileParamï¼Œå¯èƒ½æ˜¯ç›´æ¥ä¸Šå‚³çš„æœ¬åœ°æª”æ¡ˆï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ pdfDoc
        if (!pdfDoc) {
            Swal.fire({
                icon: 'warning',
                title: 'ç„¡æ³•æ¨™è¨˜',
                text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ',
                customClass: {
                    popup: 'swal-high-z-index'
                }
            });
            return;
        }
        
        // æª¢æŸ¥å¯†ç¢¼ä¿è­·
        const hasAccess = await checkPasswordProtection();
        console.log('å¯†ç¢¼æª¢æŸ¥çµæœ:', hasAccess);
        if (!hasAccess) {
            console.log('å¯†ç¢¼é©—è­‰å¤±æ•—ï¼Œä¸é€²å…¥æ¨™è¨˜æ¨¡å¼');
            return; // å¯†ç¢¼é©—è­‰å¤±æ•—ï¼Œä¸é€²å…¥æ¨™è¨˜æ¨¡å¼
        }
    }
    
    isMarkingMode = !isMarkingMode;
    console.log('åˆ‡æ›å¾Œ isMarkingMode:', isMarkingMode);
    const markButton = document.getElementById('markBlockButton');
    const saveButton = document.getElementById('saveMarkedPdfButton');
    const downloadButton = document.getElementById('downloadMarkedPdfButton');
    const clearButton = document.getElementById('clearMarksButton');
    
    // å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
    const cancelMarkingButtonToolbar = document.getElementById('cancelMarkingButtonToolbar');
    const aiMarkButtonToolbar = document.getElementById('aiMarkButtonToolbar');
    const setPasswordButtonToolbar = document.getElementById('setPasswordButtonToolbar');
    const saveButtonToolbar = document.getElementById('saveMarkedPdfButtonToolbar');
    const downloadButtonToolbar = document.getElementById('downloadMarkedPdfButtonToolbar');
    const clearButtonToolbar = document.getElementById('clearMarksButtonToolbar');
    const markingToolbar = document.getElementById('markingToolbar');
    
    const toggleButton = document.getElementById('toggleMarksButton');
    
    if (isMarkingMode) {
        // é—œé–‰API KEYæ¨¡æ…‹è¦–çª—ï¼ˆå¦‚æœæ‰“é–‹ï¼‰
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyModalOverlay = document.getElementById('apiKeyModalOverlay');
        if (apiKeyModal) apiKeyModal.style.display = 'none';
        if (apiKeyModalOverlay) apiKeyModalOverlay.style.display = 'none';
        
        // é¡¯ç¤ºæ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„ï¼ˆæ©«å‘ï¼Œç½®åº•ï¼‰
        if (markingToolbar) {
            markingToolbar.classList.add('show');
            markingToolbar.style.display = 'flex';
        }
        
        // æ›´æ–°æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
        if (markButton) {
            markButton.textContent = 'å–æ¶ˆæ¨™è¨˜';
            markButton.classList.remove('button-success');
            markButton.classList.add('button-danger');
        }
        if (saveButton) saveButton.style.display = 'block';
        if (downloadButton) downloadButton.style.display = 'block';
        if (clearButton) clearButton.style.display = 'block';
        
        // ç¢ºä¿æ‰€æœ‰å·¥å…·æ¬„æŒ‰éˆ•éƒ½é¡¯ç¤ºï¼ˆè¦†è“‹å…§è¯æ¨£å¼ï¼‰
        if (cancelMarkingButtonToolbar) {
            cancelMarkingButtonToolbar.style.display = 'inline-block';
            cancelMarkingButtonToolbar.style.visibility = 'visible';
        }
        if (aiMarkButtonToolbar) {
            aiMarkButtonToolbar.style.display = 'inline-block';
            aiMarkButtonToolbar.style.visibility = 'visible';
        }
        if (setPasswordButtonToolbar) {
            setPasswordButtonToolbar.style.display = 'inline-block';
            setPasswordButtonToolbar.style.visibility = 'visible';
        }
        if (saveButtonToolbar) {
            saveButtonToolbar.style.display = 'inline-block';
            saveButtonToolbar.style.visibility = 'visible';
        }
        if (downloadButtonToolbar) {
            downloadButtonToolbar.style.display = 'inline-block';
            downloadButtonToolbar.style.visibility = 'visible';
        }
        if (clearButtonToolbar) {
            clearButtonToolbar.style.display = 'inline-block';
            clearButtonToolbar.style.visibility = 'visible';
        }
        
        // ä¸é¡¯ç¤º toggleMarksButtonï¼Œå› ç‚ºåªæœ‰ç·¨è¼¯æ¨¡å¼æ‰é¡¯ç¤ºæ¨™è¨˜
        if (toggleButton) toggleButton.style.display = 'none';
        
        // ä½¿ç”¨CSSé¡ä¾†è¨­ç½®åå­—æ¸¸æ¨™ï¼ˆç«‹å³è¨­ç½®ï¼Œç¢ºä¿æ¸¸æ¨™ç«‹å³é¡¯ç¤ºï¼‰
        document.body.classList.add('marking-mode-active');
        document.body.style.cursor = 'crosshair';
        
        // ç¢ºä¿ PDF viewer å’Œ canvas ä¹Ÿé¡¯ç¤ºåå­—æ¸¸æ¨™ï¼ˆä½¿ç”¨!importantç¢ºä¿å„ªå…ˆç´šï¼‰
        let pdfViewersForCursor = document.querySelectorAll('.pdf-viewer');
        pdfViewersForCursor.forEach(viewer => {
            viewer.style.setProperty('cursor', 'crosshair', 'important');
            viewer.style.cursor = 'crosshair';
        });
        let canvasesForCursor = document.querySelectorAll('canvas');
        canvasesForCursor.forEach(canvas => {
            canvas.style.setProperty('cursor', 'crosshair', 'important');
            canvas.style.cursor = 'crosshair';
        });
        
        // èª¿æ•´PDFå®¹å™¨åº•éƒ¨é‚Šè·ï¼Œç‚ºåº•éƒ¨å·¥å…·æ¬„ç•™å‡ºç©ºé–“
        const pdfContainer = document.getElementById('pdfContainer');
        if (pdfContainer) {
            pdfContainer.style.marginBottom = '60px';
        }
        
        // èª¿æ•´åº•éƒ¨å…ƒç´ ä½ç½®ï¼Œé¿å…èˆ‡å·¥å…·æ¬„é‡ç–Š
        const audioPlayer = document.getElementById('audioPlayer');
        const selectAllTextButton = document.getElementById('select-all-text');
        const sendButton = document.getElementById('sendButton');
        const clearButton = document.getElementById('clearButton');
        
        if (audioPlayer) {
            audioPlayer.style.bottom = '60px';
        }
        if (selectAllTextButton) {
            selectAllTextButton.style.bottom = '60px';
        }
        if (sendButton) {
            sendButton.style.bottom = '60px';
        }
        if (clearButton) {
            clearButton.style.bottom = '60px';
        }
        
        // å•Ÿç”¨æ¨™è¨˜å±¤çš„äº‹ä»¶å’Œé¡¯ç¤ºï¼ˆå…ˆè¨­ç½®æ¨™è¨˜å±¤ï¼Œå†æ¸²æŸ“æ¨™è¨˜ï¼‰
        const markLayers = document.querySelectorAll('.mark-layer');
        markLayers.forEach(layer => {
            layer.classList.add('marking-mode');
            layer.classList.remove('hidden'); // ç¢ºä¿æ¨™è¨˜å±¤å¯è¦‹
            layer.style.display = 'block';
            layer.style.visibility = 'visible';
            // ç¢ºä¿æ¨™è¨˜å±¤å¯ä»¥æ¥æ”¶äº‹ä»¶
            layer.style.pointerEvents = 'auto';
        });
        
        // ç«‹å³æ¸²æŸ“æ¨™è¨˜ä»¥ç¢ºä¿æ‰€æœ‰æ¨™è¨˜éƒ½é¡¯ç¤ºï¼ˆç·¨è¼¯æ¨¡å¼ï¼‰
        console.log('é–‹å§‹æ¸²æŸ“æ¨™è¨˜ï¼Œç•¶å‰é ç¢¼:', currentPage, 'æ¨™è¨˜æ•¸é‡:', marks[currentPage] ? marks[currentPage].length : 0);
        // å…ˆç«‹å³å˜—è©¦æ¸²æŸ“ï¼Œå¦‚æœæ¨™è¨˜å±¤ä¸å­˜åœ¨å‰‡å¿«é€Ÿé‡è©¦
        const tryRenderMarks = (attemptCount = 0) => {
            const maxAttempts = 10; // æœ€å¤šå˜—è©¦10æ¬¡ï¼ˆç´„0.3ç§’ï¼‰
            const currentMarkLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
            console.log(`å˜—è©¦æ¸²æŸ“æ¨™è¨˜ (ç¬¬${attemptCount + 1}æ¬¡)ï¼Œæ¨™è¨˜å±¤å­˜åœ¨:`, !!currentMarkLayer);
            if (currentMarkLayer) {
                // æ¨™è¨˜å±¤å·²å­˜åœ¨ï¼Œç«‹å³æ¸²æŸ“
                console.log('æ¨™è¨˜å±¤å·²æ‰¾åˆ°ï¼Œç«‹å³æ¸²æŸ“æ¨™è¨˜');
                renderMarks();
                // ç¢ºä¿æ¨™è¨˜å€å¡Šæ¨£å¼æ­£ç¢ºï¼ˆåœ¨ renderMarks å®Œæˆå¾Œç«‹å³è¨­ç½®ï¼‰
                requestAnimationFrame(() => {
                    const markBlocks = document.querySelectorAll('.mark-block');
                    console.log('æ‰¾åˆ°æ¨™è¨˜å€å¡Š:', markBlocks.length);
                    markBlocks.forEach(block => {
                        block.style.display = 'block';
                        block.style.visibility = 'visible';
                        block.style.opacity = '1';
                        // æ¢å¾©é‚Šæ¡†å’ŒèƒŒæ™¯è‰²
                        block.style.border = '3px solid #007BFF';
                        block.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                        // é¡¯ç¤ºæ¨™ç±¤ã€ç·¨è¼¯æŒ‰éˆ•å’Œåˆªé™¤æŒ‰éˆ•
                        const label = block.querySelector('.mark-label');
                        const editBtn = block.querySelector('.mark-edit');
                        const deleteBtn = block.querySelector('.mark-delete');
                        if (label) {
                            label.style.display = 'block';
                        }
                        if (editBtn) {
                            editBtn.style.display = 'flex';
                        }
                        if (deleteBtn) {
                            deleteBtn.style.display = 'flex';
                        }
                    });
                });
            } else if (attemptCount < maxAttempts) {
                // æ¨™è¨˜å±¤é‚„ä¸å­˜åœ¨ï¼Œå¿«é€Ÿé‡è©¦ï¼ˆæ¸›å°‘å»¶é²ï¼‰
                setTimeout(() => tryRenderMarks(attemptCount + 1), 30);
            } else {
                console.warn('æ¨™è¨˜å±¤æœªèƒ½åœ¨é æœŸæ™‚é–“å…§å‰µå»ºï¼Œé ç¢¼:', currentPage);
            }
        };
        
        // ç«‹å³å˜—è©¦æ¸²æŸ“ï¼ˆä¸å»¶é²ï¼‰
        tryRenderMarks();
        
        // åœ¨ PDF viewer å’Œæ¨™è¨˜å±¤ä¸Šç¶å®šäº‹ä»¶ï¼ˆå„ªå…ˆåŸ·è¡Œï¼Œç¢ºä¿æ‰‹å‹•æ¨™è¨˜åŠŸèƒ½ç«‹å³å¯ç”¨ï¼‰
        // ç«‹å³ç¶å®šï¼Œä¸ç­‰å¾…
        let pdfViewersForEvents = document.querySelectorAll('.pdf-viewer');
        console.log('æ‰¾åˆ° PDF viewers:', pdfViewersForEvents.length);
        pdfViewersForEvents.forEach(viewer => {
            // å…ˆç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ï¼Œé¿å…é‡è¤‡ç¶å®š
            viewer.removeEventListener('mousedown', handleViewerMouseDown);
            viewer.removeEventListener('touchstart', handleViewerTouchStart);
            // ç¶å®šæ–°çš„äº‹ä»¶ç›£è½å™¨
            viewer.addEventListener('mousedown', handleViewerMouseDown);
            viewer.addEventListener('touchstart', handleViewerTouchStart);
            console.log('å·²ç‚º PDF viewer ç¶å®šäº‹ä»¶');
        });
        
        // ä¹Ÿåœ¨æ¨™è¨˜å±¤ä¸Šç¶å®šäº‹ä»¶ï¼Œç¢ºä¿é»æ“Šæ¨™è¨˜å±¤ç©ºç™½å€åŸŸä¹Ÿèƒ½è§¸ç™¼
        const markLayersForEvents = document.querySelectorAll('.mark-layer');
        console.log('æ‰¾åˆ°æ¨™è¨˜å±¤:', markLayersForEvents.length);
        markLayersForEvents.forEach(layer => {
            // å…ˆç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ï¼Œé¿å…é‡è¤‡ç¶å®š
            layer.removeEventListener('mousedown', handleViewerMouseDown);
            layer.removeEventListener('touchstart', handleViewerTouchStart);
            // ç¶å®šæ–°çš„äº‹ä»¶ç›£è½å™¨
            layer.addEventListener('mousedown', handleViewerMouseDown);
            layer.addEventListener('touchstart', handleViewerTouchStart);
            console.log('å·²ç‚ºæ¨™è¨˜å±¤ç¶å®šäº‹ä»¶');
        });
        
        // å¦‚æœç•¶å‰æ²’æœ‰ PDF viewerï¼Œç­‰å¾…é é¢æ¸²æŸ“å®Œæˆå¾Œå†ç¶å®š
        if (pdfViewersForEvents.length === 0) {
            console.log('ç•¶å‰æ²’æœ‰ PDF viewerï¼Œç­‰å¾…é é¢æ¸²æŸ“...');
            setTimeout(() => {
                pdfViewersForEvents = document.querySelectorAll('.pdf-viewer');
                pdfViewersForEvents.forEach(viewer => {
                    viewer.removeEventListener('mousedown', handleViewerMouseDown);
                    viewer.removeEventListener('touchstart', handleViewerTouchStart);
                    viewer.addEventListener('mousedown', handleViewerMouseDown);
                    viewer.addEventListener('touchstart', handleViewerTouchStart);
                    console.log('å»¶é²ç¶å®š PDF viewer äº‹ä»¶');
                });
            }, 100);
        }
    } else {
        // é‡ç½®æ‰‹å‹•æ¨™è¨˜ç‹€æ…‹
        isManualMarkingEnabled = false;
        
        // éš±è—æ¨™è¨˜åŠŸèƒ½å·¥å…·æ¬„
        if (markingToolbar) {
            markingToolbar.classList.remove('show');
            markingToolbar.style.display = 'none';
        }
        
        // æ¢å¾©PDFå®¹å™¨åº•éƒ¨é‚Šè·
        const pdfContainer = document.getElementById('pdfContainer');
        if (pdfContainer) {
            pdfContainer.style.marginBottom = '0px';
        }
        
        // æ¢å¾©åº•éƒ¨å…ƒç´ ä½ç½®
        const audioPlayer = document.getElementById('audioPlayer');
        const selectAllTextButton = document.getElementById('select-all-text');
        const sendButton = document.getElementById('sendButton');
        const clearButton = document.getElementById('clearButton');
        
        if (audioPlayer) {
            audioPlayer.style.bottom = '5px';
        }
        if (selectAllTextButton) {
            selectAllTextButton.style.bottom = '5px';
        }
        if (sendButton) {
            sendButton.style.bottom = '5px';
        }
        if (clearButton) {
            clearButton.style.bottom = '5px';
        }
        
        // æ›´æ–°æ¨¡æ…‹è¦–çª—ä¸­çš„æŒ‰éˆ•
        if (markButton) {
            markButton.textContent = 'æ¨™è¨˜å€å¡Š';
            markButton.classList.remove('button-danger');
            markButton.classList.add('button-success');
        }
        if (saveButton) saveButton.style.display = 'none';
        if (downloadButton) downloadButton.style.display = 'none';
        if (clearButton) clearButton.style.display = 'none';
        
        // æ›´æ–°å·¥å…·æ¬„ä¸­çš„æŒ‰éˆ•
        if (cancelMarkingButtonToolbar) cancelMarkingButtonToolbar.style.display = 'none';
        const manualMarkButtonToolbar = document.getElementById('manualMarkButtonToolbar');
        if (manualMarkButtonToolbar) manualMarkButtonToolbar.style.display = 'none';
        if (aiMarkButtonToolbar) aiMarkButtonToolbar.style.display = 'none';
        if (setPasswordButtonToolbar) setPasswordButtonToolbar.style.display = 'none';
        if (saveButtonToolbar) saveButtonToolbar.style.display = 'none';
        if (downloadButtonToolbar) downloadButtonToolbar.style.display = 'none';
        if (clearButtonToolbar) clearButtonToolbar.style.display = 'none';
        
        if (toggleButton) toggleButton.style.display = 'none';
        
        // ç§»é™¤æ¨™è¨˜æ¨¡å¼çš„CSSé¡
        document.body.classList.remove('marking-mode-active');
        document.body.style.cursor = 'default';
        
        // æ¢å¾© PDF viewer å’Œ canvas çš„æ¸¸æ¨™
        let pdfViewersForCursorExit = document.querySelectorAll('.pdf-viewer');
        pdfViewersForCursorExit.forEach(viewer => {
            viewer.style.removeProperty('cursor');
            viewer.style.cursor = 'default';
        });
        let canvasesForCursorExit = document.querySelectorAll('canvas');
        canvasesForCursorExit.forEach(canvas => {
            canvas.style.removeProperty('cursor');
            canvas.style.cursor = 'default';
        });
        
        if (currentMark) {
            currentMark = null;
        }
        
        // ç¦ç”¨æ¨™è¨˜å±¤çš„äº‹ä»¶èˆ‡é»æ“Šï¼Œé¿å…æ“‹ä½åº•å±¤æ–‡å­—é»æ“Šç™¼éŸ³
        const markLayers = document.querySelectorAll('.mark-layer');
        markLayers.forEach(layer => {
            layer.classList.remove('marking-mode');
            // è®“æ¨™è¨˜å±¤æœ¬èº«ä¸å†æ””æˆªä»»ä½•æ¸¸æ¨™äº‹ä»¶
            layer.style.pointerEvents = 'none';
            layer.style.display = 'none';
        });
        
        // éš±è—æ‰€æœ‰æ¨™è¨˜å€å¡Šçš„è¦–è¦ºé¡¯ç¤ºï¼Œä¸¦ä¸€ä½µé—œé–‰é»æ“ŠåŠŸèƒ½
        const markBlocks = document.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            // éš±è—è¦–è¦ºé¡¯ç¤ºä¸¦ç§»é™¤é»æ“Šèƒ½åŠ›ï¼Œé¿å…å¹²æ“¾æ–‡å­—é»æ“Šç™¼éŸ³
            block.style.opacity = '0';
            block.style.pointerEvents = 'none';
            block.style.backgroundColor = 'transparent'; // ç¢ºä¿èƒŒæ™¯é€æ˜
            block.style.border = 'none'; // éš±è—é‚Šæ¡†
            // éš±è—æ¨™ç±¤ã€ç·¨è¼¯æŒ‰éˆ•å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const editBtn = block.querySelector('.mark-edit');
            const deleteBtn = block.querySelector('.mark-delete');
            if (label) label.style.display = 'none';
            if (editBtn) editBtn.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
        });
        
        // ç§»é™¤ PDF viewer å’Œæ¨™è¨˜å±¤ä¸Šçš„äº‹ä»¶ç›£è½å™¨
        let pdfViewersForRemoveEvents = document.querySelectorAll('.pdf-viewer');
        pdfViewersForRemoveEvents.forEach(viewer => {
            viewer.removeEventListener('mousedown', handleViewerMouseDown);
            viewer.removeEventListener('touchstart', handleViewerTouchStart);
        });
        
        // ç§»é™¤æ¨™è¨˜å±¤ä¸Šçš„äº‹ä»¶ç›£è½å™¨
        const markLayersForRemoveEvents = document.querySelectorAll('.mark-layer');
        markLayersForRemoveEvents.forEach(layer => {
            layer.removeEventListener('mousedown', handleViewerMouseDown);
            layer.removeEventListener('touchstart', handleViewerTouchStart);
        });

        // å–æ¶ˆæ¨™è¨˜å¾Œï¼Œè‡ªå‹•é‡æ–°è¼‰å…¥é é¢ï¼Œç¢ºä¿ç™¼éŸ³åŠŸèƒ½èˆ‡å„ç¨®äº‹ä»¶å®Œæ•´æ¢å¾©
        // ä½¿ç”¨ setTimeout ç¢ºä¿ç•¶å‰ç‹€æ…‹æ›´æ–°å®Œæˆå†é‡æ–°è¼‰å…¥
        setTimeout(() => {
            try {
                window.location.reload();
            } catch (e) {
                console.error('é‡æ–°è¼‰å…¥é é¢å¤±æ•—:', e);
            }
        }, 100);
    }
}

// è™•ç† PDF viewer çš„æ»‘é¼ æŒ‰ä¸‹äº‹ä»¶
function handleViewerMouseDown(e) {
    console.log('handleViewerMouseDown è¢«èª¿ç”¨, isMarkingMode:', isMarkingMode, 'pdfDoc:', !!pdfDoc);
    if (!isMarkingMode || !pdfDoc) {
        console.log('æ¢ä»¶ä¸æ»¿è¶³ï¼Œè¿”å›');
        return;
    }
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šã€èª¿æ•´å¤§å°æ§åˆ¶é»ã€ç·¨è¼¯æŒ‰éˆ•æˆ–åˆªé™¤æŒ‰éˆ•ï¼Œä¸è™•ç†
    if (e.target.closest('.mark-block') || 
        e.target.classList.contains('resize-handle') ||
        e.target.classList.contains('mark-delete') ||
        e.target.classList.contains('mark-edit')) {
        console.log('é»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šæˆ–æ§åˆ¶å…ƒç´ ï¼Œè¿”å›');
        return;
    }
    
    // å¦‚æœé»æ“Šçš„æ˜¯ canvasã€æ¨™è¨˜å±¤ã€pdf-viewerã€textLayer æˆ–ä»»ä½•åœ¨ pdf-viewer å…§çš„å…ƒç´ ï¼Œé–‹å§‹æ¨™è¨˜
    const clickedElement = e.target;
    const isInPdfViewer = clickedElement.closest('.pdf-viewer');
    
    console.log('é»æ“Šçš„å…ƒç´ :', clickedElement.tagName, 'classList:', clickedElement.classList.toString(), 'isInPdfViewer:', !!isInPdfViewer);
    
    if (clickedElement.tagName === 'CANVAS' || 
        clickedElement.classList.contains('mark-layer') || 
        clickedElement.classList.contains('pdf-viewer') ||
        clickedElement.classList.contains('textLayer') ||
        isInPdfViewer) {
        console.log('æ¢ä»¶æ»¿è¶³ï¼Œèª¿ç”¨ startMarking');
        startMarking(e);
    } else {
        console.log('æ¢ä»¶ä¸æ»¿è¶³ï¼Œä¸èª¿ç”¨ startMarking');
    }
}

// è™•ç† PDF viewer çš„è§¸æ§é–‹å§‹äº‹ä»¶
function handleViewerTouchStart(e) {
    if (!isMarkingMode || !pdfDoc) return;
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šã€èª¿æ•´å¤§å°æ§åˆ¶é»ã€ç·¨è¼¯æŒ‰éˆ•æˆ–åˆªé™¤æŒ‰éˆ•ï¼Œä¸è™•ç†
    if (e.target.closest('.mark-block') || 
        e.target.classList.contains('resize-handle') ||
        e.target.classList.contains('mark-delete') ||
        e.target.classList.contains('mark-edit')) {
        return;
    }
    
    // å¦‚æœé»æ“Šçš„æ˜¯ canvasã€æ¨™è¨˜å±¤ã€pdf-viewerã€textLayer æˆ–ä»»ä½•åœ¨ pdf-viewer å…§çš„å…ƒç´ ï¼Œé–‹å§‹æ¨™è¨˜
    const clickedElement = e.target;
    const isInPdfViewer = clickedElement.closest('.pdf-viewer');
    
    if (clickedElement.tagName === 'CANVAS' || 
        clickedElement.classList.contains('mark-layer') || 
        clickedElement.classList.contains('pdf-viewer') ||
        clickedElement.classList.contains('textLayer') ||
        isInPdfViewer) {
        // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å±¤çš„ç©ºç™½å€åŸŸï¼ˆæ¨™è¨˜å±¤æœ¬èº«ï¼‰ï¼Œä¹Ÿæ‡‰è©²é–‹å§‹æ¨™è¨˜
        if (clickedElement.classList.contains('mark-layer')) {
            startMarking(e);
        } else if (clickedElement.tagName === 'CANVAS' || isInPdfViewer) {
            startMarking(e);
        }
    }
}

// é–‹å§‹ç¹ªè£½æ¨™è¨˜
function startMarking(e) {
    console.log('startMarking è¢«èª¿ç”¨');
    if (!isMarkingMode || !pdfDoc) {
        console.log('æ¨™è¨˜æ¨¡å¼æœªå•Ÿç”¨æˆ–PDFæœªè¼‰å…¥, isMarkingMode:', isMarkingMode, 'pdfDoc:', !!pdfDoc);
        return;
    }
    
    // å¦‚æœé»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šæœ¬èº«ï¼Œä¸é–‹å§‹æ–°çš„æ¨™è¨˜
    if (e.target.classList.contains('mark-block') || 
        e.target.classList.contains('mark-delete') ||
        e.target.closest('.mark-block')) {
        console.log('é»æ“Šçš„æ˜¯æ¨™è¨˜å€å¡Šï¼Œè¿”å›');
        return;
    }
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) {
        console.warn('æ¨™è¨˜å±¤ä¸å­˜åœ¨ï¼Œé ç¢¼:', currentPage, 'å˜—è©¦å‰µå»ºæ¨™è¨˜å±¤...');
        // å¦‚æœæ¨™è¨˜å±¤ä¸å­˜åœ¨ï¼Œå˜—è©¦é‡æ–°æ¸²æŸ“é é¢
        renderPage(currentPage);
        // ç­‰å¾…æ¨™è¨˜å±¤å‰µå»ºå¾Œå†é‡è©¦
        setTimeout(() => {
            const retryMarkLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
            if (retryMarkLayer) {
                console.log('æ¨™è¨˜å±¤å·²å‰µå»ºï¼Œé‡è©¦ startMarking');
                startMarking(e);
            } else {
                console.error('æ¨™è¨˜å±¤å‰µå»ºå¤±æ•—');
            }
        }, 100);
        return;
    }
    
    console.log('æ¨™è¨˜å±¤å·²æ‰¾åˆ°ï¼Œç¹¼çºŒæ¨™è¨˜æµç¨‹');
    
    // ç¢ºä¿æ¨™è¨˜å±¤è™•æ–¼æ¨™è¨˜æ¨¡å¼
    if (!markLayer.classList.contains('marking-mode')) {
        markLayer.classList.add('marking-mode');
    }
    
    e.preventDefault();
    e.stopPropagation();
    
    // ç²å–ç›¸å°æ–¼æ¨™è¨˜å±¤çš„ä½ç½®
    const rect = markLayer.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const startX = clientX - rect.left;
    const startY = clientY - rect.top;
    
    console.log('é–‹å§‹æ¨™è¨˜ï¼Œä½ç½®:', startX, startY, 'é ç¢¼:', currentPage, 'äº‹ä»¶ç›®æ¨™:', e.target);
    
    currentMark = {
        id: markIdCounter++,
        startX,
        startY,
        x: startX,
        y: startY,
        width: 0,
        height: 0,
        pageNum: currentPage
    };
    
    const markBlock = document.createElement('div');
    markBlock.className = 'mark-block';
    markBlock.dataset.markId = currentMark.id;
    markBlock.style.position = 'absolute';
    markBlock.style.left = `${startX}px`;
    markBlock.style.top = `${startY}px`;
    markBlock.style.width = '0px';
    markBlock.style.height = '0px';
    markBlock.style.display = 'block'; // ç¢ºä¿é¡¯ç¤º
    markBlock.style.visibility = 'visible'; // ç¢ºä¿å¯è¦‹
    markBlock.style.opacity = '1'; // ç¢ºä¿ä¸é€æ˜
    
    const label = document.createElement('div');
    label.className = 'mark-label';
    label.textContent = `å€å¡Š ${currentMark.id + 1}`;
    markBlock.appendChild(label);
    
    markLayer.appendChild(markBlock);
    currentMark.element = markBlock;
    
    console.log('æ¨™è¨˜æ¡†å·²å‰µå»ºï¼Œä½ç½®:', startX, startY, 'å…ƒç´ :', markBlock);
    
    // ä½¿ç”¨ capture æ¨¡å¼ç¢ºä¿äº‹ä»¶èƒ½æ­£ç¢ºæ•ç²
    document.addEventListener('mousemove', updateMark, true);
    document.addEventListener('mouseup', finishMark, true);
    document.addEventListener('touchmove', updateMark, true);
    document.addEventListener('touchend', finishMark, true);
    
    console.log('æ¨™è¨˜é–‹å§‹ï¼Œå·²æ·»åŠ äº‹ä»¶ç›£è½å™¨');
}

// æ›´æ–°æ¨™è¨˜å¤§å°
function updateMark(e) {
    if (!currentMark) return;
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) return;
    
    const rect = markLayer.getBoundingClientRect();
    const currentX = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const currentY = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    
    const width = Math.abs(currentX - currentMark.startX);
    const height = Math.abs(currentY - currentMark.startY);
    const x = Math.min(currentMark.startX, currentX);
    const y = Math.min(currentMark.startY, currentY);
    
    currentMark.x = x;
    currentMark.y = y;
    currentMark.width = width;
    currentMark.height = height;
    
    if (currentMark.element) {
        currentMark.element.style.left = `${x}px`;
        currentMark.element.style.top = `${y}px`;
        currentMark.element.style.width = `${width}px`;
        currentMark.element.style.height = `${height}px`;
    }
}

// å®Œæˆæ¨™è¨˜
function finishMark(e) {
    if (!currentMark) return;
    
    document.removeEventListener('mousemove', updateMark, true);
    document.removeEventListener('mouseup', finishMark, true);
    document.removeEventListener('touchmove', updateMark, true);
    document.removeEventListener('touchend', finishMark, true);
    
    if (currentMark.width > 10 && currentMark.height > 10) {
        // ä¿å­˜æ¨™è¨˜
        if (!marks[currentMark.pageNum]) {
            marks[currentMark.pageNum] = [];
        }
        marks[currentMark.pageNum].push({
            id: currentMark.id,
            x: currentMark.x,
            y: currentMark.y,
            width: currentMark.width,
            height: currentMark.height,
            text: '', // å°‡åœ¨é»æ“Šæ™‚æå–
            replacementText: '' // æ›¿æ›æ–‡å­—ï¼Œç”¨æ–¼éŒ¯èª¤ç™¼éŸ³ä¿®æ­£
        });
        
        // ä¿å­˜æ¨™è¨˜IDå’Œé ç¢¼åˆ°è®Šé‡ä¸­ï¼Œé¿å…é–‰åŒ…å•é¡Œ
        const markId = currentMark.id;
        const markPageNum = currentMark.pageNum;
        
        // æ·»åŠ é»æ“Šäº‹ä»¶ï¼ˆé»æ“Šå€å¡Šæ™‚æœ—è®€ï¼‰
        currentMark.element.addEventListener('click', (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯åˆªé™¤æŒ‰éˆ•ã€ç·¨è¼¯æŒ‰éˆ•ã€èª¿æ•´å¤§å°æ§åˆ¶é»æˆ–å…¶å­å…ƒç´ ï¼Œä¸è§¸ç™¼æœ—è®€
            if (e.target.classList.contains('mark-delete') || 
                e.target.closest('.mark-delete') ||
                e.target.classList.contains('mark-edit') || 
                e.target.closest('.mark-edit') ||
                e.target.classList.contains('resize-handle')) {
                e.stopPropagation();
                return;
            }
            // åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹ä¸è§¸ç™¼èªéŸ³ï¼Œé¿å…éŒ¯èª¤
            if (isMarkingMode) {
                return;
            }
            // æª¢æŸ¥æ˜¯å¦å‰›å‰›é€²è¡Œäº†æ‹–æ‹½æˆ–èª¿æ•´å¤§å°ï¼ˆé¿å…èª¤è§¸ç™¼æœ—è®€ï¼‰
            const wasDragging = currentMark.element.classList.contains('dragging');
            if (wasDragging) {
                // å¦‚æœå‰›å‰›æ‹–æ‹½éï¼Œä¸è§¸ç™¼æœ—è®€
                return;
            }
            // é»æ“Šæ¨™è¨˜å€åŸŸè§¸ç™¼æœ—è®€ï¼ˆéæ¨™è¨˜æ¨¡å¼ä¸‹ï¼‰
            e.stopPropagation();
            readMarkBlock(markId, markPageNum);
            // åœ¨æœ—è®€å¾Œé€²è¡Œå¹•å¾Œä¿å­˜
            saveMarksToPdf(false);
        });
        
        // ç¢ºä¿ locked å±¬æ€§å­˜åœ¨
        if (!marks[markPageNum]) {
            marks[markPageNum] = [];
        }
        const markData = marks[markPageNum].find(m => m.id === markId);
        if (markData && markData.locked === undefined) {
            markData.locked = false;
        }
        
        // å‰µå»ºå·¥å…·æ¬„å®¹å™¨
        const toolbar = document.createElement('div');
        toolbar.className = 'mark-toolbar';
        
        // å¦‚æœæ¨™è¨˜æ¡†å¯¬åº¦ä¸è¶³ï¼ˆå°æ–¼ 80pxï¼‰ï¼Œå·¥å…·æ¬„é¡¯ç¤ºåœ¨å¤–éƒ¨
        const markWidth = parseFloat(currentMark.element.style.width) || currentMark.width;
        if (markWidth < 80) {
            toolbar.classList.add('small-box');
        }
        
        // æ·»åŠ é–é ­æŒ‰éˆ•
        const lockBtn = document.createElement('div');
        lockBtn.className = 'mark-lock';
        const isLocked = markData ? markData.locked : false;
        lockBtn.textContent = isLocked ? 'ğŸ”’' : 'ğŸ”“';
        lockBtn.title = isLocked ? 'è§£é–æ¨™è¨˜ï¼ˆè§£é–å¾Œå¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰' : 'é–å®šæ¨™è¨˜ï¼ˆé–å®šå¾Œä¸å¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
        if (isLocked) {
            lockBtn.classList.add('locked');
            currentMark.element.classList.add('locked');
        }
        
        // ä½¿ç”¨æ¨™è¨˜é˜²æ­¢é‡è¤‡è§¸ç™¼
        let isLockHandling = false;
        
        const handleLock = async (e) => {
            // é˜²æ­¢é‡è¤‡è§¸ç™¼
            if (isLockHandling) {
                return false;
            }
            
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            isLockHandling = true;
            
            // ç¢ºä¿ markData å°è±¡å­˜åœ¨
            if (!markData) {
                console.error('æ‰¾ä¸åˆ°æ¨™è¨˜æ•¸æ“š:', markId);
                isLockHandling = false;
                return false;
            }
            
            // åˆ‡æ›é–å®šç‹€æ…‹
            markData.locked = !markData.locked;
            
            console.log('åˆ‡æ›é–å®šç‹€æ…‹ï¼Œæ¨™è¨˜ID:', markId, 'æ–°ç‹€æ…‹:', markData.locked);
            
            // ç«‹å³æ›´æ–°æ¨™è¨˜æ¡†ç‹€æ…‹
            if (markData.locked) {
                currentMark.element.classList.add('locked');
                lockBtn.textContent = 'ğŸ”’';
                lockBtn.classList.add('locked');
                lockBtn.title = 'è§£é–æ¨™è¨˜ï¼ˆè§£é–å¾Œå¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
            } else {
                currentMark.element.classList.remove('locked');
                lockBtn.textContent = 'ğŸ”“';
                lockBtn.classList.remove('locked');
                lockBtn.title = 'é–å®šæ¨™è¨˜ï¼ˆé–å®šå¾Œä¸å¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
            }
            
            // ä¿å­˜åˆ° PDFï¼ˆç•°æ­¥åŸ·è¡Œï¼Œä¸é˜»å¡ UI æ›´æ–°ï¼‰
            saveMarksToPdf(false).catch(err => {
                console.error('ä¿å­˜é–å®šç‹€æ…‹å¤±æ•—:', err);
            }).finally(() => {
                // å»¶é²é‡ç½®æ¨™è¨˜ï¼Œç¢ºä¿æ‰€æœ‰äº‹ä»¶éƒ½è™•ç†å®Œ
                setTimeout(() => {
                    isLockHandling = false;
                }, 100);
            });
            
            return false;
        };
        
        // åªä½¿ç”¨ click äº‹ä»¶ï¼Œé¿å… mousedown å’Œ click é‡è¤‡è§¸ç™¼
        lockBtn.addEventListener('click', handleLock);
        toolbar.appendChild(lockBtn);
        
        // æ·»åŠ ç·¨è¼¯æŒ‰éˆ•
        const editBtn = document.createElement('div');
        editBtn.className = 'mark-edit';
        editBtn.textContent = 'âœ';
        editBtn.title = 'ç·¨è¼¯æ›¿æ›æ–‡å­—';
        
        const handleEdit = (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            editMarkReplacementText(markId, markPageNum);
            return false;
        };
        
        editBtn.addEventListener('click', handleEdit);
        toolbar.appendChild(editBtn);
        
        // æ·»åŠ åˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'mark-delete';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'åˆªé™¤æ­¤æ¨™è¨˜';
        
        // ä½¿ç”¨ click äº‹ä»¶
        const handleDelete = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±åˆªé™¤
            if (markData && markData.locked) {
                Swal.fire({
                    icon: 'warning',
                    title: 'ç„¡æ³•åˆªé™¤',
                    text: 'æ¨™è¨˜å·²é–å®šï¼Œè«‹å…ˆè§£é–å¾Œå†åˆªé™¤',
                    timer: 2000,
                    showConfirmButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    }
                });
                return false;
            }
            console.log('åˆªé™¤æŒ‰éˆ•è¢«é»æ“Šï¼Œæ¨™è¨˜ID:', markId);
            await deleteMarkBlock(markId, markPageNum);
            return false;
        };
        
        deleteBtn.addEventListener('click', handleDelete);
        toolbar.appendChild(deleteBtn);
        
        // å°‡å·¥å…·æ¬„æ·»åŠ åˆ°æ¨™è¨˜æ¡†
        currentMark.element.appendChild(toolbar);
        
        // åœ¨ç·¨è¼¯æ¨¡å¼ä¸‹æ·»åŠ èª¿æ•´å¤§å°çš„æ§åˆ¶é»å’Œæ‹–æ‹½åŠŸèƒ½ï¼ˆèˆ‡renderMarksç›¸åŒï¼‰
        if (isMarkingMode) {
            // æ·»åŠ èª¿æ•´å¤§å°çš„æ§åˆ¶é»ï¼ˆ8å€‹æ–¹å‘ï¼‰
            const resizeHandles = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'];
            resizeHandles.forEach(direction => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${direction}`;
                handle.dataset.direction = direction;
                currentMark.element.appendChild(handle);
            });
            
            // æ‹–æ‹½ç§»å‹•åŠŸèƒ½ï¼ˆä½¿ç”¨é–‰åŒ…ä¿å­˜æ¯å€‹æ¨™è¨˜çš„ç‹€æ…‹ï¼‰
            const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentMark.pageNum}"]`);
            const markBlock = currentMark.element;
            const markState = {
                isDragging: false,
                isResizing: false,
                resizeDirection: null,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0,
                startWidth: 0,
                startHeight: 0
            };
            
            // å®šç¾©äº‹ä»¶è™•ç†å™¨ï¼ˆåœ¨æ‹–æ‹½/èª¿æ•´å¤§å°é–‹å§‹æ™‚æ‰ç¶å®šï¼‰
            let moveHandler = null;
            let endHandler = null;
            let escapeHandler = null;
            
            // ç¶å®šå…¨å±€äº‹ä»¶çš„è¼”åŠ©å‡½æ•¸
            const bindGlobalEvents = () => {
                if (!moveHandler) {
                    moveHandler = (e) => handleMove(e);
                    endHandler = (e) => handleEnd(e);
                    escapeHandler = (e) => {
                        if (e.key === 'Escape' && (markState.isDragging || markState.isResizing)) {
                            // æ¢å¾©åˆ°åŸå§‹ä½ç½®
                            if (markState.isDragging) {
                                markBlock.style.left = `${markState.startLeft}px`;
                                markBlock.style.top = `${markState.startTop}px`;
                            } else if (markState.isResizing) {
                                markBlock.style.left = `${markState.startLeft}px`;
                                markBlock.style.top = `${markState.startTop}px`;
                                markBlock.style.width = `${markState.startWidth}px`;
                                markBlock.style.height = `${markState.startHeight}px`;
                            }
                            handleEnd(e);
                        }
                    };
                    
                    document.addEventListener('mousemove', moveHandler);
                    document.addEventListener('touchmove', moveHandler);
                    document.addEventListener('mouseup', endHandler);
                    document.addEventListener('touchend', endHandler);
                    document.addEventListener('keydown', escapeHandler);
                }
            };
            
            // è™•ç†èª¿æ•´å¤§å°
            const handleResizeStart = (e, direction) => {
                // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±èª¿æ•´å¤§å°
                if (currentMark && marks[currentMark.pageNum]) {
                    const currentMarkData = marks[currentMark.pageNum].find(m => m.id === markId);
                    if (currentMarkData && currentMarkData.locked) {
                        return;
                    }
                }
                e.preventDefault();
                e.stopPropagation();
                markState.isResizing = true;
                markState.isDragging = false;
                markState.resizeDirection = direction;
                const rect = markBlock.getBoundingClientRect();
                const markLayerRect = markLayer.getBoundingClientRect();
                markState.startX = (e.touches ? e.touches[0].clientX : e.clientX);
                markState.startY = (e.touches ? e.touches[0].clientY : e.clientY);
                markState.startLeft = rect.left - markLayerRect.left;
                markState.startTop = rect.top - markLayerRect.top;
                markState.startWidth = rect.width;
                markState.startHeight = rect.height;
                markBlock.classList.add('dragging');
                
                // ç¶å®šå…¨å±€äº‹ä»¶
                bindGlobalEvents();
            };
            
            // è™•ç†æ‹–æ‹½é–‹å§‹
            const handleDragStart = (e) => {
                // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±æ‹–æ‹½
                if (currentMark && marks[currentMark.pageNum]) {
                    const currentMarkData = marks[currentMark.pageNum].find(m => m.id === markId);
                    if (currentMarkData && currentMarkData.locked) {
                        return;
                    }
                }
                // å¦‚æœé»æ“Šçš„æ˜¯æ§åˆ¶é»ã€åˆªé™¤æŒ‰éˆ•ã€ç·¨è¼¯æŒ‰éˆ•æˆ–é–é ­æŒ‰éˆ•ï¼Œä¸é–‹å§‹æ‹–æ‹½
                if (e.target.classList.contains('resize-handle') ||
                    e.target.classList.contains('mark-delete') ||
                    e.target.classList.contains('mark-edit') ||
                    e.target.classList.contains('mark-lock') ||
                    e.target.closest('.mark-delete') ||
                    e.target.closest('.mark-edit') ||
                    e.target.closest('.mark-lock')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                markState.isDragging = true;
                markState.isResizing = false;
                markState.hasMoved = false; // é‡ç½®ç§»å‹•æ¨™è¨˜
                const rect = markBlock.getBoundingClientRect();
                const markLayerRect = markLayer.getBoundingClientRect();
                markState.startX = (e.touches ? e.touches[0].clientX : e.clientX);
                markState.startY = (e.touches ? e.touches[0].clientY : e.clientY);
                markState.startLeft = rect.left - markLayerRect.left;
                markState.startTop = rect.top - markLayerRect.top;
                markBlock.classList.add('dragging');
                
                // ç¶å®šå…¨å±€äº‹ä»¶
                bindGlobalEvents();
            };
            
            // è™•ç†ç§»å‹•/èª¿æ•´å¤§å°
            const handleMove = (e) => {
                if (!markState.isDragging && !markState.isResizing) return;
                e.preventDefault();
                e.stopPropagation();
                
                const currentX = (e.touches ? e.touches[0].clientX : e.clientX);
                const currentY = (e.touches ? e.touches[0].clientY : e.clientY);
                const deltaX = currentX - markState.startX;
                const deltaY = currentY - markState.startY;
                
                // å¦‚æœç§»å‹•è·é›¢è¶…éé–¾å€¼ï¼ˆ5pxï¼‰ï¼Œæ¨™è¨˜ç‚ºçœŸçš„ç§»å‹•äº†
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    markState.hasMoved = true;
                }
                
                if (markState.isResizing && markState.resizeDirection) {
                    // èª¿æ•´å¤§å°
                    let newLeft = markState.startLeft;
                    let newTop = markState.startTop;
                    let newWidth = markState.startWidth;
                    let newHeight = markState.startHeight;
                    
                    if (markState.resizeDirection.includes('n')) {
                        newHeight = Math.max(10, markState.startHeight - deltaY);
                        newTop = markState.startTop + (markState.startHeight - newHeight);
                    }
                    if (markState.resizeDirection.includes('s')) {
                        newHeight = Math.max(10, markState.startHeight + deltaY);
                    }
                    if (markState.resizeDirection.includes('w')) {
                        newWidth = Math.max(10, markState.startWidth - deltaX);
                        newLeft = markState.startLeft + (markState.startWidth - newWidth);
                    }
                    if (markState.resizeDirection.includes('e')) {
                        newWidth = Math.max(10, markState.startWidth + deltaX);
                    }
                    
                    markBlock.style.left = `${newLeft}px`;
                    markBlock.style.top = `${newTop}px`;
                    markBlock.style.width = `${newWidth}px`;
                    markBlock.style.height = `${newHeight}px`;
                } else if (markState.isDragging) {
                    // ç§»å‹•ä½ç½®
                    const markLayerRect = markLayer.getBoundingClientRect();
                    const newLeft = markState.startLeft + deltaX;
                    const newTop = markState.startTop + deltaY;
                    
                    // é™åˆ¶åœ¨æ¨™è¨˜å±¤ç¯„åœå…§
                    const maxLeft = markLayerRect.width - parseFloat(markBlock.style.width);
                    const maxTop = markLayerRect.height - parseFloat(markBlock.style.height);
                    
                    markBlock.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
                    markBlock.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
                }
            };
            
            // è™•ç†çµæŸ
            const handleEnd = async (e) => {
                // ç§»é™¤äº‹ä»¶ç›£è½å™¨ï¼ˆé‡è¦ï¼šé˜²æ­¢äº‹ä»¶ç›£è½å™¨æ®˜ç•™ï¼‰
                if (moveHandler) {
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('touchmove', moveHandler);
                }
                if (endHandler) {
                    document.removeEventListener('mouseup', endHandler);
                    document.removeEventListener('touchend', endHandler);
                }
                if (escapeHandler) {
                    document.removeEventListener('keydown', escapeHandler);
                }
                
                // æª¢æŸ¥æ˜¯å¦çœŸçš„ç§»å‹•äº†ï¼ˆé€šéæ¯”è¼ƒæœ€çµ‚ä½ç½®å’Œèµ·å§‹ä½ç½®ï¼‰
                const finalLeft = parseFloat(markBlock.style.left);
                const finalTop = parseFloat(markBlock.style.top);
                const finalWidth = parseFloat(markBlock.style.width);
                const finalHeight = parseFloat(markBlock.style.height);
                const positionChanged = Math.abs(finalLeft - markState.startLeft) > 1 || 
                                       Math.abs(finalTop - markState.startTop) > 1;
                const sizeChanged = Math.abs(finalWidth - markState.startWidth) > 1 || 
                                   Math.abs(finalHeight - markState.startHeight) > 1;
                
                // è¨˜éŒ„æ˜¯å¦éœ€è¦è§¸ç™¼èªéŸ³ï¼ˆåªæœ‰åœ¨æ‹–æ‹½ä¸”æ²’æœ‰ç§»å‹•æ™‚ï¼‰
                let shouldRead = false;
                
                if (markState.isDragging || markState.isResizing) {
                    // å¦‚æœç§»å‹•äº†ä½ç½®æˆ–èª¿æ•´äº†å¤§å°ï¼Œæ›´æ–°æ¨™è¨˜æ•¸æ“š
                    if (positionChanged || sizeChanged || markState.hasMoved) {
                        const updatedMark = marks[currentMark.pageNum].find(m => m.id === markId);
                        if (updatedMark) {
                            updatedMark.x = finalLeft;
                            updatedMark.y = finalTop;
                            updatedMark.width = finalWidth;
                            updatedMark.height = finalHeight;
                            
                            // å¦‚æœèª¿æ•´äº†å¤§å°ï¼Œé‡æ–°æå–æ–‡å­—
                            if (markState.isResizing && sizeChanged) {
                                updatedMark.text = extractTextFromMark(updatedMark, currentMark.pageNum);
                                console.log('æ¨™è¨˜å¤§å°å·²èª¿æ•´ï¼Œé‡æ–°æå–æ–‡å­—:', updatedMark.text);
                            }
                            
                            // éœé»˜ä¿å­˜ï¼ˆä¸é¡¯ç¤ºå½ˆçª—ï¼‰
                            // ç­‰å¾…ä¿å­˜å®Œæˆå¾Œå†ç§»é™¤ dragging classï¼Œç¢ºä¿ä¸æœƒè¢«é‡æ–°æ¸²æŸ“ä¸­æ–·
                            await saveMarksToPdf(false);
                        }
                    } else if (markState.isDragging && !markState.isResizing) {
                        // å¦‚æœåªæ˜¯æ‹–æ‹½ä½†æ²’æœ‰ç§»å‹•ï¼Œæ¨™è¨˜éœ€è¦è§¸ç™¼èªéŸ³
                        shouldRead = true;
                    }
                }
                
                markState.isDragging = false;
                markState.isResizing = false;
                markState.resizeDirection = null;
                markState.hasMoved = false; // é‡ç½®ç§»å‹•æ¨™è¨˜
                // åœ¨ä¿å­˜å®Œæˆå¾Œæ‰ç§»é™¤ dragging classï¼Œç¢ºä¿ä¿å­˜éç¨‹ä¸­ä¸æœƒè¢«é‡æ–°æ¸²æŸ“
                markBlock.classList.remove('dragging');
                
                // æ¸…ç†äº‹ä»¶è™•ç†å™¨å¼•ç”¨
                moveHandler = null;
                endHandler = null;
                escapeHandler = null;
                
                // å¦‚æœæ²’æœ‰ç§»å‹•ï¼Œè§¸ç™¼èªéŸ³æœ—è®€ï¼ˆåœ¨æ¸…ç†å®Œæˆå¾Œï¼‰
                // ä½†ä¸åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹è§¸ç™¼ï¼Œé¿å…éŒ¯èª¤
                if (shouldRead && !isMarkingMode) {
                    // è¨­ç½®æ¨™è¨˜ï¼Œé¿å… click äº‹ä»¶é‡è¤‡è§¸ç™¼
                    markBlock.dataset.justHandledDrag = 'true';
                    // ä½¿ç”¨ setTimeout ç¢ºä¿æ‰€æœ‰æ¸…ç†å·¥ä½œå®Œæˆå¾Œå†è§¸ç™¼èªéŸ³
                    setTimeout(() => {
                        readMarkBlock(markId, currentMark.pageNum);
                        // æ¸…é™¤æ¨™è¨˜
                        setTimeout(() => {
                            delete markBlock.dataset.justHandledDrag;
                        }, 200);
                    }, 100);
                }
            };
            
            // ç¶å®šäº‹ä»¶ï¼ˆåªåœ¨æ¨™è¨˜å€å¡Šä¸Šç¶å®šï¼Œå…¨å±€äº‹ä»¶åœ¨æ‹–æ‹½é–‹å§‹æ™‚æ‰ç¶å®šï¼‰
            markBlock.addEventListener('mousedown', handleDragStart);
            markBlock.addEventListener('touchstart', handleDragStart);
            
            // ç‚ºæ¯å€‹èª¿æ•´å¤§å°æ§åˆ¶é»ç¶å®šäº‹ä»¶
            resizeHandles.forEach(direction => {
                const handle = markBlock.querySelector(`.resize-handle.${direction}`);
                if (handle) {
                    handle.addEventListener('mousedown', (e) => handleResizeStart(e, direction));
                    handle.addEventListener('touchstart', (e) => handleResizeStart(e, direction));
                }
            });
        }
        
    } else {
        // æ¨™è¨˜å¤ªå°ï¼Œç§»é™¤
        if (currentMark.element) {
            currentMark.element.remove();
        }
    }
    
    currentMark = null;
}

// æœ—è®€æ¨™è¨˜å€å¡Š
async function readMarkBlock(markId, pageNum) {
    // æ¯æ¬¡æœ—è®€æ–°çš„å€å¡Šå‰ï¼Œå…ˆæ¸…é™¤ä¹‹å‰çš„æœ—è®€æ¨™ç¤ºèˆ‡ç™¼éŸ³ç‹€æ…‹
    try {
        const allFraSpans = document.querySelectorAll('#viewerContainer .textLayer my-fra');
        allFraSpans.forEach(span => {
            span.style.backgroundColor = '';
            span.dataset.spoken = '';
        });
        
        // åŒæ­¥åœæ­¢ä»»ä½•æ­£åœ¨é€²è¡Œçš„èªéŸ³
        if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
        }
        const audioPlayer = document.getElementById('audioPlayer');
        if (audioPlayer) {
            audioPlayer.pause();
            audioPlayer.currentTime = 0;
        }
    } catch (e) {
        console.error('æ¸…é™¤å…ˆå‰æœ—è®€æ¨™ç¤ºæ™‚ç™¼ç”ŸéŒ¯èª¤:', e);
    }

    const mark = marks[pageNum]?.find(m => m.id === markId);
    if (!mark) return;
    
    // ç²å–æ¨™è¨˜å±¤å’Œæ–‡å­—å±¤
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
    if (!markLayer) return;
    
    // æ‰¾åˆ°èˆ‡æ¨™è¨˜å±¤åŒä¸€å€‹ pdfViewer ä¸­çš„æ–‡å­—å±¤
    const pdfViewer = markLayer.parentElement;
    if (!pdfViewer) return;
    
    const textLayer = pdfViewer.querySelector('.textLayer');
    
    // æå–æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—ï¼ˆå¦‚æœæœ‰æ–‡å­—å±¤ï¼‰
    let text = '';
    let cleanedText = '';
    const markLayerRect = markLayer.getBoundingClientRect();
    
    if (textLayer) {
        const textLayerRect = textLayer.getBoundingClientRect();
        const spans = textLayer.getElementsByTagName('my-fra');
        
        // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„å¯¦éš›ä½ç½®ï¼ˆè€ƒæ…®æ¨™è¨˜å±¤å’Œæ–‡å­—å±¤çš„ç›¸å°ä½ç½®ï¼‰
        const markInTextLayer = {
            left: mark.x + (markLayerRect.left - textLayerRect.left),
            top: mark.y + (markLayerRect.top - textLayerRect.top),
            right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
            bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
        };
        
        for (let span of spans) {
            const spanRect = span.getBoundingClientRect();
            
            // è¨ˆç®— span åœ¨æ–‡å­—å±¤ä¸­çš„ä½ç½®
            const spanX = spanRect.left - textLayerRect.left;
            const spanY = spanRect.top - textLayerRect.top;
            const spanRight = spanRect.right - textLayerRect.left;
            const spanBottom = spanRect.bottom - textLayerRect.top;
            
            // æª¢æŸ¥ span æ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Šï¼ˆä½¿ç”¨æ›´å¯¬é¬†çš„é‡ç–Šåˆ¤æ–·ï¼‰
            const isOverlapping = !(spanRight < markInTextLayer.left || 
                                    spanX > markInTextLayer.right ||
                                    spanBottom < markInTextLayer.top ||
                                    spanY > markInTextLayer.bottom);
            
            if (isOverlapping) {
                text += span.textContent;
            }
        }
        
        // æ¸…ç†æ–‡å­—ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
        cleanedText = text.trim().replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    }
    
    // å–å¾—åœ–ç‰‡ base64ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    let base64Image = null;
    let croppedCanvas = null;
    const viewerContainer = document.getElementById('viewerContainer');
    const pdfCanvas = viewerContainer.querySelector('canvas');
    if (pdfCanvas) {
        // è¨ˆç®—æ¨™è¨˜åœ¨ç•«å¸ƒä¸­çš„å¯¦éš›ä½ç½®ï¼ˆä½¿ç”¨ getBoundingClientRectï¼Œèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
        const markBlockElement = markLayer.querySelector(`[data-mark-id="${markId}"]`);
        if (markBlockElement) {
            const markBlockRect = markBlockElement.getBoundingClientRect();
            croppedCanvas = cropCanvas(pdfCanvas, markBlockRect);
            base64Image = canvasToBase64(croppedCanvas);
        }
    }
    
    // åˆ¤æ–·æ˜¯å¦æœ‰åœ–ç‰‡å…§å®¹ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    let hasImageContent = false;
    if (croppedCanvas) {
        const isCanvasAllWhiteFunc = window.isCanvasAllWhite || isCanvasAllWhite;
        if (typeof isCanvasAllWhiteFunc === 'function' && !isCanvasAllWhiteFunc(croppedCanvas)) {
            hasImageContent = true;
        }
    }
    
    // åˆ¤æ–·å…§å®¹ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    if (!hasImageContent && cleanedText.length === 0) {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ¨™è¨˜å€åŸŸå…§æ²’æœ‰æ–‡å­—æˆ–åœ–ç‰‡'
        });
        return;
    }
    
    // åªè¦æœ‰ PDF æ–‡å­—å±¤ï¼Œå°±åªæœ—è®€ç´”æ–‡å­—ï¼Œä¸é€åœ–ç‰‡çµ¦ AIï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
    if (cleanedText.length > 0) {
        // å¦‚æœæœ‰æ›¿æ›æ–‡å­—ï¼Œä½¿ç”¨æ›¿æ›æ–‡å­—ï¼›å¦å‰‡ä½¿ç”¨åŸå§‹æ–‡å­—
        text = mark.replacementText && mark.replacementText.trim() ? mark.replacementText.trim() : cleanedText;
    } else if (hasImageContent && base64Image) {
        // å¦‚æœæœ‰æ›¿æ›æ–‡å­—ï¼Œç›´æ¥ä½¿ç”¨æ›¿æ›æ–‡å­—ï¼Œä¸éœ€è¦é€²è¡Œåœ–ç‰‡è¾¨è­˜
        if (mark.replacementText && mark.replacementText.trim()) {
            text = mark.replacementText.trim();
            // ä½¿ç”¨æ›¿æ›æ–‡å­—ï¼Œè·³éåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥é€²å…¥å¾ŒçºŒæœ—è®€æµç¨‹
        } else {
            // æ²’æœ‰æ›¿æ›æ–‡å­—ï¼Œæ‰é€åœ–ç‰‡çµ¦ AIï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼Œåƒè€ƒ readTextInsideFrame çš„é‚è¼¯ï¼‰
            // å¦‚æœæ­£åœ¨é€²è¡Œåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
            if (typeof isImageRecognizing !== 'undefined' && isImageRecognizing) {
                console.log('åœ–ç‰‡è¾¨è­˜æ­£åœ¨é€²è¡Œä¸­ï¼Œå¿½ç•¥é‡è¤‡è«‹æ±‚');
                return;
            }
            
            // è¨­ç½®æ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
            if (typeof isImageRecognizing !== 'undefined') {
                isImageRecognizing = true;
            }
            
            try {
            Swal.fire({
                title: 'æ­£åœ¨è¾¨è­˜åœ–ç‰‡',
                text: 'æ­£åœ¨ä½¿ç”¨ AI è¾¨è­˜åœ–ç‰‡å…§å®¹...ï¼ˆGeminiï¼‰',
                allowOutsideClick: false,
                customClass: {
                    popup: 'swal-high-z-index'
                },
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            // ç¢ºä¿ geminiImageDescribe å‡½æ•¸å¯ç”¨
            const geminiImageDescribeFunc = typeof window !== 'undefined' && window.geminiImageDescribe ? window.geminiImageDescribe : (typeof geminiImageDescribe !== 'undefined' ? geminiImageDescribe : null);
            if (!geminiImageDescribeFunc || typeof geminiImageDescribeFunc !== 'function') {
                Swal.close();
                console.error('geminiImageDescribe å‡½æ•¸æœªå®šç¾©');
                Swal.fire({
                    icon: 'error',
                    title: 'è¾¨è­˜å¤±æ•—',
                    text: 'åœ–ç‰‡è¾¨è­˜å‡½æ•¸æœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
                });
                if (typeof isImageRecognizing !== 'undefined') {
                    isImageRecognizing = false;
                }
                if (typeof isPlayingWaitingMessage !== 'undefined') {
                    isPlayingWaitingMessage = false;
                }
                return;
            }
            const aiDescription = await geminiImageDescribeFunc(base64Image);
            Swal.close();
            if (aiDescription && aiDescription.length > 0) {
                // ç›´æ¥ä½¿ç”¨ Gemini åŸå§‹å›å‚³ï¼Œç›´æ¥èª¿ç”¨ sendTextToTTS æœ—è®€ï¼ˆèˆ‡æ¡†é¸æœ—è®€ä¸€è‡´ï¼‰
                const ttsFunction = window.sendTextToTTS || sendTextToTTS;
                if (typeof ttsFunction === 'function') {
                    ttsFunction(aiDescription, () => {
                        console.log('åœ–ç‰‡è¾¨è­˜æ–‡å­—æœ—è®€å®Œæˆ');
                        // è¾¨è­˜å®Œæˆï¼Œé‡ç½®æ¨™è¨˜
                        if (typeof isImageRecognizing !== 'undefined') {
                            isImageRecognizing = false;
                        }
                        if (typeof isPlayingWaitingMessage !== 'undefined') {
                            isPlayingWaitingMessage = false;
                        }
                    });
                }
                // åœ–ç‰‡è¾¨è­˜å®Œæˆå¾Œç›´æ¥è¿”å›ï¼Œä¸é€²å…¥å¾ŒçºŒçš„æ–‡å­—æœ—è®€æµç¨‹
                return;
            } else {
                console.error('Gemini å›å‚³çš„å…§å®¹ç‚ºç©º');
                Swal.fire({
                    icon: 'warning',
                    title: 'è¾¨è­˜çµæœç‚ºç©º',
                    text: 'AI ç„¡æ³•è¾¨è­˜åœ–ç‰‡å…§å®¹'
                });
                // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
                if (typeof isImageRecognizing !== 'undefined') {
                    isImageRecognizing = false;
                }
                if (typeof isPlayingWaitingMessage !== 'undefined') {
                    isPlayingWaitingMessage = false;
                }
                return;
            }
        } catch (error) {
            Swal.close();
            console.error('Gemini è¾¨è­˜å¤±æ•—:', error);
            Swal.fire({
                icon: 'error',
                title: 'è¾¨è­˜å¤±æ•—',
                text: 'AI è¾¨è­˜éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚'
            });
            // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
            if (typeof isImageRecognizing !== 'undefined') {
                isImageRecognizing = false;
            }
            if (typeof isPlayingWaitingMessage !== 'undefined') {
                isPlayingWaitingMessage = false;
            }
            return;
            }
        }
    } else if (hasImageContent && !base64Image) {
        // æœ‰åœ–ç‰‡å…§å®¹ä½† base64Image ç‚º nullï¼Œå¯èƒ½æ˜¯è£å‰ªå¤±æ•—
        console.error('ç„¡æ³•ç²å–åœ–ç‰‡ base64ï¼Œå¯èƒ½è£å‰ªå¤±æ•—');
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•è¾¨è­˜',
            text: 'ç„¡æ³•ç²å–æ¨™è¨˜å€åŸŸçš„åœ–ç‰‡å…§å®¹ï¼Œè«‹ç¢ºä¿æ¨™è¨˜å€åŸŸåŒ…å«åœ–ç‰‡'
        });
        return;
    }
    
    if (text.trim()) {
        // é«˜äº®é¡¯ç¤ºæ¨™è¨˜
        const markElement = markLayer.querySelector(`[data-mark-id="${markId}"]`);
        if (markElement) {
            markElement.classList.add('active');
        }
        
        // å°‡æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—èƒŒæ™¯è®Šæˆæ·¡é»ƒè‰²ï¼ˆåƒ…åœ¨æœ‰æ–‡å­—å±¤æ™‚ï¼‰
        const highlightedSpans = [];
        if (textLayer) {
            const textLayerRect = textLayer.getBoundingClientRect();
            const markLayerRect = markLayer.getBoundingClientRect();
            const spans = textLayer.getElementsByTagName('my-fra');
            
            // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„å¯¦éš›ä½ç½®
            const markInTextLayer = {
                left: mark.x + (markLayerRect.left - textLayerRect.left),
                top: mark.y + (markLayerRect.top - textLayerRect.top),
                right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
                bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
            };
            
            for (let span of spans) {
                const spanRect = span.getBoundingClientRect();
                const spanX = spanRect.left - textLayerRect.left;
                const spanY = spanRect.top - textLayerRect.top;
                const spanRight = spanRect.right - textLayerRect.left;
                const spanBottom = spanRect.bottom - textLayerRect.top;
                
                // æª¢æŸ¥ span æ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Š
                const isOverlapping = !(spanRight < markInTextLayer.left || 
                                    spanX > markInTextLayer.right ||
                                    spanBottom < markInTextLayer.top ||
                                    spanY > markInTextLayer.bottom);
                
                if (isOverlapping) {
                    // ä¿å­˜åŸå§‹èƒŒæ™¯è‰²ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
                    const originalBg = span.style.backgroundColor;
                    highlightedSpans.push({ span, originalBg });
                    // è¨­ç½®æ·¡é»ƒè‰²èƒŒæ™¯ï¼ˆä¸æ“‹ä½å…§å®¹ï¼Œä½¿ç”¨åŠé€æ˜ï¼‰
                    span.style.backgroundColor = 'rgba(255, 255, 200, 0.4)';
                }
            }
        }
        
        // ç™¼é€æ–‡å­—çµ¦TTSæœ—è®€
        await new Promise((resolve) => {
            // ä½¿ç”¨å…¨å±€çš„ sendTextToTTS å‡½æ•¸
            const ttsFunction = window.sendTextToTTS || sendTextToTTS;
            if (typeof ttsFunction === 'function') {
                ttsFunction(text.trim(), () => {
                    // æœ—è®€å®Œæˆå¾Œï¼Œæ¸…é™¤æ–‡å­—èƒŒæ™¯è‰²
                    highlightedSpans.forEach(({ span, originalBg }) => {
                        if (originalBg) {
                            span.style.backgroundColor = originalBg;
                        } else {
                            span.style.backgroundColor = '';
                        }
                    });
                    // æ¸…é™¤æ¨™è¨˜å…ƒç´ çš„é«˜äº®
                    if (markElement) {
                        markElement.classList.remove('active');
                    }
                    resolve();
                });
            } else {
                console.error('sendTextToTTS å‡½æ•¸æœªå®šç¾©ï¼Œè«‹æª¢æŸ¥å‡½æ•¸æ˜¯å¦å·²æ­£ç¢ºè¼‰å…¥');
                // æ¸…é™¤æ–‡å­—èƒŒæ™¯è‰²
                highlightedSpans.forEach(({ span, originalBg }) => {
                    if (originalBg) {
                        span.style.backgroundColor = originalBg;
                    } else {
                        span.style.backgroundColor = '';
                    }
                });
                // æ¸…é™¤æ¨™è¨˜å…ƒç´ çš„é«˜äº®
                if (markElement) {
                    markElement.classList.remove('active');
                }
                Swal.fire({
                    icon: 'error',
                    title: 'æœ—è®€å¤±æ•—',
                    text: 'TTS å‡½æ•¸æœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
                });
                resolve();
            }
        });
        
        // åœ¨å¹•å¾Œä¿å­˜æ¨™è¨˜ï¼ˆä¸é¡¯ç¤ºå½ˆçª—ï¼‰
        saveMarksToPdf(false);
    } else {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ­¤å€å¡Šå…§æ²’æœ‰å¯æœ—è®€çš„æ–‡å­—æˆ–åœ–ç‰‡'
        });
    }
}

// æå–æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—ï¼ˆè¼”åŠ©å‡½æ•¸ï¼Œç”¨æ–¼é‡æ–°æå–æ–‡å­—ï¼‰
function extractTextFromMark(mark, pageNum) {
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
    if (!markLayer) return '';
    
    const pdfViewer = markLayer.parentElement;
    const textLayer = pdfViewer?.querySelector('.textLayer');
    if (!textLayer) return '';
    
    const textLayerRect = textLayer.getBoundingClientRect();
    const markLayerRect = markLayer.getBoundingClientRect();
    const spans = textLayer.getElementsByTagName('my-fra');
    
    // è¨ˆç®—æ¨™è¨˜åœ¨æ–‡å­—å±¤ä¸­çš„å¯¦éš›ä½ç½®
    const markInTextLayer = {
        left: mark.x + (markLayerRect.left - textLayerRect.left),
        top: mark.y + (markLayerRect.top - textLayerRect.top),
        right: mark.x + mark.width + (markLayerRect.left - textLayerRect.left),
        bottom: mark.y + mark.height + (markLayerRect.top - textLayerRect.top)
    };
    
    let text = '';
    let lastSpanY = null;
    let lastSpanBottom = null;
    
    // éæ­·æ‰€æœ‰ spanï¼Œæå–åœ¨æ¨™è¨˜å€åŸŸå…§çš„æ–‡å­—
    for (let span of spans) {
        const spanRect = span.getBoundingClientRect();
        
        // è¨ˆç®— span åœ¨æ–‡å­—å±¤ä¸­çš„ä½ç½®
        const spanX = spanRect.left - textLayerRect.left;
        const spanY = spanRect.top - textLayerRect.top;
        const spanRight = spanRect.right - textLayerRect.left;
        const spanBottom = spanRect.bottom - textLayerRect.top;
        
        // æª¢æŸ¥ span æ˜¯å¦èˆ‡æ¨™è¨˜å€åŸŸé‡ç–Š
        const isOverlapping = !(spanRight < markInTextLayer.left || 
                                spanX > markInTextLayer.right ||
                                spanBottom < markInTextLayer.top ||
                                spanY > markInTextLayer.bottom);
        
        if (isOverlapping) {
            // æª¢æ¸¬æ˜¯å¦éœ€è¦æ›è¡Œï¼ˆYåº§æ¨™æœ‰æ˜é¡¯è®ŠåŒ–ï¼Œè¡¨ç¤ºæ›è¡Œï¼‰
            if (lastSpanY !== null && lastSpanBottom !== null) {
                const yGap = spanY - lastSpanBottom;
                // å¦‚æœYåº§æ¨™å·®è·è¶…éå­—é«”å¤§å°çš„50%ï¼Œèªç‚ºæ˜¯æ›è¡Œ
                const fontSize = spanRect.height || 16;
                if (yGap > fontSize * 0.5) {
                    text += '\n';
                }
            }
            text += span.textContent;
            lastSpanY = spanY;
            lastSpanBottom = spanBottom;
        }
    }
    
    // æ¸…ç†æ–‡å­—ï¼šå¾¹åº•å»é™¤å‰å°ç©ºæ ¼ï¼Œä¿ç•™æ›è¡Œï¼Œæ¸…ç†å¤šé¤˜çš„ç©ºç™½
    // å…ˆå»é™¤é–‹é ­çš„æ‰€æœ‰ç©ºæ ¼ã€Tabï¼ˆåŒ…æ‹¬å…¨å½¢ç©ºæ ¼ï¼‰
    text = text.replace(/^[\s\t\u3000]+/, '');
    // å°‡å¤šå€‹é€£çºŒç©ºæ ¼å’Œ Tab æ›¿æ›ç‚ºå–®å€‹ç©ºæ ¼
    text = text.replace(/[ \t\u3000]+/g, ' ');
    // æ¸…ç†æ›è¡Œç¬¦å‰å¾Œçš„ç©ºæ ¼å’Œ Tabï¼Œä½†ä¿ç•™æ›è¡Œç¬¦
    text = text.replace(/[ \t\u3000]*\n[ \t\u3000]*/g, '\n');
    // å»é™¤æ¯è¡Œé–‹é ­çš„ç©ºæ ¼å’Œ Tab
    text = text.replace(/\n[ \t\u3000]+/g, '\n');
    // æœ€å¾Œå»é™¤å‰å¾Œç©ºç™½ï¼ˆåŒ…æ‹¬å…¨å½¢ç©ºæ ¼ï¼‰
    text = text.trim();
    // å†æ¬¡ç¢ºä¿é–‹é ­æ²’æœ‰ç©ºæ ¼
    text = text.replace(/^[\s\t\u3000]+/, '');
    return text;
}

// ç·¨è¼¯æ¨™è¨˜çš„æ›¿æ›æ–‡å­—
async function editMarkReplacementText(markId, pageNum) {
    // ä¸éœ€è¦å†æ¬¡é©—è­‰å¯†ç¢¼ï¼Œå› ç‚ºé€²å…¥æ¨™è¨˜æ¨¡å¼æ™‚å·²ç¶“é©—è­‰éäº†
    const mark = marks[pageNum]?.find(m => m.id === markId);
    if (!mark) return;
    
    // ç¸½æ˜¯é‡æ–°æå–åŸå§‹æ–‡å­—ï¼Œä½¿ç”¨ extractTextFromMark å‡½æ•¸
    mark.text = extractTextFromMark(mark, pageNum);
    
    // ç¢ºä¿é¡¯ç¤ºæ™‚å»é™¤å‰å°ç©ºæ ¼ï¼ˆé›™é‡æª¢æŸ¥ï¼‰
    let displayText = mark.text || '(ç„¡æ–‡å­—)';
    if (displayText !== '(ç„¡æ–‡å­—)') {
        // å»é™¤å‰å°ç©ºæ ¼ã€Tab å’Œå…¨å½¢ç©ºæ ¼
        displayText = displayText.replace(/^[\s\t\u3000]+/, '');
    }
    
    const result = await Swal.fire({
        title: 'ç·¨è¼¯æ›¿æ›æ–‡å­—',
        html: `
            <div style="text-align: left; margin-bottom: 20px; width: 100%; box-sizing: border-box;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; width: 95%; box-sizing: border-box;">
                    <label style="font-weight: bold; font-size: 18px; color: #333; margin: 0;">åŸå§‹æ–‡å­—ï¼š</label>
                    <button id="copyOriginalTextBtn" type="button" onclick="window.copyOriginalToReplacement && window.copyOriginalToReplacement()" style="padding: 6px 12px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: normal; white-space: nowrap; pointer-events: auto; z-index: 10000; position: relative;">è¤‡è£½åˆ°æ›¿æ›æ–‡å­—</button>
                </div>
                <div id="originalTextDisplay" style="width: 95%; margin-left: 0; margin-right: auto; padding: 12px 12px 12px 0; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 6px; min-height: 50px; max-height: 300px; overflow-y: auto; word-wrap: break-word; word-break: break-all; font-size: 15px; line-height: 1.8; color: #555; box-sizing: border-box; white-space: pre-wrap; font-family: inherit; cursor: pointer;" title="é»æ“Šæ­¤è™•ç™¼éŸ³">${displayText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
            </div>
            <div style="text-align: left; width: 100%; box-sizing: border-box;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; width: 95%; box-sizing: border-box;">
                    <label for="replacementTextInput" style="font-weight: bold; font-size: 18px; color: #333; margin: 0;">æ›¿æ›æ–‡å­—ï¼ˆç•™ç©ºå‰‡ä½¿ç”¨åŸå§‹æ–‡å­—ï¼‰ï¼š</label>
                    <button id="previewReplacementTextBtn" type="button" style="padding: 6px 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: normal; white-space: nowrap; pointer-events: auto; z-index: 10000; position: relative;">æ›¿æ›æ–‡å­—è©¦è½</button>
                </div>
                <textarea id="replacementTextInput" class="swal2-textarea" placeholder="è¼¸å…¥æ›¿æ›æ–‡å­—" style="width: 95%; margin-left: 0; margin-right: auto; min-height: 80px; max-height: 200px; resize: vertical; box-sizing: border-box; font-size: 15px; padding: 12px; border: 1px solid #ccc; border-radius: 6px; word-wrap: break-word; word-break: break-word; white-space: pre-wrap; overflow-wrap: break-word; overflow-x: hidden; overflow-y: auto; line-height: 1.6; font-family: inherit;">${(mark.replacementText || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
            </div>
        `,
        width: '90%',
        maxWidth: '600px',
        showCancelButton: true,
        confirmButtonText: 'å„²å­˜',
        cancelButtonText: 'å–æ¶ˆ',
        customClass: {
            popup: 'swal-high-z-index'
        },
        didOpen: () => {
            const input = document.getElementById('replacementTextInput');
            if (input) {
                input.focus();
                input.select();
            }
            
            // å®šç¾©å…¨å±€å‡½æ•¸ç”¨æ–¼è¤‡è£½åŸå§‹æ–‡å­—åˆ°æ›¿æ›æ–‡å­—æ¡†
            window.copyOriginalToReplacement = function() {
                console.log('è¤‡è£½å‡½æ•¸è¢«èª¿ç”¨ï¼ŒdisplayText:', displayText);
                const replacementInput = document.getElementById('replacementTextInput');
                const copyBtn = document.getElementById('copyOriginalTextBtn');
                if (replacementInput && copyBtn) {
                    // å°‡åŸå§‹æ–‡å­—è¤‡è£½åˆ°æ›¿æ›æ–‡å­—æ¡†
                    replacementInput.value = displayText;
                    replacementInput.focus();
                    console.log('å·²è¤‡è£½æ–‡å­—åˆ°æ›¿æ›æ–‡å­—æ¡†:', displayText);
                    // é¡¯ç¤ºæç¤º
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'å·²è¤‡è£½ï¼';
                    copyBtn.style.backgroundColor = '#28a745';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.style.backgroundColor = '#007bff';
                    }, 1500);
                } else {
                    console.error('æ‰¾ä¸åˆ°æ›¿æ›æ–‡å­—è¼¸å…¥æ¡†æˆ–è¤‡è£½æŒ‰éˆ•');
                }
            };
            
            // ä¹Ÿä½¿ç”¨ addEventListener ä½œç‚ºå‚™ç”¨ï¼ˆå»¶é²ç¶å®šç¢ºä¿ DOM å·²æº–å‚™å¥½ï¼‰
            setTimeout(() => {
                const copyBtn = document.getElementById('copyOriginalTextBtn');
                if (copyBtn) {
                    copyBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        window.copyOriginalToReplacement();
                    });
                    console.log('å·²ç¶å®šè¤‡è£½æŒ‰éˆ•äº‹ä»¶ç›£è½å™¨');
                }
                
                // ç‚ºåŸå§‹æ–‡å­—æ¬„ä½æ·»åŠ é»æ“Šäº‹ä»¶ï¼Œè§¸ç™¼èªéŸ³æœ—è®€
                const originalTextDisplay = document.getElementById('originalTextDisplay');
                if (originalTextDisplay) {
                    // æ·»åŠ é»æ“Šäº‹ä»¶
                    originalTextDisplay.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        // ä½¿ç”¨é¦–é é¸æ“‡çš„ç™¼éŸ³æ–¹å¼ç™¼éŸ³
                        if (displayText && displayText !== '(ç„¡æ–‡å­—)') {
                            sendTextToTTS(displayText);
                        }
                    });
                    console.log('å·²ç‚ºåŸå§‹æ–‡å­—æ¬„ä½ç¶å®šé»æ“Šç™¼éŸ³äº‹ä»¶');
                } else {
                    console.warn('æ‰¾ä¸åˆ°åŸå§‹æ–‡å­—é¡¯ç¤ºæ¬„ä½');
                }
                
                // ç‚ºè©¦è½æŒ‰éˆ•ç¶å®šé»æ“Šäº‹ä»¶ï¼Œè©¦è½æ›¿æ›æ–‡å­—æ¬„ä½çš„å…§å®¹
                const previewBtn = document.getElementById('previewReplacementTextBtn');
                if (previewBtn) {
                    previewBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const replacementInput = document.getElementById('replacementTextInput');
                        if (replacementInput) {
                            const replacementText = replacementInput.value.trim();
                            // å¦‚æœæ›¿æ›æ–‡å­—ç‚ºç©ºï¼Œä½¿ç”¨åŸå§‹æ–‡å­—
                            const textToRead = replacementText || displayText;
                            if (textToRead && textToRead !== '(ç„¡æ–‡å­—)') {
                                // ä½¿ç”¨é¦–é é¸æ“‡çš„ç™¼éŸ³æ–¹å¼ç™¼éŸ³
                                sendTextToTTS(textToRead);
                                // é¡¯ç¤ºæç¤º
                                const originalText = previewBtn.textContent;
                                previewBtn.textContent = 'æ’­æ”¾ä¸­...';
                                previewBtn.style.backgroundColor = '#ffc107';
                                // æ³¨æ„ï¼šé€™è£¡ç„¡æ³•æº–ç¢ºçŸ¥é“æ’­æ”¾ä½•æ™‚çµæŸï¼Œæ‰€ä»¥è¨­ç½®ä¸€å€‹è¼ƒé•·çš„å»¶é²
                                setTimeout(() => {
                                    previewBtn.textContent = originalText;
                                    previewBtn.style.backgroundColor = '#28a745';
                                }, 3000);
                            } else {
                                // å¦‚æœæ²’æœ‰æ–‡å­—ï¼Œé¡¯ç¤ºæç¤º
                                const originalText = previewBtn.textContent;
                                previewBtn.textContent = 'ç„¡æ–‡å­—';
                                previewBtn.style.backgroundColor = '#dc3545';
                                setTimeout(() => {
                                    previewBtn.textContent = originalText;
                                    previewBtn.style.backgroundColor = '#28a745';
                                }, 1500);
                            }
                        }
                    });
                    console.log('å·²ç‚ºè©¦è½æŒ‰éˆ•ç¶å®šé»æ“Šäº‹ä»¶');
                } else {
                    console.warn('æ‰¾ä¸åˆ°è©¦è½æŒ‰éˆ•');
                }
            }, 100);
        },
        preConfirm: () => {
            const input = document.getElementById('replacementTextInput');
            return input ? input.value.trim() : '';
        }
    });
    
    if (result.isConfirmed) {
        mark.replacementText = result.value;
        // ä¿å­˜åˆ°PDF
        await saveMarksToPdf();
        Swal.fire({
            icon: 'success',
            title: 'å·²å„²å­˜',
            text: 'æ›¿æ›æ–‡å­—å·²å„²å­˜',
            timer: 1500,
            showConfirmButton: false,
            customClass: {
                popup: 'swal-high-z-index'
            }
        });
    }
    
    // ç·¨è¼¯è¦–çª—é—œé–‰å¾Œï¼Œç¢ºä¿é‡ç½®æ‰€æœ‰æ¨™è¨˜æ¡†çš„ç‹€æ…‹ï¼Œé¿å…å½±éŸ¿å¾ŒçºŒæ“ä½œ
    // æ¸…é™¤æ‰€æœ‰å¯èƒ½çš„ dragging ç‹€æ…‹å’Œæ®˜ç•™çš„äº‹ä»¶ç›£è½å™¨
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${pageNum}"]`);
    if (markLayer) {
        const markBlocks = markLayer.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            // ç§»é™¤ dragging class
            block.classList.remove('dragging');
            // æ¸…é™¤å¯èƒ½æ®˜ç•™çš„æ•¸æ“šå±¬æ€§
            delete block.dataset.justHandledDrag;
        });
    }
    
    // ç¢ºä¿ç•¶å‰é é¢çš„æ¨™è¨˜æ¡†äº‹ä»¶ç›£è½å™¨æ­£å¸¸å·¥ä½œ
    // å¦‚æœè™•æ–¼æ¨™è¨˜æ¨¡å¼ï¼Œé‡æ–°æ¸²æŸ“æ¨™è¨˜ä»¥ç¢ºä¿äº‹ä»¶ç¶å®šæ­£ç¢º
    if (isMarkingMode) {
        // ä½¿ç”¨ setTimeout ç¢ºä¿è¦–çª—å®Œå…¨é—œé–‰å¾Œå†é‡æ–°æ¸²æŸ“
        setTimeout(() => {
            renderMarks();
        }, 100);
    }
}

// åˆªé™¤å–®å€‹æ¨™è¨˜å€å¡Š
async function deleteMarkBlock(markId, pageNum) {
    // ä¸éœ€è¦å†æ¬¡é©—è­‰å¯†ç¢¼ï¼Œå› ç‚ºé€²å…¥æ¨™è¨˜æ¨¡å¼æ™‚å·²ç¶“é©—è­‰éäº†
    console.log('deleteMarkBlock è¢«èª¿ç”¨ï¼ŒmarkId:', markId, 'pageNum:', pageNum);
    
    if (!marks[pageNum]) {
        console.warn('è©²é æ²’æœ‰æ¨™è¨˜:', pageNum);
        return;
    }
    
    // ç›´æ¥åˆªé™¤ï¼Œä¸é¡¯ç¤ºç¢ºèªå°è©±æ¡†ï¼ˆå› ç‚ºç”¨æˆ¶å·²ç¶“é»æ“Šäº†åˆªé™¤æŒ‰éˆ•ï¼‰
    // å¾æ¨™è¨˜æ•¸çµ„ä¸­ç§»é™¤
    const originalLength = marks[pageNum].length;
    marks[pageNum] = marks[pageNum].filter(m => m.id !== markId);
    
    if (marks[pageNum].length === originalLength) {
        console.warn('æœªæ‰¾åˆ°è¦åˆªé™¤çš„æ¨™è¨˜ï¼ŒmarkId:', markId);
        return;
    }
    
    // å¦‚æœè©²é æ²’æœ‰æ¨™è¨˜äº†ï¼Œåˆªé™¤è©²é çš„æ¨™è¨˜æ•¸çµ„
    if (marks[pageNum].length === 0) {
        delete marks[pageNum];
    }
    
    // é‡æ–°æ¸²æŸ“æ¨™è¨˜
    renderMarks();
    
    console.log('æ¨™è¨˜å·²åˆªé™¤ï¼ŒmarkId:', markId);
}

// æ¨™è¨˜é¡¯ç¤ºç‹€æ…‹
let marksVisible = false;

// åˆ‡æ›æ¨™è¨˜é¡¯ç¤º/éš±è—
function toggleMarksVisibility() {
    marksVisible = !marksVisible;
    const toggleButton = document.getElementById('toggleMarksButton');
    const markLayers = document.querySelectorAll('.mark-layer');
    
    if (marksVisible) {
        toggleButton.textContent = 'éš±è—æ¨™è¨˜';
        markLayers.forEach(layer => {
            layer.classList.remove('hidden');
        });
    } else {
        toggleButton.textContent = 'é¡¯ç¤ºæ¨™è¨˜';
        markLayers.forEach(layer => {
            layer.classList.add('hidden');
        });
    }
}

// æ›´æ–°æ¨™è¨˜å¯è¦‹æ€§
function updateMarksVisibility() {
    const markLayers = document.querySelectorAll('.mark-layer');
    const toggleButton = document.getElementById('toggleMarksButton');
    
    if (toggleButton) {
        if (marksVisible) {
            markLayers.forEach(layer => {
                layer.classList.remove('hidden');
            });
        } else {
            markLayers.forEach(layer => {
                layer.classList.add('hidden');
            });
        }
    }
}


// å¾PDFæ–‡ä»¶è¼‰å…¥æ¨™è¨˜ï¼ˆå¾PDFå…ƒæ•¸æ“šä¸­è®€å–ï¼‰
async function loadMarksFromPdf() {
    try {
        if (!originalPdfBytes) {
            console.warn('originalPdfBytes æœªè¨­ç½®ï¼Œç„¡æ³•è¼‰å…¥æ¨™è¨˜');
            marks = {};
            return;
        }
        
        if (typeof PDFLib === 'undefined') {
            console.warn('PDFLib æœªè¼‰å…¥ï¼Œç­‰å¾…è¼‰å…¥...');
            // ç­‰å¾… PDFLib è¼‰å…¥
            let retryCount = 0;
            const maxRetries = 50; // æœ€å¤šç­‰å¾…5ç§’
            const checkPDFLib = setInterval(() => {
                retryCount++;
                if (typeof PDFLib !== 'undefined') {
                    clearInterval(checkPDFLib);
                    loadMarksFromPdf(); // é‡æ–°èª¿ç”¨
                } else if (retryCount >= maxRetries) {
                    clearInterval(checkPDFLib);
                    console.error('PDFLib è¼‰å…¥è¶…æ™‚ï¼Œç„¡æ³•è¼‰å…¥æ¨™è¨˜');
                    marks = {};
                }
            }, 100);
            return;
        }
        
        console.log('é–‹å§‹å¾PDFè¼‰å…¥æ¨™è¨˜ï¼ŒoriginalPdfBytesé•·åº¦:', originalPdfBytes.length);
        
        const { PDFDocument } = PDFLib;
        const pdfDocLib = await PDFDocument.load(originalPdfBytes);
        
        // å¾PDFçš„Keywordsæ¬„ä½è®€å–å¯†ç¢¼å“ˆå¸Œ
        // PDF-lib çš„ keywords æ˜¯é™£åˆ—æ ¼å¼
        let keywordsArray = pdfDocLib.getKeywords() || [];
        // ç¢ºä¿æ˜¯é™£åˆ—æ ¼å¼
        if (typeof keywordsArray === 'string') {
            keywordsArray = keywordsArray ? [keywordsArray] : [];
        } else if (!Array.isArray(keywordsArray)) {
            keywordsArray = [];
        }
        
        // åœ¨é™£åˆ—ä¸­æŸ¥æ‰¾å¯†ç¢¼æ¨™è¨˜
        const passwordKeyword = keywordsArray.find(k => k.includes('PDF_MARKS_PASSWORD:'));
        if (passwordKeyword) {
            const passwordMatch = passwordKeyword.match(/PDF_MARKS_PASSWORD:([a-f0-9]{64})/);
            if (passwordMatch) {
                pdfPasswordHash = passwordMatch[1];
                console.log('PDFæ¨™è¨˜å·²å—å¯†ç¢¼ä¿è­·');
            } else {
                pdfPasswordHash = null;
                currentSessionPassword = null;
            }
        } else {
            pdfPasswordHash = null;
            currentSessionPassword = null;
        }
        
        // å¾PDFçš„Subjectæ¬„ä½è®€å–æ¨™è¨˜æ•¸æ“š
        const subject = pdfDocLib.getSubject() || '';
        
        console.log('PDF Subject:', subject.substring(0, 50) + '...'); // åªé¡¯ç¤ºå‰50å€‹å­—ç¬¦
        
        if (subject.startsWith('PDF_MARKS_DATA:')) {
            // æå–æ¨™è¨˜æ•¸æ“š
            const encodedMarks = subject.substring('PDF_MARKS_DATA:'.length);
            try {
                const marksJson = decodeURIComponent(escape(atob(encodedMarks)));
                marks = JSON.parse(marksJson);
                
                // ç¢ºä¿æ¯å€‹æ¨™è¨˜éƒ½æœ‰ replacementText å’Œ locked å­—æ®µï¼ˆå‘å¾Œå…¼å®¹ï¼‰
                Object.keys(marks).forEach(pageNum => {
                    if (Array.isArray(marks[pageNum])) {
                        marks[pageNum].forEach(mark => {
                            if (!mark.hasOwnProperty('replacementText')) {
                                mark.replacementText = '';
                            }
                            if (!mark.hasOwnProperty('locked')) {
                                mark.locked = false;
                            }
                        });
                    }
                });
                
                console.log('å¾PDFæ–‡ä»¶è¼‰å…¥æ¨™è¨˜æ•¸æ“šæˆåŠŸï¼Œæ¨™è¨˜æ•¸é‡:', Object.keys(marks).length);
                
                // æ¨™è¨˜æ•¸æ“šå·²è¼‰å…¥ï¼Œä½†ä¸è‡ªå‹•é¡¯ç¤ºæ¨™è¨˜å’Œç·¨è¼¯æŒ‰éˆ•
                // åªæœ‰é€²å…¥ç·¨è¼¯æ¨¡å¼æ™‚æ‰é¡¯ç¤ºæ¨™è¨˜å’Œç·¨è¼¯åŠŸèƒ½
                console.log('æ¨™è¨˜æ•¸æ“šå·²è¼‰å…¥ï¼Œç­‰å¾…é€²å…¥ç·¨è¼¯æ¨¡å¼å¾Œé¡¯ç¤º');
                
                // å»¶é²æ¸²æŸ“æ¨™è¨˜ï¼ˆä½†æ¨™è¨˜æœƒéš±è—ï¼Œç›´åˆ°é€²å…¥ç·¨è¼¯æ¨¡å¼ï¼‰
                setTimeout(() => {
                    renderMarks();
                }, 500);
            } catch (parseError) {
                console.error('è§£æPDFä¸­çš„æ¨™è¨˜æ•¸æ“šå¤±æ•—:', parseError);
                console.error('ç·¨ç¢¼çš„æ¨™è¨˜æ•¸æ“š:', encodedMarks.substring(0, 100));
                // PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“šæˆ–è§£æå¤±æ•—ï¼Œæ¨™è¨˜ç‚ºç©º
                marks = {};
            }
        } else {
            // PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“šï¼Œæ¨™è¨˜ç‚ºç©º
            console.log('PDFä¸­æ²’æœ‰æ¨™è¨˜æ•¸æ“š');
            marks = {};
        }
    } catch (error) {
        console.error('å¾PDFè¼‰å…¥æ¨™è¨˜å¤±æ•—:', error);
        console.error('éŒ¯èª¤è©³æƒ…:', error.stack);
        // è¼‰å…¥å¤±æ•—ï¼Œæ¨™è¨˜ç‚ºç©º
        marks = {};
    }
}

// æ¸²æŸ“æ¨™è¨˜
function renderMarks() {
    if (!marks[currentPage] || marks[currentPage].length === 0) {
        // æ¸…é™¤æ¨™è¨˜å±¤å…§å®¹
        const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
        if (markLayer) {
            markLayer.innerHTML = '';
        }
        return;
    }
    
    const markLayer = document.querySelector(`.mark-layer[data-page-num="${currentPage}"]`);
    if (!markLayer) {
        console.warn('æ¨™è¨˜å±¤ä¸å­˜åœ¨ï¼Œé ç¢¼:', currentPage);
        return;
    }
    
    // æª¢æŸ¥æ˜¯å¦æœ‰æ¨™è¨˜æ­£åœ¨è¢«æ‹–æ‹½æˆ–èª¿æ•´å¤§å°
    // å¦‚æœæœ‰ï¼Œå‰‡è·³éé‡æ–°æ¸²æŸ“ï¼Œé¿å…ä¸­æ–·ç”¨æˆ¶æ“ä½œ
    const activeMarkBlocks = markLayer.querySelectorAll('.mark-block.dragging');
    if (activeMarkBlocks.length > 0) {
        console.log('æª¢æ¸¬åˆ°æ­£åœ¨æ“ä½œçš„æ¨™è¨˜ï¼Œè·³éé‡æ–°æ¸²æŸ“ä»¥é¿å…ä¸­æ–·æ“ä½œ');
        return;
    }
    
    // æ¸…é™¤èˆŠçš„æ¨™è¨˜
    markLayer.innerHTML = '';
    
    marks[currentPage].forEach(mark => {
        // é©—è­‰æ¨™è¨˜æ•¸æ“š
        if (!mark || typeof mark.x !== 'number' || typeof mark.y !== 'number' || 
            typeof mark.width !== 'number' || typeof mark.height !== 'number') {
            console.warn('ç„¡æ•ˆçš„æ¨™è¨˜æ•¸æ“š:', mark);
            return;
        }
        
        // ç¢ºä¿æ¨™è¨˜å°ºå¯¸åˆç†
        if (mark.width <= 0 || mark.height <= 0) {
            console.warn('æ¨™è¨˜å°ºå¯¸ç„¡æ•ˆ:', mark);
            return;
        }
        
        const markBlock = document.createElement('div');
        markBlock.className = 'mark-block';
        markBlock.dataset.markId = mark.id;
        markBlock.style.position = 'absolute';
        markBlock.style.left = `${mark.x}px`;
        markBlock.style.top = `${mark.y}px`;
        markBlock.style.width = `${mark.width}px`;
        markBlock.style.height = `${mark.height}px`;
        markBlock.style.display = 'block';
        markBlock.style.visibility = 'visible';
        
        const label = document.createElement('div');
        label.className = 'mark-label';
        label.textContent = `å€å¡Š ${mark.id + 1}`;
        markBlock.appendChild(label);
        
        // ç¢ºä¿ locked å±¬æ€§å­˜åœ¨ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
        if (mark.locked === undefined) {
            mark.locked = false;
        }
        
        // å¦‚æœé–å®šï¼Œæ·»åŠ  locked class
        if (mark.locked) {
            markBlock.classList.add('locked');
        }
        
        // å‰µå»ºå·¥å…·æ¬„å®¹å™¨
        const toolbar = document.createElement('div');
        toolbar.className = 'mark-toolbar';
        
        // å¦‚æœæ¨™è¨˜æ¡†å¯¬åº¦ä¸è¶³ï¼ˆå°æ–¼ 80pxï¼‰ï¼Œå·¥å…·æ¬„é¡¯ç¤ºåœ¨å¤–éƒ¨
        if (mark.width < 80) {
            toolbar.classList.add('small-box');
        }
        
        // æ·»åŠ é–é ­æŒ‰éˆ•
        const lockBtn = document.createElement('div');
        lockBtn.className = 'mark-lock';
        lockBtn.textContent = mark.locked ? 'ğŸ”’' : 'ğŸ”“';
        lockBtn.title = mark.locked ? 'è§£é–æ¨™è¨˜ï¼ˆè§£é–å¾Œå¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰' : 'é–å®šæ¨™è¨˜ï¼ˆé–å®šå¾Œä¸å¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
        if (mark.locked) {
            lockBtn.classList.add('locked');
        }
        
        // ä½¿ç”¨æ¨™è¨˜é˜²æ­¢é‡è¤‡è§¸ç™¼
        let isLockHandling = false;
        
        const handleLock = async (e) => {
            // é˜²æ­¢é‡è¤‡è§¸ç™¼
            if (isLockHandling) {
                return false;
            }
            
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            isLockHandling = true;
            
            // ç¢ºä¿ mark å°è±¡å­˜åœ¨
            const currentMarkData = marks[currentPage].find(m => m.id === mark.id);
            if (!currentMarkData) {
                console.error('æ‰¾ä¸åˆ°æ¨™è¨˜æ•¸æ“š:', mark.id);
                isLockHandling = false;
                return false;
            }
            
            // åˆ‡æ›é–å®šç‹€æ…‹
            currentMarkData.locked = !currentMarkData.locked;
            mark.locked = currentMarkData.locked; // åŒæ­¥æ›´æ–°é–‰åŒ…ä¸­çš„ mark
            
            console.log('åˆ‡æ›é–å®šç‹€æ…‹ï¼Œæ¨™è¨˜ID:', mark.id, 'æ–°ç‹€æ…‹:', currentMarkData.locked);
            
            // ç«‹å³æ›´æ–°æ¨™è¨˜æ¡†ç‹€æ…‹
            if (currentMarkData.locked) {
                markBlock.classList.add('locked');
                lockBtn.textContent = 'ğŸ”’';
                lockBtn.classList.add('locked');
                lockBtn.title = 'è§£é–æ¨™è¨˜ï¼ˆè§£é–å¾Œå¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
            } else {
                markBlock.classList.remove('locked');
                lockBtn.textContent = 'ğŸ”“';
                lockBtn.classList.remove('locked');
                lockBtn.title = 'é–å®šæ¨™è¨˜ï¼ˆé–å®šå¾Œä¸å¯ç§»å‹•ã€èª¿æ•´å’Œåˆªé™¤ï¼‰';
            }
            
            // ä¿å­˜åˆ° PDFï¼ˆç•°æ­¥åŸ·è¡Œï¼Œä¸é˜»å¡ UI æ›´æ–°ï¼‰
            saveMarksToPdf(false).catch(err => {
                console.error('ä¿å­˜é–å®šç‹€æ…‹å¤±æ•—:', err);
            }).finally(() => {
                // å»¶é²é‡ç½®æ¨™è¨˜ï¼Œç¢ºä¿æ‰€æœ‰äº‹ä»¶éƒ½è™•ç†å®Œ
                setTimeout(() => {
                    isLockHandling = false;
                }, 100);
            });
            
            return false;
        };
        
        // åªä½¿ç”¨ click äº‹ä»¶ï¼Œé¿å… mousedown å’Œ click é‡è¤‡è§¸ç™¼
        lockBtn.addEventListener('click', handleLock);
        toolbar.appendChild(lockBtn);
        
        // æ·»åŠ ç·¨è¼¯æŒ‰éˆ•
        const editBtn = document.createElement('div');
        editBtn.className = 'mark-edit';
        editBtn.textContent = 'âœ';
        editBtn.title = 'ç·¨è¼¯æ›¿æ›æ–‡å­—';
        
        const handleEdit = (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            editMarkReplacementText(mark.id, currentPage);
            return false;
        };
        
        editBtn.addEventListener('click', handleEdit);
        toolbar.appendChild(editBtn);
        
        // æ·»åŠ åˆªé™¤æŒ‰éˆ•
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'mark-delete';
        deleteBtn.textContent = 'Ã—';
        deleteBtn.title = 'åˆªé™¤æ­¤æ¨™è¨˜';
        
        // ä½¿ç”¨ click äº‹ä»¶
        deleteBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±åˆªé™¤
            if (mark.locked) {
                Swal.fire({
                    icon: 'warning',
                    title: 'ç„¡æ³•åˆªé™¤',
                    text: 'æ¨™è¨˜å·²é–å®šï¼Œè«‹å…ˆè§£é–å¾Œå†åˆªé™¤',
                    timer: 2000,
                    showConfirmButton: false,
                    customClass: {
                        popup: 'swal-high-z-index'
                    }
                });
                return false;
            }
            console.log('åˆªé™¤æŒ‰éˆ•è¢«é»æ“Šï¼Œæ¨™è¨˜ID:', mark.id);
            await deleteMarkBlock(mark.id, currentPage);
            return false;
        });
        
        toolbar.appendChild(deleteBtn);
        
        // å°‡å·¥å…·æ¬„æ·»åŠ åˆ°æ¨™è¨˜æ¡†
        markBlock.appendChild(toolbar);
        
        // åœ¨ç·¨è¼¯æ¨¡å¼ä¸‹æ·»åŠ èª¿æ•´å¤§å°çš„æ§åˆ¶é»å’Œæ‹–æ‹½åŠŸèƒ½
        if (isMarkingMode) {
            // æ·»åŠ èª¿æ•´å¤§å°çš„æ§åˆ¶é»ï¼ˆ8å€‹æ–¹å‘ï¼‰
            const resizeHandles = ['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'];
            resizeHandles.forEach(direction => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${direction}`;
                handle.dataset.direction = direction;
                markBlock.appendChild(handle);
            });
            
            // æ‹–æ‹½ç§»å‹•åŠŸèƒ½ï¼ˆä½¿ç”¨é–‰åŒ…ä¿å­˜æ¯å€‹æ¨™è¨˜çš„ç‹€æ…‹ï¼‰
            const markState = {
                isDragging: false,
                isResizing: false,
                resizeDirection: null,
                startX: 0,
                startY: 0,
                startLeft: 0,
                startTop: 0,
                startWidth: 0,
                startHeight: 0,
                hasMoved: false // è¿½è¹¤æ˜¯å¦çœŸçš„ç§»å‹•äº†
            };
            
            // å®šç¾©äº‹ä»¶è™•ç†å™¨ï¼ˆåœ¨æ‹–æ‹½/èª¿æ•´å¤§å°é–‹å§‹æ™‚æ‰ç¶å®šï¼‰
            let moveHandler2 = null;
            let endHandler2 = null;
            let escapeHandler2 = null;
            
            // ç¶å®šå…¨å±€äº‹ä»¶çš„è¼”åŠ©å‡½æ•¸
            const bindGlobalEvents2 = () => {
                if (!moveHandler2) {
                    moveHandler2 = (e) => handleMove(e);
                    endHandler2 = (e) => handleEnd(e);
                    escapeHandler2 = (e) => {
                        if (e.key === 'Escape' && (markState.isDragging || markState.isResizing)) {
                            // æ¢å¾©åˆ°åŸå§‹ä½ç½®
                            if (markState.isDragging) {
                                markBlock.style.left = `${markState.startLeft}px`;
                                markBlock.style.top = `${markState.startTop}px`;
                            } else if (markState.isResizing) {
                                markBlock.style.left = `${markState.startLeft}px`;
                                markBlock.style.top = `${markState.startTop}px`;
                                markBlock.style.width = `${markState.startWidth}px`;
                                markBlock.style.height = `${markState.startHeight}px`;
                            }
                            handleEnd(e);
                        }
                    };
                    
                    document.addEventListener('mousemove', moveHandler2);
                    document.addEventListener('touchmove', moveHandler2);
                    document.addEventListener('mouseup', endHandler2);
                    document.addEventListener('touchend', endHandler2);
                    document.addEventListener('keydown', escapeHandler2);
                }
            };
            
            // è™•ç†èª¿æ•´å¤§å°
            const handleResizeStart = (e, direction) => {
                // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±èª¿æ•´å¤§å°
                if (mark.locked) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                markState.isResizing = true;
                markState.isDragging = false;
                markState.resizeDirection = direction;
                const rect = markBlock.getBoundingClientRect();
                const markLayerRect = markLayer.getBoundingClientRect();
                markState.startX = (e.touches ? e.touches[0].clientX : e.clientX);
                markState.startY = (e.touches ? e.touches[0].clientY : e.clientY);
                markState.startLeft = rect.left - markLayerRect.left;
                markState.startTop = rect.top - markLayerRect.top;
                markState.startWidth = rect.width;
                markState.startHeight = rect.height;
                markBlock.classList.add('dragging');
                
                // ç¶å®šå…¨å±€äº‹ä»¶
                bindGlobalEvents2();
            };
            
            // è™•ç†æ‹–æ‹½é–‹å§‹
            const handleDragStart = (e) => {
                // å¦‚æœæ¨™è¨˜å·²é–å®šï¼Œä¸å…è¨±æ‹–æ‹½
                if (mark.locked) {
                    return;
                }
                // å¦‚æœé»æ“Šçš„æ˜¯æ§åˆ¶é»ã€åˆªé™¤æŒ‰éˆ•ã€ç·¨è¼¯æŒ‰éˆ•æˆ–é–é ­æŒ‰éˆ•ï¼Œä¸é–‹å§‹æ‹–æ‹½
                if (e.target.classList.contains('resize-handle') ||
                    e.target.classList.contains('mark-delete') ||
                    e.target.classList.contains('mark-edit') ||
                    e.target.classList.contains('mark-lock') ||
                    e.target.closest('.mark-delete') ||
                    e.target.closest('.mark-edit') ||
                    e.target.closest('.mark-lock')) {
                    return;
                }
                e.preventDefault();
                e.stopPropagation();
                markState.isDragging = true;
                markState.isResizing = false;
                markState.hasMoved = false; // é‡ç½®ç§»å‹•æ¨™è¨˜
                const rect = markBlock.getBoundingClientRect();
                const markLayerRect = markLayer.getBoundingClientRect();
                markState.startX = (e.touches ? e.touches[0].clientX : e.clientX);
                markState.startY = (e.touches ? e.touches[0].clientY : e.clientY);
                markState.startLeft = rect.left - markLayerRect.left;
                markState.startTop = rect.top - markLayerRect.top;
                markBlock.classList.add('dragging');
                
                // ç¶å®šå…¨å±€äº‹ä»¶
                bindGlobalEvents2();
            };
            
            // è™•ç†ç§»å‹•/èª¿æ•´å¤§å°
            const handleMove = (e) => {
                if (!markState.isDragging && !markState.isResizing) return;
                e.preventDefault();
                e.stopPropagation();
                
                const currentX = (e.touches ? e.touches[0].clientX : e.clientX);
                const currentY = (e.touches ? e.touches[0].clientY : e.clientY);
                const deltaX = currentX - markState.startX;
                const deltaY = currentY - markState.startY;
                
                // å¦‚æœç§»å‹•è·é›¢è¶…éé–¾å€¼ï¼ˆ5pxï¼‰ï¼Œæ¨™è¨˜ç‚ºçœŸçš„ç§»å‹•äº†
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    markState.hasMoved = true;
                }
                
                if (markState.isResizing && markState.resizeDirection) {
                    // èª¿æ•´å¤§å°
                    let newLeft = markState.startLeft;
                    let newTop = markState.startTop;
                    let newWidth = markState.startWidth;
                    let newHeight = markState.startHeight;
                    
                    if (markState.resizeDirection.includes('n')) {
                        newHeight = Math.max(10, markState.startHeight - deltaY);
                        newTop = markState.startTop + (markState.startHeight - newHeight);
                    }
                    if (markState.resizeDirection.includes('s')) {
                        newHeight = Math.max(10, markState.startHeight + deltaY);
                    }
                    if (markState.resizeDirection.includes('w')) {
                        newWidth = Math.max(10, markState.startWidth - deltaX);
                        newLeft = markState.startLeft + (markState.startWidth - newWidth);
                    }
                    if (markState.resizeDirection.includes('e')) {
                        newWidth = Math.max(10, markState.startWidth + deltaX);
                    }
                    
                    markBlock.style.left = `${newLeft}px`;
                    markBlock.style.top = `${newTop}px`;
                    markBlock.style.width = `${newWidth}px`;
                    markBlock.style.height = `${newHeight}px`;
                } else if (markState.isDragging) {
                    // ç§»å‹•ä½ç½®
                    const markLayerRect = markLayer.getBoundingClientRect();
                    const newLeft = markState.startLeft + deltaX;
                    const newTop = markState.startTop + deltaY;
                    
                    // é™åˆ¶åœ¨æ¨™è¨˜å±¤ç¯„åœå…§
                    const maxLeft = markLayerRect.width - parseFloat(markBlock.style.width);
                    const maxTop = markLayerRect.height - parseFloat(markBlock.style.height);
                    
                    markBlock.style.left = `${Math.max(0, Math.min(newLeft, maxLeft))}px`;
                    markBlock.style.top = `${Math.max(0, Math.min(newTop, maxTop))}px`;
                }
            };
            
            
            // è™•ç†çµæŸ
            const handleEnd = async (e) => {
                // ç§»é™¤äº‹ä»¶ç›£è½å™¨ï¼ˆé‡è¦ï¼šé˜²æ­¢äº‹ä»¶ç›£è½å™¨æ®˜ç•™ï¼‰
                if (moveHandler2) {
                    document.removeEventListener('mousemove', moveHandler2);
                    document.removeEventListener('touchmove', moveHandler2);
                }
                if (endHandler2) {
                    document.removeEventListener('mouseup', endHandler2);
                    document.removeEventListener('touchend', endHandler2);
                }
                if (escapeHandler2) {
                    document.removeEventListener('keydown', escapeHandler2);
                }
                
                // æª¢æŸ¥æ˜¯å¦çœŸçš„ç§»å‹•äº†ï¼ˆé€šéæ¯”è¼ƒæœ€çµ‚ä½ç½®å’Œèµ·å§‹ä½ç½®ï¼‰
                const finalLeft = parseFloat(markBlock.style.left);
                const finalTop = parseFloat(markBlock.style.top);
                const finalWidth = parseFloat(markBlock.style.width);
                const finalHeight = parseFloat(markBlock.style.height);
                const positionChanged = Math.abs(finalLeft - markState.startLeft) > 1 || 
                                       Math.abs(finalTop - markState.startTop) > 1;
                const sizeChanged = Math.abs(finalWidth - markState.startWidth) > 1 || 
                                   Math.abs(finalHeight - markState.startHeight) > 1;
                
                // è¨˜éŒ„æ˜¯å¦éœ€è¦è§¸ç™¼èªéŸ³ï¼ˆåªæœ‰åœ¨æ‹–æ‹½ä¸”æ²’æœ‰ç§»å‹•æ™‚ï¼‰
                let shouldRead = false;
                
                if (markState.isDragging || markState.isResizing) {
                    // å¦‚æœç§»å‹•äº†ä½ç½®æˆ–èª¿æ•´äº†å¤§å°ï¼Œæ›´æ–°æ¨™è¨˜æ•¸æ“š
                    if (positionChanged || sizeChanged || markState.hasMoved) {
                        const updatedMark = marks[currentPage].find(m => m.id === mark.id);
                        if (updatedMark) {
                            updatedMark.x = finalLeft;
                            updatedMark.y = finalTop;
                            updatedMark.width = finalWidth;
                            updatedMark.height = finalHeight;
                            
                            // å¦‚æœèª¿æ•´äº†å¤§å°ï¼Œé‡æ–°æå–æ–‡å­—
                            if (markState.isResizing && sizeChanged) {
                                updatedMark.text = extractTextFromMark(updatedMark, currentPage);
                                console.log('æ¨™è¨˜å¤§å°å·²èª¿æ•´ï¼Œé‡æ–°æå–æ–‡å­—:', updatedMark.text);
                            }
                            
                            // éœé»˜ä¿å­˜ï¼ˆä¸é¡¯ç¤ºå½ˆçª—ï¼‰
                            // ç­‰å¾…ä¿å­˜å®Œæˆå¾Œå†ç§»é™¤ dragging classï¼Œç¢ºä¿ä¸æœƒè¢«é‡æ–°æ¸²æŸ“ä¸­æ–·
                            await saveMarksToPdf(false);
                        }
                    } else if (markState.isDragging && !markState.isResizing) {
                        // å¦‚æœåªæ˜¯æ‹–æ‹½ä½†æ²’æœ‰ç§»å‹•ï¼Œæ¨™è¨˜éœ€è¦è§¸ç™¼èªéŸ³
                        shouldRead = true;
                    }
                }
                
                markState.isDragging = false;
                markState.isResizing = false;
                markState.resizeDirection = null;
                markState.hasMoved = false; // é‡ç½®ç§»å‹•æ¨™è¨˜
                // åœ¨ä¿å­˜å®Œæˆå¾Œæ‰ç§»é™¤ dragging classï¼Œç¢ºä¿ä¿å­˜éç¨‹ä¸­ä¸æœƒè¢«é‡æ–°æ¸²æŸ“
                markBlock.classList.remove('dragging');
                
                // æ¸…ç†äº‹ä»¶è™•ç†å™¨å¼•ç”¨
                moveHandler2 = null;
                endHandler2 = null;
                escapeHandler2 = null;
                
                // å¦‚æœæ²’æœ‰ç§»å‹•ï¼Œè§¸ç™¼èªéŸ³æœ—è®€ï¼ˆåœ¨æ¸…ç†å®Œæˆå¾Œï¼‰
                // ä½†ä¸åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹è§¸ç™¼ï¼Œé¿å…éŒ¯èª¤
                if (shouldRead && !isMarkingMode) {
                    // è¨­ç½®æ¨™è¨˜ï¼Œé¿å… click äº‹ä»¶é‡è¤‡è§¸ç™¼
                    markBlock.dataset.justHandledDrag = 'true';
                    // ä½¿ç”¨ setTimeout ç¢ºä¿æ‰€æœ‰æ¸…ç†å·¥ä½œå®Œæˆå¾Œå†è§¸ç™¼èªéŸ³
                    setTimeout(() => {
                        readMarkBlock(mark.id, currentPage);
                        // æ¸…é™¤æ¨™è¨˜
                        setTimeout(() => {
                            delete markBlock.dataset.justHandledDrag;
                        }, 200);
                    }, 100);
                }
            };
            
            // ç¶å®šäº‹ä»¶ï¼ˆåªåœ¨æ¨™è¨˜å€å¡Šä¸Šç¶å®šï¼Œå…¨å±€äº‹ä»¶åœ¨æ‹–æ‹½/èª¿æ•´å¤§å°é–‹å§‹æ™‚æ‰ç¶å®šï¼‰
            markBlock.addEventListener('mousedown', handleDragStart);
            markBlock.addEventListener('touchstart', handleDragStart);
            
            // ç‚ºæ¯å€‹èª¿æ•´å¤§å°æ§åˆ¶é»ç¶å®šäº‹ä»¶
            resizeHandles.forEach(direction => {
                const handle = markBlock.querySelector(`.resize-handle.${direction}`);
                if (handle) {
                    handle.addEventListener('mousedown', (e) => handleResizeStart(e, direction));
                    handle.addEventListener('touchstart', (e) => handleResizeStart(e, direction));
                }
            });
        }
        
        // é»æ“Šå€å¡Šæ™‚æœ—è®€ï¼ˆæ’é™¤åˆªé™¤æŒ‰éˆ•å’Œç·¨è¼¯æŒ‰éˆ•ï¼‰
        // ç„¡è«–æ¨™è¨˜æ˜¯å¦å¯è¦‹ï¼Œéƒ½è¦ä¿ç•™é»æ“Šæœ—è®€åŠŸèƒ½
        // ä½†ä¸åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹è§¸ç™¼ï¼Œé¿å…éŒ¯èª¤
        markBlock.addEventListener('click', (e) => {
            // å¦‚æœé»æ“Šçš„æ˜¯åˆªé™¤æŒ‰éˆ•ã€ç·¨è¼¯æŒ‰éˆ•ã€é–é ­æŒ‰éˆ•ã€èª¿æ•´å¤§å°æ§åˆ¶é»æˆ–å…¶å­å…ƒç´ ï¼Œä¸è§¸ç™¼æœ—è®€
            if (e.target.classList.contains('mark-delete') || 
                e.target.closest('.mark-delete') ||
                e.target.classList.contains('mark-edit') || 
                e.target.closest('.mark-edit') ||
                e.target.classList.contains('mark-lock') ||
                e.target.closest('.mark-lock') ||
                e.target.classList.contains('resize-handle')) {
                e.stopPropagation();
                return;
            }
            // åœ¨æ¨™è¨˜æ¨¡å¼ä¸‹ä¸è§¸ç™¼èªéŸ³ï¼Œé¿å…éŒ¯èª¤
            if (isMarkingMode) {
                return;
            }
            // æª¢æŸ¥æ˜¯å¦å‰›å‰›é€²è¡Œäº†æ‹–æ‹½æˆ–èª¿æ•´å¤§å°ï¼ˆé¿å…èª¤è§¸ç™¼æœ—è®€ï¼‰
            const wasDragging = markBlock.classList.contains('dragging');
            // æª¢æŸ¥æ˜¯å¦å‰›å‰›è™•ç†éæ‹–æ‹½çµæŸï¼ˆé€šéæ•¸æ“šå±¬æ€§ï¼‰
            const justHandledDrag = markBlock.dataset.justHandledDrag === 'true';
            if (wasDragging || justHandledDrag) {
                // å¦‚æœå‰›å‰›æ‹–æ‹½éæˆ–å‰›å‰›è™•ç†éæ‹–æ‹½çµæŸï¼Œä¸è§¸ç™¼æœ—è®€
                if (justHandledDrag) {
                    delete markBlock.dataset.justHandledDrag; // æ¸…é™¤æ¨™è¨˜
                }
                return;
            }
            // é»æ“Šæ¨™è¨˜å€åŸŸè§¸ç™¼æœ—è®€ï¼ˆéæ¨™è¨˜æ¨¡å¼ä¸‹ï¼‰
            e.stopPropagation();
            readMarkBlock(mark.id, currentPage);
        });
        
        markLayer.appendChild(markBlock);
    });
    
    // æ›´æ–°æœ€å¤§IDè¨ˆæ•¸å™¨
    const allMarks = Object.values(marks).flat();
    if (allMarks.length > 0) {
        markIdCounter = Math.max(...allMarks.map(m => m.id)) + 1;
    }
    
    // æ ¹æ“šæ˜¯å¦åœ¨ç·¨è¼¯æ¨¡å¼ä¾†æ±ºå®šæ¨™è¨˜çš„å¯è¦‹æ€§
    if (isMarkingMode) {
        // ç·¨è¼¯æ¨¡å¼ï¼šé¡¯ç¤ºæ‰€æœ‰æ¨™è¨˜
        const markBlocks = markLayer.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            block.style.display = 'block';
            block.style.visibility = 'visible';
            block.style.opacity = '1';
            block.style.pointerEvents = 'auto';
            // æ¢å¾©é‚Šæ¡†å’ŒèƒŒæ™¯è‰²
            block.style.border = '3px solid #007BFF';
            block.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
            // é¡¯ç¤ºæ¨™ç±¤ã€ç·¨è¼¯æŒ‰éˆ•å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const editBtn = block.querySelector('.mark-edit');
            const deleteBtn = block.querySelector('.mark-delete');
            if (label) {
                label.style.display = 'block';
            }
            if (editBtn) {
                editBtn.style.display = 'flex';
            }
            if (deleteBtn) {
                deleteBtn.style.display = 'flex';
            }
            // é¡¯ç¤ºèª¿æ•´å¤§å°æ§åˆ¶é»
            const resizeHandles = block.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.style.display = 'block';
            });
        });
        markLayer.classList.remove('hidden');
    } else {
        // éç·¨è¼¯æ¨¡å¼ï¼šéš±è—æ¨™è¨˜è¦–è¦ºï¼Œä½†ä¿ç•™é»æ“ŠåŠŸèƒ½
        const markBlocks = markLayer.querySelectorAll('.mark-block');
        markBlocks.forEach(block => {
            block.style.display = 'block'; // ä¿ç•™å…ƒç´ ä»¥ä¾¿é»æ“Š
            block.style.visibility = 'visible';
            block.style.opacity = '0'; // è¦–è¦ºä¸Šä¸å¯è¦‹
            block.style.pointerEvents = 'auto'; // ä¿ç•™é»æ“ŠåŠŸèƒ½
            block.style.backgroundColor = 'transparent'; // ç¢ºä¿èƒŒæ™¯é€æ˜
            block.style.border = 'none'; // éš±è—é‚Šæ¡†
            // éš±è—æ¨™ç±¤å’Œåˆªé™¤æŒ‰éˆ•
            const label = block.querySelector('.mark-label');
            const deleteBtn = block.querySelector('.mark-delete');
            const editBtn = block.querySelector('.mark-edit');
            if (label) label.style.display = 'none';
            if (deleteBtn) deleteBtn.style.display = 'none';
            if (editBtn) editBtn.style.display = 'none';
            // éš±è—èª¿æ•´å¤§å°æ§åˆ¶é»
            const resizeHandles = block.querySelectorAll('.resize-handle');
            resizeHandles.forEach(handle => {
                handle.style.display = 'none';
            });
        });
        markLayer.classList.remove('hidden'); // æ¨™è¨˜å±¤éœ€è¦å­˜åœ¨ä»¥ä¾¿é»æ“Š
    }
}

// ä¿å­˜æ¨™è¨˜åˆ°PDFï¼ˆå°‡æ¨™è¨˜æ•¸æ“šä¿å­˜åˆ°PDFå…ƒæ•¸æ“šä¸­ï¼‰
async function saveMarksToPdf(showNotification = true) {
    if (!pdfDoc || !originalPdfBytes) {
        if (showNotification) {
            Swal.fire({
                icon: 'warning',
                title: 'ç„¡æ³•ä¿å­˜',
                text: 'è«‹å…ˆè¼‰å…¥PDFæª”æ¡ˆ'
            });
        }
        return;
    }
    
    // æª¢æŸ¥ PDFLib æ˜¯å¦å·²è¼‰å…¥
    if (typeof PDFLib === 'undefined') {
        if (showNotification) {
            Swal.fire({
                icon: 'error',
                title: 'åº«æœªè¼‰å…¥',
                text: 'PDF-lib åº«å°šæœªè¼‰å…¥ï¼Œè«‹åˆ·æ–°é é¢å¾Œé‡è©¦'
            });
        }
        return;
    }
    
    try {
        if (showNotification) {
            Swal.fire({
                title: 'æ­£åœ¨ä¿å­˜',
                text: 'æ­£åœ¨å°‡æ¨™è¨˜ä¿å­˜åˆ°PDF...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
        }
        
        const { PDFDocument } = PDFLib;
        const pdfDocLib = await PDFDocument.load(originalPdfBytes);
        
        // å°‡æ¨™è¨˜æ•¸æ“šè½‰æ›ç‚ºJSONå­—ç¬¦ä¸²
        const marksJson = JSON.stringify(marks);
        
        // å°‡æ¨™è¨˜æ•¸æ“šä¿å­˜åˆ°PDFçš„å…ƒæ•¸æ“šä¸­ï¼ˆä½¿ç”¨è‡ªå®šç¾©å±¬æ€§ï¼‰
        // ä½¿ç”¨ Subject æ¬„ä½ä¾†å­˜å„²æ¨™è¨˜æ•¸æ“šï¼ˆå› ç‚ºé€™æ˜¯æ¨™æº–å…ƒæ•¸æ“šæ¬„ä½ï¼Œä¸æœƒå½±éŸ¿PDFé¡¯ç¤ºï¼‰
        const existingSubject = pdfDocLib.getSubject() || '';
        
        // å‰µå»ºä¸€å€‹åŒ…å«æ¨™è¨˜æ•¸æ“šçš„å°è±¡ï¼Œä½¿ç”¨ç‰¹æ®Šæ¨™è¨˜ä¾†è­˜åˆ¥
        const marksMetadata = {
            pdfMarks: marksJson,
            version: '1.0'
        };
        
        // å°‡æ¨™è¨˜æ•¸æ“šç·¨ç¢¼å¾Œå­˜å„²åˆ°PDFçš„Subjectæ¬„ä½
        // ä½¿ç”¨base64ç·¨ç¢¼ä»¥é¿å…ç‰¹æ®Šå­—ç¬¦å•é¡Œ
        const encodedMarks = btoa(unescape(encodeURIComponent(marksJson)));
        pdfDocLib.setSubject(`PDF_MARKS_DATA:${encodedMarks}`);
        
        // ä½¿ç”¨å·²è¨­å®šçš„å¯†ç¢¼ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰ï¼Œä¿æŒç¾æœ‰çš„å¯†ç¢¼è¨­å®š
        // PDF-lib çš„ keywords å¿…é ˆæ˜¯é™£åˆ—
        let keywordsArray = pdfDocLib.getKeywords() || [];
        // ç¢ºä¿æ˜¯é™£åˆ—æ ¼å¼
        if (typeof keywordsArray === 'string') {
            keywordsArray = keywordsArray ? [keywordsArray] : [];
        } else if (!Array.isArray(keywordsArray)) {
            keywordsArray = [];
        }
        
        // ä¿æŒç¾æœ‰çš„å¯†ç¢¼è¨­å®šï¼ˆå¦‚æœå·²è¨­å®šï¼‰
        if (pdfPasswordHash) {
            // ç§»é™¤èˆŠçš„å¯†ç¢¼æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            keywordsArray = keywordsArray.filter(k => !k.includes('PDF_MARKS_PASSWORD:'));
            // æ·»åŠ ç•¶å‰çš„å¯†ç¢¼æ¨™è¨˜
            keywordsArray.push(`PDF_MARKS_PASSWORD:${pdfPasswordHash}`);
            pdfDocLib.setKeywords(keywordsArray);
        } else {
            // å¦‚æœæ²’æœ‰å¯†ç¢¼ä¿è­·ï¼Œæ¸…é™¤å¯†ç¢¼æ¨™è¨˜ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            keywordsArray = keywordsArray.filter(k => !k.includes('PDF_MARKS_PASSWORD:'));
            pdfDocLib.setKeywords(keywordsArray);
        }
        
        // ä¹Ÿå¯ä»¥ä½¿ç”¨è‡ªå®šç¾©å±¬æ€§ï¼ˆå¦‚æœPDF-libæ”¯æŒï¼‰
        // ä¿å­˜æ›´æ–°å¾Œçš„PDFå­—ç¯€
        const pdfBytes = await pdfDocLib.save();
        originalPdfBytes = pdfBytes;
        
        // æ›´æ–°IndexedDBä¸­çš„PDF
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        const fileName = fileParam || 'marked_document.pdf';
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        if (showNotification) {
            Swal.fire({
                icon: 'success',
                title: 'ä¿å­˜æˆåŠŸ',
                text: 'æ¨™è¨˜å·²ä¿å­˜åˆ°PDFæ–‡ä»¶ä¸­ï¼Œå¯ç¹¼çºŒç·¨è¼¯',
                timer: 1500,
                showConfirmButton: false
            });
        }
        
        // ä¿å­˜å¾Œä¸éš±è—æ¨™è¨˜ï¼Œä¿æŒå¯è¦‹ä»¥ä¾¿ç¹¼çºŒç·¨è¼¯
    } catch (error) {
        console.error('ä¿å­˜æ¨™è¨˜åˆ°PDFå¤±æ•—:', error);
        if (showNotification) {
            Swal.fire({
                icon: 'error',
                title: 'ä¿å­˜å¤±æ•—',
                text: 'ç„¡æ³•ä¿å­˜æ¨™è¨˜åˆ°PDF: ' + error.message
            });
        }
    }
}

// ä¸‹è¼‰åŒ…å«æ¨™è¨˜çš„PDF
async function downloadMarkedPdf() {
    if (!originalPdfBytes) {
        Swal.fire({
            icon: 'warning',
            title: 'ç„¡æ³•ä¸‹è¼‰',
            text: 'è«‹å…ˆä¿å­˜æ¨™è¨˜åˆ°PDF'
        });
        return;
    }
    
    try {
        // ç¢ºä¿æ¨™è¨˜æ•¸æ“šå·²ä¿å­˜åˆ°PDFæ–‡ä»¶
        await saveMarksToPdf();
        
        // ä¸‹è¼‰åŸå§‹PDFï¼ˆä¸åŒ…å«æ¨™è¨˜æ¡†ç·šï¼‰
        const blob = new Blob([originalPdfBytes], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        
        const urlParams = new URLSearchParams(window.location.search);
        const fileParam = urlParams.get('file');
        let fileName = fileParam || 'document.pdf';
        
        // åœ¨æª”åå¾ŒåŠ ä¸Šã€Œå·²æ¨™ç¤ºã€å¾Œç¶´ï¼ˆå¦‚æœé‚„æ²’æœ‰ï¼‰
        if (!fileName.includes('å·²æ¨™ç¤º')) {
            const lastDotIndex = fileName.lastIndexOf('.');
            if (lastDotIndex > 0) {
                // æœ‰å‰¯æª”åï¼Œåœ¨å‰¯æª”åå‰æ’å…¥ã€Œå·²æ¨™ç¤ºã€
                fileName = fileName.substring(0, lastDotIndex) + '_å·²æ¨™ç¤º' + fileName.substring(lastDotIndex);
            } else {
                // æ²’æœ‰å‰¯æª”åï¼Œç›´æ¥åŠ ä¸Šã€Œå·²æ¨™ç¤ºã€
                fileName = fileName + '_å·²æ¨™ç¤º';
            }
        }
        
        a.download = fileName;
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        Swal.fire({
            icon: 'success',
            title: 'åŒ¯å‡ºæˆåŠŸ',
            text: 'PDFå·²åŒ¯å‡ºåˆ°æœ¬åœ°ï¼ˆæ¨™è¨˜æ•¸æ“šå·²ä¿å­˜ï¼Œé‡æ–°è¼‰å…¥æ­¤PDFæ™‚æœƒè‡ªå‹•æ¢å¾©æ¨™è¨˜ï¼‰',
            timer: 2000,
            showConfirmButton: false
        });
    } catch (error) {
        console.error('åŒ¯å‡ºPDFå¤±æ•—:', error);
        Swal.fire({
            icon: 'error',
            title: 'åŒ¯å‡ºå¤±æ•—',
            text: 'ç„¡æ³•åŒ¯å‡ºPDF: ' + error.message
        });
    }
}

// æ¸…é™¤æ‰€æœ‰æ¨™è¨˜
async function clearAllMarks() {
    // ä¸éœ€è¦å†æ¬¡é©—è­‰å¯†ç¢¼ï¼Œå› ç‚ºé€²å…¥æ¨™è¨˜æ¨¡å¼æ™‚å·²ç¶“é©—è­‰éäº†
    Swal.fire({
        icon: 'warning',
        title: 'ç¢ºèªæ¸…é™¤',
        text: 'ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰æ¨™è¨˜å—ï¼Ÿ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®š',
        cancelButtonText: 'å–æ¶ˆ'
    }).then(async (result) => {
        if (result.isConfirmed) {
            marks = {};
            markIdCounter = 0;
            const markLayers = document.querySelectorAll('.mark-layer');
            markLayers.forEach(layer => {
                layer.innerHTML = '';
            });
            // æ¸…é™¤æ¨™è¨˜å¾Œï¼Œéœ€è¦ä¿å­˜åˆ°PDFä»¥æ›´æ–°PDFæ–‡ä»¶
            if (typeof PDFLib !== 'undefined' && originalPdfBytes) {
                saveMarksToPdf();
            }
            Swal.fire({
                icon: 'success',
                title: 'å·²æ¸…é™¤',
                text: 'æ‰€æœ‰æ¨™è¨˜å·²æ¸…é™¤',
                timer: 1500,
                showConfirmButton: false
            });
        }
    });
}

// åœ¨PDFè¼‰å…¥æ™‚ä¿å­˜åŸå§‹å­—ç¯€
async function saveOriginalPdfBytes(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        originalPdfBytes = new Uint8Array(arrayBuffer);
    } catch (error) {
        console.error('ä¿å­˜åŸå§‹PDFå­—ç¯€å¤±æ•—:', error);
    }
}

// æ·»åŠ æ¨™è¨˜äº‹ä»¶ç›£è½å™¨
document.addEventListener('DOMContentLoaded', () => {
    // ç­‰å¾… PDFLib è¼‰å…¥å®Œæˆ
    const checkPDFLib = setInterval(() => {
        if (typeof PDFLib !== 'undefined') {
            clearInterval(checkPDFLib);
            initMarkingFeature();
            
            // åœ¨æ¨™è¨˜å±¤ä¸Šæ·»åŠ æ¨™è¨˜äº‹ä»¶ï¼ˆå‹•æ…‹ç¶å®šï¼Œå› ç‚ºæ¨™è¨˜å±¤æ˜¯å‹•æ…‹å‰µå»ºçš„ï¼‰
            // æ¨™è¨˜äº‹ä»¶å·²åœ¨å‰µå»ºæ¨™è¨˜å±¤æ™‚ç¶å®š
        }
    }, 100);
    
    // 10ç§’å¾Œåœæ­¢æª¢æŸ¥
    setTimeout(() => {
        clearInterval(checkPDFLib);
        if (typeof PDFLib === 'undefined') {
            console.warn('PDFLib æœªè¼‰å…¥ï¼Œæ¨™è¨˜åŠŸèƒ½å¯èƒ½ç„¡æ³•ä½¿ç”¨');
            // å³ä½¿ PDFLib æœªè¼‰å…¥ï¼Œä¹Ÿåˆå§‹åŒ–åŸºæœ¬åŠŸèƒ½ï¼ˆæ¨™è¨˜å’Œæœ—è®€ä»å¯ä½¿ç”¨ï¼‰
            initMarkingFeature();
        }
    }, 10000);
});
        
</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@latest/dist/tesseract.min.js"></script>
</body>
</html>