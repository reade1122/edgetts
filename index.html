<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èªéŸ³å ±è®€ç³»çµ±</title>
    <style>
	    html {
    touch-action: manipulation;
}
	     body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }

select, input, button {
  font-size: 18px; /* Increase font size for better readability */
  padding: 15px; /* Increase padding for larger touch targets */
  margin-bottom: 20px;
  border-radius: 8px; /* Add rounded corners for a modern look */
  border: 2px solid #ccc; /* Add border for better visibility */
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Add subtle shadow for depth */
}

select {
  width: 20%; /* Increase width for better usability */
  z-index: 1900;
  position: fixed;
  right: 20px;
  top:5px;
}
#pdfContainer {
  margin-top: 80px; /* è¨­å®šé ‚éƒ¨é‚Šè·ç‚º 80px */
}
  #prevPage, #nextPage {
    padding: 15px 30px; /* å¢åŠ å…§é‚Šè·ä»¥æ“´å¤§è§¸æ§å€åŸŸ */
    font-size: 18px; /* å¢åŠ å­—é«”å¤§å°ä»¥æé«˜å¯è®€æ€§ */
    cursor: pointer;
    background-color: #007BFF; /* æ·»åŠ èƒŒæ™¯è‰²ä»¥æé«˜å¯è¦‹æ€§ */
    color: white; /* å°‡æ–‡å­—é¡è‰²æ”¹ç‚ºç™½è‰² */
    border: none; /* ç§»é™¤é»˜èªé‚Šæ¡† */
    transition: background-color 0.3s; /* æ·»åŠ éæ¸¡æ•ˆæœä»¥æé«˜äº’å‹•æ€§ */
  }

  #prevPage:hover, #nextPage:hover {
    background-color: #0056b3; /* æ‡¸åœæ™‚æ›´æ”¹èƒŒæ™¯è‰² */
  }
audio {
    width: 50%;
    bottom: 5px;
    z-index: 1000;
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
}
	.pdf-page-container {
            margin-bottom: 20px;
            position: relative;
            display: inline-block;
        }
        .pdf-viewer {
            position: relative;
            display: inline-block;
        }
        canvas {
            display: block;
        }
      .textLayer {
            position: absolute;
            text-align: initial;
            left: 0;
            top: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            opacity: 1;
            line-height: 1.0;
            -webkit-text-size-adjust: none;
            -webkit-transform-origin: 0% 0%;
            transform-origin: 0% 0%;
        }
        .textLayer > span {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            pointer-events: auto;
        }
        .textLayer > span.highlight {
            background-color: transparent !important;
        }
        .textLayer > span[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer > my-fra {
            background-color: transparent;
        }
        .textLayer > my-fra[style*="background-color: rgba(255, 255, 0, 0.2)"] {
            background-color: transparent !important;
        }
        .textLayer .highlight {
            margin: -1px;
            padding: 1px;
            background-color: rgba(180, 0, 170, 0.2);
            border-radius: 4px;
        }
        .textLayer .highlight.selected {
            background-color: rgba(0, 100, 0, 0.2);
        }
        .textLayer ::-moz-selection {
            background: rgba(0, 0, 255, 0.2);
        }
        .textLayer ::selection {
            background: rgba(0, 0, 255, 0.2);
        }
		  .no-select {
        user-select: none; /* ç¦ç”¨åç™½é¸å– */
        -webkit-user-select: none; /* ç¦ç”¨åç™½é¸å– for Safari */
        -moz-user-select: none; /* ç¦ç”¨åç™½é¸å– for Firefox */
        -ms-user-select: none; /* ç¦ç”¨åç™½é¸å– for Internet Explorer/Edge */
    }
    
    /* æ¨¡æ€çª—å£æ ·å¼ */
    .modal {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      z-index: 900;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 500px;
      background-color: white;
      border: 1px solid #ccc;
      border-radius: 5px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    /* é®ç½©å±‚æ ·å¼ */
    .modal-overlay {
      display: none;
      /* é»˜è®¤éšè— */
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.05);
      z-index: 900;
    }

    /* æŒ‰é’®æ ·å¼ */
    .button {
      padding: 10px 10px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .button-secondary {
      background-color: #6c757d;
    }

    .button-success {
      background-color: #28a745;
    }

    .button-light {
      background-color: #ded520;
    }

    .button-danger {
      background-color: #dc3545;
      
    }
     
   my-fra {
            display: inline; /* ç¢ºä¿ä¸å½±éŸ¿æ’ç‰ˆ */
        }
 input[type=range] {
    -webkit-appearance: none;
    width: 300px;
    height: 20px;
    background: linear-gradient(145deg, #d4d4d4, #f0f0f0);
    border: 1px solid #b0b0b0;
    border-radius: 10px;
    outline: none;
    opacity: 0.9;
    -webkit-transition: .2s;
    transition: opacity .2s;
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}

input[type=range]::-moz-range-thumb {
    width: 30px;
    height: 30px;
    background: linear-gradient(145deg, #4CAF50, #2E7D32);
    border: 1px solid #2E7D32;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
}
   #verticalDiv {
            position: fixed;
            top: 200px; /* è·é›¢é ‚éƒ¨50px */
            right: 15px; /* è·é›¢å³å´0px */
            z-index: 1000;
            display: flex;
            flex-direction: column; /* ä½¿å…§å®¹ç¸±å‘æ’åˆ— */
            align-items: center; /* å…§å®¹ç½®ä¸­ */	
			
        }

        #speakSpeed {
		
            z-index: 1000;
            transform: rotate(-90deg); /* æ—‹è½‰æ»‘è»Œ */
            transform-origin: right center; /* è¨­ç½®æ—‹è½‰ä¸­å¿ƒ */

        }
    
    /* SweetAlert2 é«˜ z-index æ¨£å¼ */
    .swal-high-z-index {
        z-index: 10030 !important;
    }

    /* SweetAlert2 å…¨åŸŸé«˜ z-indexï¼Œç¢ºä¿æ°¸é åœ¨æœ€ä¸Šå±¤ï¼ˆé«˜æ–¼ API KEY æ¨¡æ…‹è¦–çª—çš„ 10020ï¼‰ */
    .swal2-container,
    .swal2-popup,
    .swal2-modal,
    .swal2-backdrop,
    .swal2-shown,
    .swal2-height-auto,
    .swal2-icon,
    .swal2-title,
    .swal2-content,
    .swal2-actions,
    .swal2-styled,
    .swal2-close,
    .swal2-validation-message,
    .swal2-html-container,
    .swal2-loader,
    .swal2-progress-steps,
    .swal2-backdrop-show,
    .swal2-backdrop-hide,
    .swal2-noanimation,
    .swal2-toast {
      z-index: 10030 !important;
    }
    </style>
	  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11/dist/sweetalert2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
</head>
<body tabindex="0">
	 <div class="container">
<div>
    <!-- è²éŸ³é¸æ“‡ -->  
    <select id="voiceSelect">
	é¸æ“‡è²éŸ³ï¼š
      <option value="zh-TW-HsiaoChenNeural">ä¸­æ–‡ï¼šæ›‰è‡» (å¥³æ€§)</option>
      <option value="zh-TW-YunJheNeural">ä¸­æ–‡ï¼šå…å“² (ç”·æ€§)</option>
      <option value="zh-TW-HsiaoYuNeural">ä¸­æ–‡ï¼šæ›‰é›¨ (å¥³æ€§)</option>
      <option value="en-US-JennyNeural">è‹±æ–‡ï¼šJenny (å¥³æ€§)</option>
      <option value="en-US-GuyNeural">è‹±æ–‡ï¼šGuy (ç”·æ€§)</option>
      <option value="en-US-AriaNeural">è‹±æ–‡ï¼šAria (å¥³æ€§)</option>
      <option value="en-US-ChristopherNeural">è‹±æ–‡ï¼šChrist (ç”·æ€§)</option> 
    </select>
</div>
		  <!-- èªé€Ÿèª¿æ•´ -->
 <div id="verticalDiv">	     
      <label for="speakSpeed" style="writing-mode: vertical-lr; position: fixed; top: 120px; right: 5px; color: rgb(134, 101, 224); font-size: 20px; font-weight: bold; text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px; height: 200px; display: flex; align-items: center;">
    <span id="speedLabel">èªé€ŸåŠ </span>
    <span id="speedPercent" style="writing-mode: horizontal-tb; margin-left: 5px;">0%</span>
</label>
      <input type="range" id="speakSpeed" name="rate" min="-50" max="50" value="-30" oninput="updateRate(this.value)" style="  width:20%;  padding: 10px;  margin-bottom: 20px; z-index:1000;right:15px;position: fixed;">
    </div>
    
    <!-- éŸ³é »æ’­æ”¾å™¨ -->
    <audio id="audioPlayer" controls></audio>
  </div>
<div id="movable-frame"></div>
<input type="file" id="pdfFileInput" style=" width: 20%; /* Increase width for better usability */  z-index: 1900;  position: fixed;  left: 20px; top:5px;">
<div id="viewerContainer" tabindex="0">
    <center><div id="pdfContainer"></div></center>
</div>
	
<div class="pagination" style="width: 100%; top: 5px; z-index: 1000;  position: fixed;">
	<center>
    <button id="prevPage">ä¸Šä¸€é </button>
    <span id="pageNumber"></span>
    <button id="nextPage">ä¸‹ä¸€é </button>
	</center>	
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>    
  <button id="select-all-text" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;right: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" >æ•´é æœ—è®€</button>
  <!-- é¡µé¢é®ç½© -->
  <div id="modalOverlay" class="modal-overlay"></div>

   <button id="sendButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;right: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æœ—è®€é¸å–æ–‡å­—</button>
  <button id="clearButton" class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; bottom: 5px;left: 0%; z-index: 2000;color:black;font-size:20px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;display:none;">æ¸…é™¤é¸å–æ–‡å­—</button>
    <label style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; top: 300px;left: 2px; z-index: 1000;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;">
        <input type="checkbox" id="touchSelectCheckbox" style="writing-mode: vertical-rl; text-orientation: upright; width: 30px; height: 30px; position: fixed;left: 1px;top: 260px;">è§¸æ§é¸å–</label>
    <!-- æ–°å¢ï¼šæ‰‹å‹•æ¸…é™¤å¿«å–æŒ‰éˆ• -->
    <button id="clearCacheButton" class="button button-danger" style="writing-mode: vertical-rl; text-orientation: upright;position: fixed; left: 0px; top: 450px; z-index: 1100; font-size: 16px;">æ¸…é™¤å¿«å–</button> 

    <!-- API KEY è¨­å®šæŒ‰éˆ• -->
    <button id="apiKeySettingsButton" class="button button-secondary" style="position: fixed; top: 70px; left: 0px; z-index: 1; width: 40px; height: 40px; border-radius: 50%; padding: 0; font-size: 20px; display: flex; align-items: center; justify-content: center;" title="è¨­å®š Gemini API KEY">ğŸ”‘</button>

    <!-- API KEY è¨­å®šæ¨¡æ…‹è¦–çª— -->
    <div id="apiKeyModal" class="modal" style="display: none; z-index: 10020;">
        <div style="padding: 20px;">
            <h2 style="margin-top: 0;">è¨­å®šåœ–ç‰‡è¾¨è­˜ç”¨çš„ Gemini API KEY</h2>
            <div style="margin-bottom: 15px;">
                <label for="apiKeyInput" style="display: block; margin-bottom: 5px; font-weight: bold;">API KEYï¼š</label>
                <input type="password" id="apiKeyInput" placeholder="è«‹è¼¸å…¥æˆ–æƒæ QR Code" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 15px;">
                <button id="scanQRButton" class="button button-success" style="width: 100%; margin-bottom: 10px;">ğŸ“· æƒæ QR Code</button>
                <div id="qrScannerContainer" style="display: none; margin-bottom: 15px;">
                    <video id="qrVideo" style="width: 100%; max-width: 400px; border: 2px solid #ccc; border-radius: 5px; display: block; margin: 0 auto;"></video>
                    <canvas id="qrCanvas" style="display: none;"></canvas>
                    <button id="stopScanButton" class="button button-danger" style="width: 100%; margin-top: 10px;">åœæ­¢æƒæ</button>
                </div>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button id="saveApiKeyButton" class="button button-success" style="flex: 1;">å„²å­˜</button>
                <button id="deleteApiKeyButton" class="button button-danger" style="flex: 1;">åˆªé™¤ API KEY</button>
                <button id="cancelApiKeyButton" class="button button-secondary" style="flex: 1;">å–æ¶ˆ</button>
            </div>
        </div>
    </div>
    <div id="apiKeyModalOverlay" class="modal-overlay" style="z-index: 10019;"></div>

<button  class="button button-light" style="writing-mode: vertical-rl; text-orientation: upright;z-index: 2000;position: fixed; bottom: 5px;left: 0%; z-index: 1100;color:black;font-size:16px;font-weight:bold;color: rgb(134, 101, 224);font-size: 20px;text-shadow: rgb(204, 204, 204) 0px 1px 0px, rgb(201, 201, 201) 0px 2px 0px;" onclick="redirectToNewPage()">åˆ‡æ›è¼‰å…·èªéŸ³</button>
<script>
// ç§»é™¤ BroadcastChannel ç›¸é—œä»£ç¢¼ï¼Œæ›¿æ›ç‚ºä»¥ä¸‹å¯¦ç¾

// é æ•¸åŒæ­¥ç›¸é—œè®Šé‡
let pageSyncTimeout = null;
const PAGE_SYNC_DELAY = 300; // é˜²æŠ–å»¶é²(æ¯«ç§’)

// ä¿®æ”¹ notifyPageChange å‡½æ•¸
function notifyPageChange(page) {
    // æ›´æ–° URL hash
    updateUrlHash(page);
    
    // å¦‚æœæ˜¯ iframe å…§åµŒçš„æƒ…æ³ï¼Œé€šçŸ¥çˆ¶çª—å£
    if (window !== window.top) {
        window.parent.postMessage({
            type: 'pageChange',
            page: page,
            source: 'pdfViewer'
        }, '*'); // æ³¨æ„: å¯¦éš›æ‡‰ç”¨ä¸­æ‡‰æŒ‡å®šå…·é«”åŸŸåè€Œé '*'
    }
    
    // æ›´æ–° localStorage
    localStorage.setItem('currentPage', page);
}

//  æ›´æ–°URL hash (ä¸è§¸ç™¼é é¢åˆ·æ–°)
function updateUrlHash(page) {
    const newUrl = new URL(window.location.href);
    newUrl.hash = `page=${page}`;
    window.history.replaceState({}, '', newUrl);
}
// ç²å–ç•¶å‰é æ•¸ (å¾URL hashæˆ–localStorage)
function getPageFromHash() {
    const hash = window.location.hash.substring(1);
    const params = new URLSearchParams(hash);
    const pageFromHash = params.get('page') ? parseInt(params.get('page')) : null;
    
    // å¾ localStorage è®€å–ä½œç‚ºå‚™ç”¨
    const pageFromStorage = localStorage.getItem('currentPage') ? parseInt(localStorage.getItem('currentPage')) : 1;
    
    return pageFromHash || pageFromStorage;
}
// åˆ‡æ›ç¶²è·¯èªéŸ³æ™‚ä¿ç•™ç•¶å‰æª”æ¡ˆå’Œé æ•¸
function redirectToNewPage() {
    const urlParams = new URLSearchParams(window.location.search);
    const params = new URLSearchParams();
    
    // ä¿ç•™æ‰€æœ‰ç¾æœ‰åƒæ•¸
    if (urlParams.get('file')) params.set('file', urlParams.get('file'));
    if (urlParams.get('googlesheetid')) params.set('googlesheetid', urlParams.get('googlesheetid'));
    
    // æ§‹å»ºæ–°URL
    let newUrl = 'localvoice.html';
    if (params.toString()) newUrl += `?${params.toString()}`;
    
    // ä¿ç•™ç•¶å‰é æ•¸
    const currentPage = getPageFromHash();
    if (currentPage > 1) newUrl += `#page=${currentPage}`;
    
    window.location.href = newUrl;
}
// PDF.js åˆå§‹åŒ–
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

const pdfFileInput = document.getElementById('pdfFileInput');
const pdfContainer = document.getElementById('pdfContainer');
const prevPageButton = document.getElementById('prevPage');
const nextPageButton = document.getElementById('nextPage');
const pageNumberSpan = document.getElementById('pageNumber');

let pdfDoc = null;
let currentPage = 1;

// Function to render the page with dynamic width
function renderPage(pageNum) {
    if (!pdfDoc) return;

    pdfDoc.getPage(pageNum).then(page => {
        const screenWidth = window.innerWidth;
        const desiredWidth = screenWidth * 0.95; // Keep 95% width
        const viewport = page.getViewport({ scale: 1 });
        const scale = desiredWidth / viewport.width;
        const scaledViewport = page.getViewport({ scale: scale });

        pdfContainer.innerHTML = '';

        const pageContainer = document.createElement('div');
        pageContainer.className = 'pdf-page-container';
        pageContainer.style.position = 'relative';

        const pdfViewer = document.createElement('div');
        pdfViewer.className = 'pdf-viewer';
        pdfViewer.style.position = 'relative';

        const pdfCanvas = document.createElement('canvas');
        const context = pdfCanvas.getContext('2d');

        const dpi = window.devicePixelRatio || 1;
        pdfCanvas.height = scaledViewport.height * dpi;
        pdfCanvas.width = scaledViewport.width * dpi;
        context.scale(dpi, dpi);

        pdfCanvas.style.height = `${scaledViewport.height}px`;
        pdfCanvas.style.width = `${scaledViewport.width}px`;
        pdfCanvas.style.display = 'block';

        const textLayerDiv = document.createElement('div');
        textLayerDiv.className = 'textLayer';
        textLayerDiv.style.width = `${scaledViewport.width}px`;
        textLayerDiv.style.height = `${scaledViewport.height}px`;
        textLayerDiv.style.position = 'absolute';
        textLayerDiv.style.top = '0';
        textLayerDiv.style.left = '0';
        textLayerDiv.style.pointerEvents = 'none';

        pageContainer.appendChild(pdfViewer);
        pdfViewer.appendChild(pdfCanvas);
        pdfViewer.appendChild(textLayerDiv);
        pdfContainer.appendChild(pageContainer);

        const renderContext = {
            canvasContext: context,
            viewport: scaledViewport
        };

        page.render(renderContext).promise.then(() => {
            return page.getTextContent();
        }).then(textContent => {
            textLayerDiv.innerHTML = '';
            pdfjsLib.renderTextLayer({
                textContent: textContent,
                container: textLayerDiv,
                viewport: scaledViewport,
                textDivs: [],
                enhanceTextSelection: true
            });

            // ä¿®æ­£æ–‡å­—å±¤çš„ç¸®æ”¾å’Œä½ç½®
            const textElements = textLayerDiv.getElementsByTagName('span');
            for (let span of textElements) {
                const originalTransform = span.style.transform || '';
                span.style.transform = originalTransform.replace(/scale\([^)]+\)/, `scale(${1/dpi})`);
            }
        });

        pageNumberSpan.textContent = `Page ${pageNum} of ${pdfDoc.numPages}`;

        const currentHash = window.location.hash;
        const newHash = `page=${pageNum}`;
        if (currentHash !== newHash) {
            const newUrl = new URL(window.location.href);
            newUrl.hash = newHash;
            window.history.replaceState({}, '', newUrl);
        }
    });
}

// Event listener for orientation changes
window.addEventListener('orientationchange', () => {
    setTimeout(() => {
        renderPage(currentPage);
    }, 200); // Delay of 200 milliseconds
});

// Initial render
renderPage(currentPage);
	
// Google Apps Script ä»£ç† URL
const gasUrl = 'https://script.google.com/macros/s/AKfycbzOak3lHdg8lGSQSiLLk0kVK9IIC277xyVgU9hjykW0tRRcCE6si_-hMLfeLcwnvvNcHg/exec';


// æ‰“é–‹ IndexedDB è³‡æ–™åº«
const openDB = () => {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('pdfDB', 3); // å¢åŠ ç‰ˆæœ¬è™Ÿä»¥è§¸ç™¼å‡ç´š
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            // å¦‚æœ objectStore å·²å­˜åœ¨ï¼Œå…ˆåˆªé™¤å†é‡æ–°å‰µå»ºä»¥ç¢ºä¿é…ç½®æ­£ç¢º
            if (db.objectStoreNames.contains('pdfFiles')) {
                db.deleteObjectStore('pdfFiles');
            }
            // é‡æ–°å‰µå»º objectStoreï¼Œç¢ºä¿ä½¿ç”¨ keyPath: 'id'
            db.createObjectStore('pdfFiles', { keyPath: 'id' });
            
            // å‰µå»ºè¨­å®š objectStoreï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!db.objectStoreNames.contains('settings')) {
                db.createObjectStore('settings', { keyPath: 'id' });
            }
        };
        request.onsuccess = (e) => resolve(e.target.result);
        request.onerror = (e) => reject(e.target.error);
    });
};

// ä¿å­˜æª”æ¡ˆåˆ° IndexedDB
const saveFileToIndexedDB = async (file) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        
        // ç¢ºä¿å°è±¡æœ‰ id å±¬æ€§ï¼Œä¸¦ç­‰å¾… put æ“ä½œå®Œæˆ
        const dataToStore = { id: 'currentPdf', file: file };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                // put æ“ä½œæˆåŠŸï¼Œç­‰å¾… transaction å®Œæˆ
            };
            putRequest.onerror = () => reject(putRequest.error);
            
            // ç›£è½ transaction å®Œæˆ
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    } catch (error) {
        console.error('ä¿å­˜æª”æ¡ˆåˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å–æª”æ¡ˆ
const loadFileFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readonly');
        const store = transaction.objectStore('pdfFiles');
        const request = store.get('currentPdf');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.file);
                } else {
                    reject(new Error('IndexedDB ä¸­æœªæ‰¾åˆ°æª”æ¡ˆ'));
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ¸…ç©º IndexedDB ä¸­çš„æª”æ¡ˆ
const clearIndexedDB = async (forceClear = false) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('pdfFiles', 'readwrite');
        const store = transaction.objectStore('pdfFiles');
        if (forceClear) {
            store.delete('currentPdf');
        }
        updateUrl(null);
    } catch (error) {
        console.error('æ¸…é™¤ IndexedDB å¤±æ•—ï¼š', error);
    }
};

// ä¿å­˜ API KEY åˆ° IndexedDB
const saveApiKeyToIndexedDB = async (apiKey) => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const dataToStore = { id: 'geminiApiKey', value: apiKey };
        const putRequest = store.put(dataToStore);
        
        return new Promise((resolve, reject) => {
            putRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            putRequest.onerror = () => reject(putRequest.error);
        });
    } catch (error) {
        console.error('ä¿å­˜ API KEY åˆ° IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// å¾ IndexedDB è®€å– API KEY
const loadApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readonly');
        const store = transaction.objectStore('settings');
        const request = store.get('geminiApiKey');
        return new Promise((resolve, reject) => {
            request.onsuccess = (e) => {
                if (e.target.result) {
                    resolve(e.target.result.value);
                } else {
                    resolve(null);
                }
            };
            request.onerror = (e) => reject(e.target.error);
        });
    } catch (error) {
        console.error('å¾ IndexedDB è®€å– API KEY å¤±æ•—ï¼š', error);
        return null;
    }
};

// åˆªé™¤ API KEY å¾ IndexedDB
const deleteApiKeyFromIndexedDB = async () => {
    try {
        const db = await openDB();
        const transaction = db.transaction('settings', 'readwrite');
        const store = transaction.objectStore('settings');
        const deleteRequest = store.delete('geminiApiKey');
        
        return new Promise((resolve, reject) => {
            deleteRequest.onsuccess = () => {
                transaction.oncomplete = () => resolve();
                transaction.onerror = () => reject(transaction.error);
            };
            deleteRequest.onerror = () => reject(deleteRequest.error);
        });
    } catch (error) {
        console.error('åˆªé™¤ API KEY å¾ IndexedDB å¤±æ•—ï¼š', error);
        throw error;
    }
};

// æ›´æ–°ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

function updateUrl(fileName) {
    const newUrl = new URL(window.location.href);
    if (fileName) {
        newUrl.searchParams.set('file', fileName); // ä¸ä½¿ç”¨ encodeURIComponent
    } else {
        newUrl.searchParams.delete('file');
    }
    window.history.replaceState({}, '', newUrl);
}

// å¾ Google é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥ PDF æª”æ¡ˆï¼ˆä½¿ç”¨ GAS ä»£ç†ï¼‰
async function loadPdfFromDrive(fileId, showLoading = true) {
    // æª¢æŸ¥æ˜¯å¦æ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼ˆåŒ…å« .pdf çµå°¾ï¼‰
    if (fileId && fileId.toLowerCase().endsWith('.pdf')) {
        // å¦‚æœæ˜¯æœ¬åœ°æª”æ¡ˆåç¨±ï¼Œç›´æ¥è¿”å›ä¸è™•ç†
        return;
    }

    if (showLoading) {
        Swal.fire({
            title: 'è¼‰å…¥ä¸­è«‹ç¨å€™',
            text: 'æ­£åœ¨å¾é›²ç«¯ç¡¬ç¢Ÿè¼‰å…¥æª”æ¡ˆ...',
            allowOutsideClick: false,
            didOpen: () => {
                Swal.showLoading();
            }
        });
    }

    let fileName = `file_${fileId}.pdf`;
    
    // å‰µå»ºå¸¶è¶…æ™‚çš„ fetch å‡½æ•¸
    const fetchWithTimeout = (url, options = {}, timeout = 10000) => {
        return Promise.race([
            fetch(url, options),
            new Promise((_, reject) => 
                setTimeout(() => reject(new Error('è«‹æ±‚è¶…æ™‚')), timeout)
            )
        ]);
    };
    
    try {
        // ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰
        console.log('ä½¿ç”¨ GAS ä»£ç†ä¸‹è¼‰æª”æ¡ˆ...');
        const gasResponse = await fetchWithTimeout(
            `${gasUrl}?fileId=${fileId}`, 
            { method: 'GET' }, 
            10000
        );
        
        if (!gasResponse.ok) {
            throw new Error(`GAS ä»£ç†å›æ‡‰éŒ¯èª¤: ${gasResponse.status} ${gasResponse.statusText}`);
        }
        
        const data = await gasResponse.json();
        
        if (!data.fileContent || !data.fileName) {
            throw new Error('GAS ä»£ç†è¿”å›çš„è³‡æ–™æ ¼å¼éŒ¯èª¤');
        }
        
        // GAS è¿”å› base64 ç·¨ç¢¼çš„å…§å®¹
        const fileContent = atob(data.fileContent);
        const arrayBuffer = new ArrayBuffer(fileContent.length);
        const uint8Array = new Uint8Array(arrayBuffer);
        for (let i = 0; i < fileContent.length; i++) {
            uint8Array[i] = fileContent.charCodeAt(i);
        }
        fileName = data.fileName;
        
        console.log(`âœ“ ä¸‹è¼‰æˆåŠŸï¼Œä¾†æº: GAS ä»£ç†`);
        
        // å°‡ ArrayBuffer è½‰æ›ç‚º File ä¸¦ä¿å­˜
        const blob = new Blob([arrayBuffer], { type: 'application/pdf' });
        const file = new File([blob], fileName, { type: 'application/pdf' });
        await saveFileToIndexedDB(file);
        
        // è¼‰å…¥ PDF
        const typedarray = new Uint8Array(arrayBuffer);
        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
            pdfDoc = pdf;
            renderPage(currentPage);
            updateUrl(fileId);
            if (showLoading) {
                Swal.close();
            }
        }).catch(error => {
            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'è¼‰å…¥å¤±æ•—',
                text: 'ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚',
            });
        });
    } catch (error) {
        console.error('GAS ä»£ç†ä¸‹è¼‰å¤±æ•—ï¼š', error);
        if (showLoading) {
            Swal.fire({
                icon: 'error',
                title: 'ä¸‹è¼‰å¤±æ•—',
                text: 'ç„¡æ³•å¾ Google é›²ç«¯ç¡¬ç¢Ÿä¸‹è¼‰æª”æ¡ˆã€‚\n\n' +
                    'å¯èƒ½çš„åŸå› ï¼š\n' +
                    '1. æª”æ¡ˆæœªå…¬é–‹åˆ†äº«ï¼ˆè«‹ç¢ºèªæª”æ¡ˆåˆ†äº«è¨­å®šç‚ºã€ŒçŸ¥é“é€£çµçš„ä½¿ç”¨è€…ã€ï¼‰\n' +
                    '2. GAS ä»£ç†æœå‹™ç•°å¸¸\n' +
                    '3. ç¶²è·¯é€£ç·šå•é¡Œ\n\n' +
                    'å»ºè­°ï¼š\n' +
                    '- ç¢ºèªæª”æ¡ˆå·²å…¬é–‹åˆ†äº«\n' +
                    '- æª¢æŸ¥ç¶²è·¯é€£ç·š\n' +
                    '- ç¨å¾Œå†è©¦',
            });
        }
    }
}
// ç•¶é é¢è¼‰å…¥æ™‚ï¼Œæª¢æŸ¥ç¶²å€ä¸­çš„æª”æ¡ˆåç¨±

// ä¿®æ”¹é é¢åˆå§‹åŒ–éƒ¨åˆ†
window.addEventListener('load', async () => {
    // å¾ URL hash æˆ– localStorage è®€å–åˆå§‹é æ•¸
    currentPage = getPageFromHash();
    
    // åŸæœ‰çš„åˆå§‹åŒ–ä»£ç¢¼...
    const urlParams = new URLSearchParams(window.location.search);
    const fileParam = urlParams.get('file');
    const previousUrl = sessionStorage.getItem('previousUrl');
    const currentUrl = window.location.href;

    // åˆ¤æ–·æ˜¯å¦ç‚ºé é¢é‡æ–°æ•´ç†
    const isPageRefresh = previousUrl === currentUrl;

    // åˆ¤æ–· URL æ˜¯å¦ä»¥ .pdf çµå°¾ï¼ˆæœ¬åœ°æª”æ¡ˆï¼‰
    const isLocalPdfFile = fileParam && fileParam.toLowerCase().endsWith('.pdf');

    if (fileParam) {
        if (fileParam.startsWith('http://') || fileParam.startsWith('https://')) {
            // è™•ç†ç¶²è·¯ PDF æª”æ¡ˆ
            await clearIndexedDB();
            loadPdfFromUrl(fileParam);
        } else if (isLocalPdfFile) {
            // è™•ç†æœ¬åœ° PDF æª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file && file.name === fileParam) {
                    console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æœ¬åœ°æª”æ¡ˆç›¸åŒï¼Œå¾ IndexedDB è¼‰å…¥');
                    const fileReader = new FileReader();
                    fileReader.onload = function() {
                        const typedarray = new Uint8Array(this.result);
                        pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                            pdfDoc = pdf;
                            renderPage(currentPage);
                        }).catch(error => {
                            console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                            alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                        });
                    };
                    fileReader.onerror = function() {
                        console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                        alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                    };
                    fileReader.readAsArrayBuffer(file);
                } else {
                    console.log('IndexedDB ä¸­æ²’æœ‰åŒ¹é…çš„æœ¬åœ°æª”æ¡ˆï¼Œæ¸…é™¤ URL åƒæ•¸');
                    updateUrl(null);
                }
            } catch (error) {
                console.error('è®€å–æœ¬åœ°æª”æ¡ˆå¤±æ•—ï¼š', error);
                updateUrl(null);
            }
        } else {
            // è™•ç† Google é›²ç«¯ç¡¬ç¢Ÿæª”æ¡ˆ
            try {
                const file = await loadFileFromIndexedDB();
                if (file) {
                    if (file.name === fileParam) {
                        console.log('ç•¶å‰æª”æ¡ˆèˆ‡ URL ä¸­çš„æª”æ¡ˆç›¸åŒï¼Œè·³éé‡æ–°è¼‰å…¥ã€‚');
                        const fileReader = new FileReader();
                        fileReader.onload = function() {
                            const typedarray = new Uint8Array(this.result);
                            pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                                pdfDoc = pdf;
                                renderPage(currentPage);
                            }).catch(error => {
                                console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                                alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                            });
                        };
                        fileReader.onerror = function() {
                            console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                            alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
                        };
                        fileReader.readAsArrayBuffer(file);
                    } else {
                        await clearIndexedDB();
                        await saveFileToIndexedDB(file);
                        updateUrl(file.name);
                    }
                } else {
                    await loadPdfFromDrive(fileParam, !isPageRefresh);
                }
            } catch (error) {
                console.error('è®€å–æª”æ¡ˆå¤±æ•—ï¼š', error);
                await loadPdfFromDrive(fileParam, !isPageRefresh);
            }
        }
    }

    // æ›´æ–° sessionStorage ä¸­çš„ previousUrl
    sessionStorage.setItem('previousUrl', currentUrl);
});

//  ç›£è½é æ•¸è®ŠåŒ–äº‹ä»¶
window.addEventListener('hashchange', function() {
    const newPage = getPageFromHash();
    if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
        currentPage = newPage;
        renderPage(currentPage);
    }
});

// ç•¶ä½¿ç”¨è€…é¸æ“‡æª”æ¡ˆæ™‚
pdfFileInput.addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if (file) {
        try {
            await clearIndexedDB(true);
            await saveFileToIndexedDB(file);
            
            // æ›´æ–° URL åƒæ•¸ï¼Œæ¨™è¨˜ç‚ºæœ¬åœ°æª”æ¡ˆ
            const newUrl = new URL(window.location.href);
            newUrl.searchParams.set('file', file.name);
            window.history.replaceState({}, '', newUrl);
            
            const fileReader = new FileReader();
            fileReader.onload = function() {
                const typedarray = new Uint8Array(this.result);
                pdfjsLib.getDocument(typedarray).promise.then(pdf => {
                    pdfDoc = pdf;
                    currentPage = 1; // é‡ç½®ç‚ºç¬¬ä¸€é 
                    renderPage(currentPage);
                }).catch(error => {
                    console.error('PDF æª”æ¡ˆè¼‰å…¥å¤±æ•—ï¼š', error);
                    alert('ç„¡æ³•è¼‰å…¥ PDF æª”æ¡ˆï¼Œè«‹æª¢æŸ¥æª”æ¡ˆæ˜¯å¦æ­£ç¢ºæˆ–æœªé–‹æ”¾ç€è¦½ã€‚');
                });
            };
            fileReader.onerror = function() {
                console.error('æª”æ¡ˆè®€å–å¤±æ•—ï¼š', fileReader.error);
                alert('æª”æ¡ˆè®€å–å¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
            };
            fileReader.readAsArrayBuffer(file);
        } catch (error) {
            console.error('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼š', error);
            alert('ä¿å­˜æª”æ¡ˆå¤±æ•—ï¼Œè«‹é‡è©¦ã€‚');
        }
    } else {
        updateUrl(null);
    }
});

// ä¸Šä¸€é å’Œä¸‹ä¸€é æŒ‰éˆ•çš„äº‹ä»¶ç›£è½
// ä¿®æ”¹ä¸Šä¸€é /ä¸‹ä¸€é æŒ‰éˆ•äº‹ä»¶
prevPageButton.addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        renderPage(currentPage);
        notifyPageChange(currentPage);
    }
});

nextPageButton.addEventListener('click', () => {
    if (pdfDoc && currentPage < pdfDoc.numPages) {
        currentPage++;
        renderPage(currentPage);
        notifyPageChange(currentPage);
    }
});
// ç›£è½è·¨ç¶²åŸŸæ¶ˆæ¯
window.addEventListener('message', function(event) {
    if (event.data?.type === 'pageChange' && event.data.source !== 'pdfViewer') {
        const newPage = event.data.page;
        if (newPage !== currentPage && newPage >= 1 && newPage <= (pdfDoc?.numPages || 1)) {
            currentPage = newPage;
            renderPage(currentPage);
            updateUrlHash(currentPage);
        }
    }
});


// å¾ URL åƒæ•¸ä¸­è®€å– PDF æª”æ¡ˆçš„ ID
const urlParams = new URLSearchParams(window.location.search);
const fileId = urlParams.get('file');
if (fileId) {
    loadPdfFromDrive(fileId);
}
// æ–°å¢ï¼šæ‰‹å‹•æ¸…é™¤å¿«å–æŒ‰éˆ•åŠŸèƒ½
const clearCacheButton = document.getElementById('clearCacheButton');
if (clearCacheButton) {
    clearCacheButton.addEventListener('click', async () => {
        await clearIndexedDB(true);
        Swal.fire({
            icon: 'success',
            title: 'å·²æ¸…é™¤PDFå¿«å–',
            text: 'PDF å¿«å–å·²æ¸…é™¤ï¼Œè«‹é‡æ–°è¼‰å…¥æª”æ¡ˆã€‚',
            timer: 1500,
            showConfirmButton: false
        });
    });
}
</script>
 <script>
  
  // API é…ç½®
  const API_CONFIG = {
    BASE_URL: 'https://readatts-tts.hf.space', // Hugging Face Spaces TTS API
    TTS_ENDPOINT: '/tts',
    VOICES_ENDPOINT: '/voices'
  };
  
  // API å¥åº·æª¢æŸ¥
  async function checkAPIHealth() {
    try {
      const response = await fetch(`${API_CONFIG.BASE_URL}/health`);
      if (response.ok) {
        console.log('âœ… Edge TTS API æœå‹™æ­£å¸¸é‹è¡Œ');
        return true;
      } else {
        console.warn('âš ï¸ Edge TTS API æœå‹™å¯èƒ½æœªæ­£å¸¸é‹è¡Œ');
        return false;
      }
    } catch (error) {
      console.error('âŒ ç„¡æ³•é€£æ¥åˆ° Edge TTS API æœå‹™:', error);
      return false;
    }
  }
  
  let selectedFile = null;
  let isListening = true; // åˆå§‹è¨­ç½®ç‚ºç›£è½æ¨¡å¼
  let isReading = false; // åˆå§‹è¨­ç½®ç‚ºæœªé–±è®€ç‹€æ…‹
  let audioPlayer = null;
          document.addEventListener('DOMContentLoaded', async () => {
    audioPlayer = document.getElementById('audioPlayer');
    
    // æª¢æŸ¥ API å¥åº·ç‹€æ…‹
    const isAPIHealthy = await checkAPIHealth();
    if (!isAPIHealthy) {
        console.warn('Edge TTS API æœå‹™æœªé‹è¡Œï¼ŒèªéŸ³åŠŸèƒ½å¯èƒ½ç„¡æ³•ä½¿ç”¨');
    }
    
    const findInput = document.getElementById('findInput'); // ç²å–è¼¸å…¥æ¬„ä½
    const findEntireWord = document.getElementById('findEntireWord'); // ç²å– Whole Words å‹¾é¸æ¡†
    let isFinding = false; // ç”¨æ–¼è¿½è¹¤æ˜¯å¦æœ‰æœªå®Œæˆçš„æŸ¥æ‰¾æ“ä½œ

    // å‡½æ•¸: ç™¼é€é¸ä¸­çš„æ–‡æœ¬åˆ°æ–°çš„ TTS API é€²è¡Œè™•ç†

        function getSheetIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('googlesheetid');
        }

        function fetchSheetData(sheetId) {
    const base = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?`;
    const query = encodeURIComponent('Select B, C format B "", C ""'); // ä½¿ç”¨ format å¼·åˆ¶è½‰æ›ç‚ºç´”æ–‡å­—
    const url = `${base}&tq=${query}`;

    return fetch(url)
        .then(res => res.text())
        .then(rep => {
            const jsonStr = rep.match(/google\.visualization\.Query\.setResponse\(([\s\S]+)\);/)[1];
            const data = JSON.parse(jsonStr);
            console.log("ç¢ºèªæ¬„ä½å°æ‡‰:", data.table.rows[0]?.c); // æ‡‰ç‚º [Bæ¬„, Cæ¬„]
            return data;
        })
        .catch(err => {
            console.error('è¼‰å…¥å¤±æ•—:', err);
            return null;
        });
}

function replaceTextWithSheetData(text, data) {
    if (!data) return text;
    data.table.rows.forEach(row => {
        // ç¢ºä¿è³‡æ–™å­˜åœ¨ä¸”è½‰æ›ç‚ºå­—ä¸²
        const original = row.c[0]?.v?.toString() || ''; // Bæ¬„
        const replacement = row.c[1]?.v?.toString() || ''; // Cæ¬„
        if (original && replacement) {
            // ä½¿ç”¨å­—ä¸²æ›¿æ›ï¼Œç¢ºä¿éƒ½æ˜¯ç´”æ–‡å­—è™•ç†
            text = text.replace(new RegExp(original.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "g"), replacement);
        }
    });
    return text;
}
 async function sendTextToTTS(selectedText, callback) {
    // åŠ å¼·æ–‡å­—æ¸…ç†ï¼Œç§»é™¤å¯èƒ½å°è‡´ SSML è§£æéŒ¯èª¤çš„ç‰¹æ®Šå­—ç¬¦
    const cleanedText = selectedText
        .replace(/[\r\n]+/g, ' ')
        .replace(/\s+/g, ' ')
        .replace(/[<>&]/g, '') // ç§»é™¤ SSML ç‰¹æ®Šå­—ç¬¦
        .trim();
    
    let filteredText = cleanedText; // Initialize with cleanedText as fallback
    
    const sheetId = getSheetIdFromUrl();
    if (sheetId) {
        const data = await fetchSheetData(sheetId);
        filteredText = replaceTextWithSheetData(cleanedText, data);
    }
    
    console.log("é€å‡ºçµ¦ TTS çš„æ–‡æœ¬:", filteredText);
    console.log("æ–‡æœ¬é•·åº¦:", filteredText.length);
    
    // æª¢æŸ¥æ–‡æœ¬æ˜¯å¦ç‚ºç©º
    if (!filteredText || filteredText.length === 0) {
        console.error('TTS æ–‡æœ¬ç‚ºç©ºï¼Œç„¡æ³•æœ—è®€');
        if (callback) callback();
        return;
    }
    
    // ç²å–é¸æ“‡çš„è²éŸ³å’Œèªé€Ÿ
    const voiceName = document.getElementById("voiceSelect").value;
    const rateValueRaw = parseFloat(document.getElementById('speakSpeed').value);
    const rateValue = Math.max(-50, Math.min(50, isNaN(rateValueRaw) ? 0 : rateValueRaw));
    const rateString = `${rateValue >= 0 ? '+' : ''}${rateValue}%`;

    // æ§‹å»º API è«‹æ±‚åƒæ•¸
    const requestData = {
        text: filteredText,
        voice: voiceName,
        rate: rateString,
        volume: "+0%",
        pitch: "+0Hz"
    };

    // ç™¼é€è«‹æ±‚åˆ° Edge TTS API
    fetch(`${API_CONFIG.BASE_URL}/tts`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
    })
    .then(response => {
        console.log('TTS API å›æ‡‰ç‹€æ…‹:', response.status);
        if (!response.ok) {
            throw new Error(`è«‹æ±‚å¤±æ•—ï¼š${response.status} ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('TTS API å›æ‡‰:', data);
        if (data.success) {
            // æˆåŠŸç”ŸæˆèªéŸ³ï¼Œç›´æ¥ä½¿ç”¨éŸ³é »URL
            const audioUrl = `${API_CONFIG.BASE_URL}${data.audio_url}`;
            console.log('éŸ³é »URL:', audioUrl);
            
            // è¨­ç½®éŸ³é »æ’­æ”¾å™¨
            const audioPlayer = document.getElementById('audioPlayer');
            
            // æ·»åŠ éŒ¯èª¤è™•ç†
            audioPlayer.onerror = (e) => {
                console.error('éŸ³é »è¼‰å…¥éŒ¯èª¤:', e);
                console.error('éŸ³é »å…ƒç´ éŒ¯èª¤:', audioPlayer.error);
                // è¼‰å…¥éŒ¯èª¤æ™‚èª¿ç”¨å›èª¿
                if (callback) callback();
            };
            
            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›£è½å™¨ï¼Œé˜²æ­¢é‡è¤‡æ’­æ”¾
            audioPlayer.oncanplay = null;
            audioPlayer.onended = null;
            audioPlayer.onerror = null;
            
            // è¨­ç½®è¼‰å…¥è¶…æ™‚
            let loadTimeout = setTimeout(() => {
                console.error('éŸ³é »è¼‰å…¥è¶…æ™‚');
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                if (callback) callback();
            }, 10000); // 10ç§’è¶…æ™‚
            
            // æ·»åŠ è¼‰å…¥äº‹ä»¶ï¼ˆåªè¨­ç½®ä¸€æ¬¡ï¼‰
            audioPlayer.onloadstart = () => console.log('é–‹å§‹è¼‰å…¥éŸ³é »...');
            audioPlayer.oncanplay = () => {
                // æ¸…é™¤è¶…æ™‚
                if (loadTimeout) {
                    clearTimeout(loadTimeout);
                    loadTimeout = null;
                }
                
                console.log('éŸ³é »å¯ä»¥æ’­æ”¾');
                // éŸ³é »æº–å‚™å¥½å¾Œè‡ªå‹•æ’­æ”¾
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('éŸ³é »æ’­æ”¾æˆåŠŸ');
                            // æ’­æ”¾æˆåŠŸå¾Œè¨­ç½®å®Œæˆå›èª¿
                            audioPlayer.onended = callback;
                        })
                        .catch(error => {
                            console.error('éŸ³é »æ’­æ”¾å¤±æ•—:', error);
                            // æ’­æ”¾å¤±æ•—æ™‚ä¹Ÿè¦èª¿ç”¨å›èª¿
                            if (callback) callback();
                        });
                } else {
                    // å¦‚æœæ²’æœ‰æ’­æ”¾Promiseï¼Œç›´æ¥è¨­ç½®å›èª¿
                    audioPlayer.onended = callback;
                }
            };
            
            // æ·»åŠ æ›´å¤šäº‹ä»¶ç›£è½å™¨
            audioPlayer.onloadeddata = () => console.log('éŸ³é »æ•¸æ“šå·²è¼‰å…¥');
            audioPlayer.onprogress = () => console.log('éŸ³é »è¼‰å…¥é€²åº¦ä¸­...');
            audioPlayer.onabort = () => console.log('éŸ³é »è¼‰å…¥è¢«ä¸­æ­¢');
            audioPlayer.onstalled = () => console.log('éŸ³é »è¼‰å…¥åœæ»¯');
            audioPlayer.onsuspend = () => console.log('éŸ³é »è¼‰å…¥æš«åœ');
            
            // è¨­ç½®éŸ³é »æº
            audioPlayer.src = audioUrl;
        } else {
            throw new Error(data.error || 'èªéŸ³ç”Ÿæˆå¤±æ•—');
        }
    })
    .catch(error => {
        console.error('TTS ç™¼ç”ŸéŒ¯èª¤ï¼š', error);
        // ä¸è¦å½ˆå‡ºè­¦å‘Šï¼Œéœé»˜è™•ç†éŒ¯èª¤
        console.warn('TTS éŒ¯èª¤å·²è™•ç†ï¼Œç¹¼çºŒåŸ·è¡Œ');
        if (callback) callback();
    });
}

        // createSSML å‡½æ•¸å·²ç§»é™¤ï¼Œç¾åœ¨ç›´æ¥ä½¿ç”¨ JSON æ ¼å¼ç™¼é€è«‹æ±‚

        const selectAllTextButton = document.getElementById('select-all-text');
        let sentences = [];
        let currentSentenceIndex = 0;
        let isReading = false;

        selectAllTextButton.addEventListener('click', function() {
            clearHighlights();
            if (isReading) {
                // å–æ¶ˆæœ—è®€
                cancelReading();
            } else {
                // é–‹å§‹æœ—è®€
                const pdfContainer = document.getElementById('pdfContainer');
                const textLayers = pdfContainer.getElementsByClassName('textLayer');
                let fullText = '';

                for (let textLayer of textLayers) {
                    const spans = textLayer.getElementsByTagName('span');
                    for (let span of spans) {
                        fullText += span.textContent + ' ';
                    }
                }

                const cleanedText = fullText.replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
                sentences = cleanedText.split(/(?<=[ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šæ¨™é»ç¬¦è™Ÿåˆ†å¥
                currentSentenceIndex = 0;
                isReading = true;

                // ç«‹å³æ›´æ–°æŒ‰éˆ•æ¨£å¼å’Œæ–‡æœ¬
                selectAllTextButton.textContent = "å–æ¶ˆæœ—è®€";
                selectAllTextButton.classList.remove('button-light');
                selectAllTextButton.classList.add('button-danger');

                startReading(); // ç›´æ¥é–‹å§‹æœ—è®€
            }
        });

function cancelReading() {
  isReading = false;
  audioPlayer.pause();
  audioPlayer.currentTime = 0;
  selectAllTextButton.textContent = "æ•´é æœ—è®€";
  selectAllTextButton.classList.remove('button-danger');
  selectAllTextButton.classList.add('button-light');
  
  // æ¸…é™¤æ‰€æœ‰æ¨™ç¤º
  const textLayerDivs = document.querySelectorAll('#viewerContainer .textLayer my-fra');
  textLayerDivs.forEach(span => {
    span.style.backgroundColor = ''; // æ¸…é™¤æ¨™ç¤º
  });

  // æ¸…é™¤äº‹ä»¶ç›£è½å™¨
  audioPlayer.onended = null;
}

function startReading() {
    if (sentences.length > 0) {
        readNextSentence();
    } else {
        console.error('æ²’æœ‰å¯æœ—è®€çš„å¥å­');
    }
}

function readNextSentence() {
    if (isReading && currentSentenceIndex < sentences.length) {
        const sentence = sentences[currentSentenceIndex];
        highlightCurrentSentence(sentence);
        sendTextToTTS(sentence, function() {
            currentSentenceIndex++;
            if (currentSentenceIndex < sentences.length) {
                readNextSentence();
            } else {
                isReading = false;
                clearHighlights();
                selectAllTextButton.textContent = "æ•´é æœ—è®€";
                selectAllTextButton.classList.remove('button-danger');
                selectAllTextButton.classList.add('button-light');
            }
        });
    }
}

function highlightCurrentSentence(sentence) {
    const pdfContainer = document.getElementById('pdfContainer');
    const textLayers = pdfContainer.getElementsByClassName('textLayer');
    let spansArray = []; // å­˜å„²æ‰€æœ‰ <my-fra> æ¨™ç±¤

    // å°‡æ‰€æœ‰ <my-fra> æ¨™ç±¤å­˜å„²åˆ°æ•¸çµ„ä¸­ï¼Œä¸¦æŒ‰é †åºæ’åˆ—
    for (let textLayer of textLayers) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            spansArray.push(span);
        }
    }

    // æ¸…é™¤å‰ä¸€å¥çš„æ¨™ç¤º
    for (let span of spansArray) {
        span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
    }

    // æŒ‰æ–·å¥ç¬¦è™Ÿåˆ†æ®µ
    const sentences = sentence.split(/([ã€‚ï¼ï¼Ÿ])/); // æ ¹æ“šå¥è™Ÿã€å•è™Ÿã€é©šå˜†è™Ÿåˆ†æ®µ
    const cleanedSentences = [];
    for (let i = 0; i < sentences.length; i += 2) {
        const sentenceText = sentences[i] + (sentences[i + 1] || ''); // å°‡æ–·å¥ç¬¦è™Ÿèˆ‡å¥å­åˆä½µ
        const cleanedSentence = sentenceText.replace(/\s+/g, ''); // å»é™¤ç©ºç™½å­—ç¬¦
        if (cleanedSentence) {
            cleanedSentences.push(cleanedSentence);
        }
    }

    // æŒ‰é †åºæ¨™ç¤ºæ¯å€‹å¥å­
    let currentIndex = 0; // ç•¶å‰éæ­·åˆ°çš„å­—ç¬¦ç´¢å¼•
    for (let s = 0; s < cleanedSentences.length; s++) {
        const cleanedSentence = cleanedSentences[s];
        let sentenceIndex = 0; // ç”¨æ–¼è¿½è¹¤ç•¶å‰å¥å­å­—ç¬¦ä½ç½®

        // å¾ç•¶å‰ç´¢å¼•é–‹å§‹ï¼Œå°‹æ‰¾åŒ¹é…çš„å­—ç¬¦
        while (currentIndex < spansArray.length && sentenceIndex < cleanedSentence.length) {
            const span = spansArray[currentIndex];
            const char = span.textContent.trim(); // å»é™¤å­—ç¬¦å‰å¾Œç©ºç™½

            // å¦‚æœå­—ç¬¦æ˜¯ç©ºç™½å­—ç¬¦ï¼Œå‰‡è·³é
            if (char === '') {
                currentIndex++;
                continue;
            }

            // å¦‚æœå­—ç¬¦åŒ¹é…
            if (char === cleanedSentence[sentenceIndex]) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // é«˜äº®é¡¯ç¤º
                sentenceIndex++;
            } else {
                // å¦‚æœå­—ç¬¦ä¸åŒ¹é…ï¼Œå‰‡æ¸…é™¤ç•¶å‰å¥å­çš„é«˜äº®
                for (let i = currentIndex - sentenceIndex; i < currentIndex; i++) {
                    spansArray[i].style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                }
                sentenceIndex = 0; // é‡ç½®å¥å­ç´¢å¼•
            }

            currentIndex++; // ç§»å‹•åˆ°ä¸‹ä¸€å€‹å­—ç¬¦
        }

        // å¦‚æœå¥å­æ¨™ç¤ºå®Œæˆï¼Œå‰‡ç¹¼çºŒä¸‹ä¸€å€‹å¥å­
        if (sentenceIndex >= cleanedSentence.length) {
            console.log(`å¥å­ ${s + 1} æ¨™ç¤ºå®Œæˆ: ${cleanedSentence}`);
        } else {
            console.error(`å¥å­ ${s + 1} æ¨™ç¤ºå¤±æ•—: ${cleanedSentence}`);
        }
    }
}
// å¯ç§»å‹•æ¡†çš„åŠŸèƒ½
const frame = document.getElementById('movable-frame');
let isDragging = false;
let startX, startY;

// Add CSS styles for frame and resize buttons
const style = document.createElement('style');
style.innerHTML = `
  #movable-frame {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 6px solid red;
    background-color: transparent;
    border-radius: 15px; /* Adjust the value to change the roundness */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */   
    z-index: 2000;
}
 .resize-button {
    position: absolute;
    width: 0;
    height: 0;
    cursor: pointer;
    z-index: 2000;
  } 
  #resize-bottom {
    width: 80px;
    height: 50px;
    background-color: orange;
    border-radius: 0 0 50px 50px; /* Bottom half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */   
    z-index: 2000;
  }
  #resize-right {
    width: 50px;
    height: 80px;
    background-color: orange;
    border-radius: 0 50px 50px 0; /* Right half-circle */
    position: absolute;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    display: flex;
    justify-content: center;
    align-items: center;
    color: white; /* Text color */
    font-size: 36px; /* Text size */
    white-space: pre-wrap; /* Allow text to wrap */   
    z-index: 2000;
  }
  #read-button {
    position: absolute;
    padding: 5px 10px;
    background-color: orange;
    color: blue;
    border: none;
    cursor: pointer;
    z-index: 2000;
    width: 90px;
    height: 40px;
    font-size:15px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Adding shadow */
    border-top-left-radius: 15px; /* Top-left corner roundness */
    border-top-right-radius: 15px; /* Top-right corner roundness */
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Text shadow */    
  }
`;
document.head.appendChild(style);

// Add resize buttons
const buttons = [
  { direction: 'bottom' },
  { direction: 'right' }
];
buttons.forEach(({ direction }) => {
  const button = document.createElement('div');
  button.classList.add('resize-button');
  button.id = `resize-${direction}`;
  document.body.appendChild(button);
});

// Add read button
const readButton = document.createElement('button');
readButton.id = 'read-button';
readButton.textContent = 'æ¡†é¸æœ—è®€';
document.body.appendChild(readButton);

function initializeFramePosition() {
  const frame = document.getElementById('movable-frame');
  frame.style.top = `${frame.offsetTop + 90}px`; // å‘ä¸Šç§»å‹• 40px
  frame.style.left = `${frame.offsetLeft - 20}px`; // å‘ä¸Šç§»å‹• 40px
}

// æ›´æ–°æŒ‰éˆ•ä½ç½®
function updateButtonPositions() {
  const frame = document.getElementById('movable-frame');

  document.getElementById('resize-bottom').style.top = `${frame.offsetTop + frame.offsetHeight}px`;
  document.getElementById('resize-bottom').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 40}px`; // Adjusted for new width
  document.getElementById('resize-right').style.top = `${frame.offsetTop + frame.offsetHeight / 2 - 40}px`; // Adjusted for new height
  document.getElementById('resize-right').style.left = `${frame.offsetLeft + frame.offsetWidth}px`;
  document.getElementById('read-button').style.top = `${frame.offsetTop - 40}px`; // Position above the frame
  document.getElementById('read-button').style.left = `${frame.offsetLeft + frame.offsetWidth / 2 - 45}px`; // Centered above the frame

  // Add text to the buttons
  document.getElementById('resize-bottom').textContent = 'â†•';
  document.getElementById('resize-right').textContent = 'â†”';

  // Center the text within the buttons
  document.getElementById('resize-bottom').style.display = 'flex';
  document.getElementById('resize-bottom').style.alignItems = 'center';
  document.getElementById('resize-bottom').style.justifyContent = 'center';
  
  document.getElementById('resize-right').style.display = 'flex';
  document.getElementById('resize-right').style.alignItems = 'center';
  document.getElementById('resize-right').style.justifyContent = 'center';
}

// åˆå§‹åŒ–æ¡†çš„ä½ç½®
initializeFramePosition();

frame.addEventListener('mousedown', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  startX = e.clientX - frame.offsetLeft;
  startY = e.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('mousemove', (e) => {
  if (isDragging) {
    frame.style.left = `${e.clientX - startX}px`;
    frame.style.top = `${e.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('mouseup', () => {
  isDragging = false;
});

frame.addEventListener('touchstart', (e) => {
  if (e.target.classList.contains('resize-button') || e.target.id === 'read-button') return;
  isDragging = true;
  const touch = e.touches[0];
  startX = touch.clientX - frame.offsetLeft;
  startY = touch.clientY - frame.offsetTop;
  e.preventDefault(); // Prevent page scrolling
});

document.addEventListener('touchmove', (e) => {
  if (isDragging) {
    const touch = e.touches[0];
    frame.style.left = `${touch.clientX - startX}px`;
    frame.style.top = `${touch.clientY - startY}px`;
    updateButtonPositions();
  }
});

document.addEventListener('touchend', () => {
  isDragging = false;
});

// Read button click event
readButton.addEventListener('click', readTextInsideFrame);

updateButtonPositions();
 

// åˆ¤æ–· canvas æ˜¯å¦ç‚ºå…¨ç™½
function isCanvasAllWhite(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
    for (let i = 0; i < imageData.length; i += 4) {
        if (!(imageData[i] === 255 && imageData[i+1] === 255 && imageData[i+2] === 255 && imageData[i+3] === 255)) {
            return false;
        }
    }
    return true;
}

// è¼”åŠ©å‡½æ•¸ï¼šcanvas è½‰ base64ï¼Œä¾› Gemini åœ–ç‰‡è¾¨è­˜ç”¨
function canvasToBase64(canvas) {
    return canvas.toDataURL("image/png").split(',')[1];
}

// è¼”åŠ©å‡½æ•¸ï¼šGemini åœ–ç‰‡è¾¨è­˜
async function geminiImageDescribe(base64Image) {
    try {
        // å¾ IndexedDB è®€å– API KEYï¼Œå¦‚æœæ²’æœ‰å‰‡ä½¿ç”¨é è¨­å€¼
        let apiKey = await loadApiKeyFromIndexedDB();
        if (!apiKey) {
            apiKey = ''; // é è¨­ API KEY
        }
        
        console.log('é–‹å§‹èª¿ç”¨ Gemini APIï¼ŒAPI KEY é•·åº¦:', apiKey.length);
        
        const response = await fetch("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=" + apiKey, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [
                    {
                        role: "user",
                        parts: [
                            { text: "ä½ æ˜¯ä¸€å€‹çµ¦å­¸ç¿’éšœç¤™å­¸ç”Ÿå ±è®€è€ƒé¡Œçš„å ±è®€å“¡ï¼Œä¸è¦ç”¢ç”Ÿ markdown çš„ * ç¬¦è™Ÿï¼Œè«‹å…ˆè®€å‡ºåœ–ç‰‡ä¸­çš„æ‰€æœ‰æ–‡å­—ï¼Œé‡åˆ°ç§‘å­¸æˆ–æ•¸å­¸ç¬¦è™Ÿè«‹è½‰æˆä¸­æ–‡æ–‡å­—çš„è®€æ³•ï¼Œé‡åˆ°æ•¸å­¸åˆ†æ•¸æ™‚ä»¥ä¸­æ–‡è®€æ³•è¡¨ç¤ºï¼Œå¦‚:å¹¾åˆ†ä¹‹å¹¾ï¼Œæ•¸å­¸å¼å­ç„¡é ˆå†ç‰¹åˆ¥èªªæ˜å®ƒæ˜¯ä¸€å€‹å…¬å¼ï¼Œå¦‚æœé€™äº›æ–‡å­—èˆ‡åœ–ç‰‡å…§å®¹æœ‰é—œï¼Œè«‹åˆä½µæè¿°ã€‚ç„¶å¾Œç”¨ç°¡å–®å¥å­æè¿°åœ–ç‰‡ä¸­çš„ç‰©ä»¶ï¼Œä¸è¦è´…è¿°ï¼Œä¸è¦æè¿°å ´æ™¯ã€æ•´é«”ä½ˆå±€æˆ–é¢¨æ ¼ï¼Œå¦‚æœæ–‡å­—éƒ¨åˆ†å·²èƒ½å‘ˆç¾å…¨éƒ¨ï¼Œæè¿°å®Œä¸è¦å†é‡è¤‡é™³è¿°åœ–ç‰‡å…ƒç´ ï¼Œå¦‚:å¼Ÿå¼Ÿåƒäº†å…«åˆ†ä¹‹äº”ç›’é›å¡Šï¼Œåœ–ç‰‡ä¸­ï¼Œé¡¯ç¤ºäº†ä¸€è¡Œä¸­æ–‡å­—å’Œä¸€å€‹åˆ†æ•¸ï¼Œåœ–ç‰‡ä¸­......ä»¥å¾Œå°±æ˜¯è´…è¿°ã€‚é‡åˆ°è‹±æ–‡å­—è«‹å¦‚å¯¦å‘ˆç¾ï¼Œä¸è¦æŠŠXè®€æˆè‰¾å…‹æ–¯ã€‚" },
                            { inline_data: { mime_type: "image/png", data: base64Image } }
                        ]
                    }
                ]
            })
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            console.error('Gemini API å›æ‡‰éŒ¯èª¤:', response.status, errorText);
            throw new Error(`API è«‹æ±‚å¤±æ•— (${response.status}): ${errorText}`);
        }
        
        const data = await response.json();
        console.log('Gemini API å›æ‡‰:', data);
        
        if (data.error) {
            console.error('Gemini API éŒ¯èª¤:', data.error);
            throw new Error(data.error.message || 'API è¿”å›éŒ¯èª¤');
        }
        
        if (data.candidates && data.candidates.length > 0) {
            const text = data.candidates[0].content.parts[0].text;
            console.log('è¾¨è­˜çµæœ:', text);
            return text;
        } else {
            throw new Error('API å›æ‡‰ä¸­æ²’æœ‰è¾¨è­˜çµæœ');
        }
    } catch (error) {
        console.error('Gemini åœ–ç‰‡è¾¨è­˜éŒ¯èª¤:', error);
        throw error; // é‡æ–°æ‹‹å‡ºéŒ¯èª¤ï¼Œè®“èª¿ç”¨è€…è™•ç†
    }
}

async function readTextInsideFrame() {
    // å¦‚æœæ­£åœ¨é€²è¡Œåœ–ç‰‡è¾¨è­˜ï¼Œç›´æ¥è¿”å›ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
    if (isImageRecognizing) {
        console.log('åœ–ç‰‡è¾¨è­˜æ­£åœ¨é€²è¡Œä¸­ï¼Œå¿½ç•¥é‡è¤‡è«‹æ±‚');
        return;
    }
    
    window.speechSynthesis.cancel();
    const frameRect = frame.getBoundingClientRect();
    const viewerContainer = document.getElementById('viewerContainer');
    const pdfCanvas = viewerContainer.querySelector('canvas');

    // å…ˆæŠ“ PDF æ–‡å­—å±¤
    const textLayerDivs = viewerContainer.getElementsByClassName('textLayer');
    let textInsideFrame = '';
    for (let textLayer of textLayerDivs) {
        const spans = textLayer.getElementsByTagName('my-fra');
        for (let span of spans) {
            const spanRect = span.getBoundingClientRect();
            if (isInsideFrame(spanRect, frameRect)) {
                span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)';
                textInsideFrame += span.textContent + '';
            }
        }
    }
    const cleanedText = textInsideFrame.trim().replace(/[\r\n]+/g, ' ').replace(/\s{2,}/g, ' ').trim();
    // å–å¾—åœ–ç‰‡ base64
    let base64Image = null;
    let croppedCanvas = null;
    if (pdfCanvas) {
        croppedCanvas = cropCanvas(pdfCanvas, frameRect);
        base64Image = canvasToBase64(croppedCanvas);
    }
    // åˆ¤æ–·æ˜¯å¦æœ‰åœ–ç‰‡å…§å®¹
    let hasImageContent = false;
    if (croppedCanvas && !isCanvasAllWhite(croppedCanvas)) {
        hasImageContent = true;
    }
    // åˆ¤æ–·å…§å®¹
    if (!hasImageContent && cleanedText.length === 0) {
        Swal.fire({
            icon: 'warning',
            title: 'æ²’æœ‰å…§å®¹',
            text: 'æ¡†é¸å€åŸŸå…§æ²’æœ‰æ–‡å­—æˆ–åœ–ç‰‡'
        });
        return;
    }
    // åªè¦æœ‰ PDF æ–‡å­—å±¤ï¼Œå°±åªæœ—è®€ç´”æ–‡å­—ï¼Œä¸é€åœ–ç‰‡çµ¦ AI
    if (cleanedText.length > 0) {
        await new Promise((resolve, reject) => {
            sendTextToTTS(cleanedText, () => {
                resolve();
            });
        });
        return;
    }
    // æ²’æœ‰ PDF æ–‡å­—å±¤ï¼Œæ‰é€åœ–ç‰‡çµ¦ AI
    if (hasImageContent) {
        // è¨­ç½®æ¨™è¨˜ï¼Œé˜²æ­¢é‡è¤‡åŸ·è¡Œ
        isImageRecognizing = true;
        
        // åœ¨ iOS ä¸Šï¼Œéœ€è¦åœ¨ç”¨æˆ¶äº¤äº’çš„åŒæ­¥ä¸Šä¸‹æ–‡ä¸­ç«‹å³ç²å–éŸ³é »æ’­æ”¾æ¬Šé™
        // é€šéæ’­æ”¾"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"ä¾†ç²å–æ¬Šé™ï¼ŒåŒæ™‚çµ¦ç”¨æˆ¶æç¤º
        // é˜²æ­¢é‡è¤‡æ’­æ”¾
        if (!isPlayingWaitingMessage) {
            isPlayingWaitingMessage = true;
            sendTextToTTS('åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚', () => {
                console.log('æ’­æ”¾æ¬Šé™å·²ç²å–ï¼Œé–‹å§‹åœ–ç‰‡è¾¨è­˜');
                isPlayingWaitingMessage = false; // æ’­æ”¾å®Œæˆå¾Œé‡ç½®æ¨™è¨˜
            });
        }
        
        try {
            Swal.fire({
                title: 'æ­£åœ¨è¾¨è­˜åœ–ç‰‡',
                text: 'æ­£åœ¨ä½¿ç”¨ AI è¾¨è­˜åœ–ç‰‡å…§å®¹...ï¼ˆGeminiï¼‰',
                allowOutsideClick: false,
                customClass: {
                    popup: 'swal-high-z-index'
                },
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            const aiDescription = await geminiImageDescribe(base64Image);
            Swal.close();
            //console.log('Gemini åŸå§‹å›å‚³:', aiDescription);
            if (aiDescription && aiDescription.length > 0) {
                // ç­‰å¾…"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™ã€‚"æ’­æ”¾å®Œæˆï¼ˆæˆ–è‡³å°‘ç­‰å¾…ä¸€å°æ®µæ™‚é–“ç¢ºä¿æ¬Šé™å·²ç²å–ï¼‰
                // å¦‚æœé‚„åœ¨æ’­æ”¾ï¼Œåœæ­¢å®ƒ
                const audioPlayer = document.getElementById('audioPlayer');
                if (audioPlayer && !audioPlayer.paused) {
                    audioPlayer.pause();
                    audioPlayer.currentTime = 0;
                }
                
                // ç›´æ¥ä½¿ç”¨ Gemini åŸå§‹å›å‚³ï¼Œä¸é€²è¡Œä»»ä½•æ¸…ç†
                // æ­¤æ™‚å·²ç¶“ç²å–äº†æ’­æ”¾æ¬Šé™ï¼Œå¯ä»¥è‡ªå‹•æ’­æ”¾
                sendTextToTTS(aiDescription, () => {
                    console.log('åœ–ç‰‡è¾¨è­˜æ–‡å­—æœ—è®€å®Œæˆ');
                    // è¾¨è­˜å®Œæˆï¼Œé‡ç½®æ¨™è¨˜
                    isImageRecognizing = false;
                    isPlayingWaitingMessage = false;
                });
            } else {
                console.error('Gemini å›å‚³çš„å…§å®¹ç‚ºç©º');
                Swal.fire({
                    icon: 'warning',
                    title: 'è¾¨è­˜çµæœç‚ºç©º',
                    text: 'AI ç„¡æ³•è¾¨è­˜åœ–ç‰‡å…§å®¹'
                });
                // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
                isImageRecognizing = false;
                isPlayingWaitingMessage = false;
            }
        } catch (error) {
            console.error('Gemini è¾¨è­˜å¤±æ•—:', error);
            Swal.fire({
                icon: 'error',
                title: 'è¾¨è­˜å¤±æ•—',
                text: 'AI è¾¨è­˜éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤ã€‚'
            });
            // è¾¨è­˜å¤±æ•—ï¼Œé‡ç½®æ¨™è¨˜
            isImageRecognizing = false;
            isPlayingWaitingMessage = false;
        }
        return;
    }
}

// è¼”åŠ©å‡½æ•¸ï¼šåˆ¤æ–·å…ƒç´ æ˜¯å¦åœ¨æ¡†é¸å€åŸŸå…§
function isInsideFrame(elementRect, frameRect) {
  return (
    elementRect.top >= frameRect.top &&
    elementRect.bottom <= frameRect.bottom &&
    elementRect.left >= frameRect.left &&
    elementRect.right <= frameRect.right
  );
}

// è¼”åŠ©å‡½æ•¸ï¼šè£å‰ªCanvaså€åŸŸ
function cropCanvas(sourceCanvas, cropRect) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  // è€ƒæ…®è¨­å‚™åƒç´ æ¯”é€²è¡Œç²¾ç¢ºè£å‰ª
  const dpr = window.devicePixelRatio || 1;
  const cropX = (cropRect.left - sourceCanvas.getBoundingClientRect().left) * dpr;
  const cropY = (cropRect.top - sourceCanvas.getBoundingClientRect().top) * dpr;
  const cropWidth = cropRect.width * dpr;
  const cropHeight = cropRect.height * dpr;
  
  // è¨­ç½®æ–°Canvaså°ºå¯¸
  canvas.width = cropWidth;
  canvas.height = cropHeight;
  
  // åŸ·è¡Œè£å‰ªæ“ä½œ
  ctx.drawImage(
    sourceCanvas,
    cropX, cropY, cropWidth, cropHeight,
    0, 0, cropWidth, cropHeight
  );
  
  return canvas;
}
  let lastTouchElement = null;
  let isImageRecognizing = false; // é˜²æ­¢åœ–ç‰‡è¾¨è­˜é‡è¤‡åŸ·è¡Œ
  let isPlayingWaitingMessage = false; // é˜²æ­¢"åœ–ç‰‡è¾¨è­˜ä¸­ï¼Œè«‹ç¨å€™"èªéŸ³é‡è¤‡æ’­æ”¾

 function wrapTextInFraTags() {
    const markedContentSpans = document.querySelectorAll('span[role="presentation"]');
    
    markedContentSpans.forEach(span => {
        if (!span.dataset.processed) {
            const text = span.textContent;
            const fragment = document.createDocumentFragment();
            
            for (let char of text) {
                const fra = document.createElement('my-fra');
                fra.textContent = char;
                fra.style.cursor = 'pointer'; // å…§è¯æ¨£å¼
                fra.addEventListener('touchstart', highlightText);
                fra.addEventListener('touchmove', highlightText);
                fra.addEventListener('mousedown', startHighlight); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fra.addEventListener('mousemove', highlightText); // æ–°å¢æ»‘é¼ äº‹ä»¶
                fragment.appendChild(fra);
            }
            
            span.innerHTML = '';
            span.appendChild(fragment);
            span.dataset.processed = 'true';
        }
    });
}
let isMouseDown = false;

function startHighlight(event) {
    isMouseDown = true;
    highlightText(event);
}

document.addEventListener('mouseup', () => {
    isMouseDown = false;
});
     function highlightText(event) {
     
    if (!document.getElementById('touchSelectCheckbox').checked) return; // æª¢æŸ¥æ ¸å–æ–¹å¡Šæ˜¯å¦è¢«é¸ä¸­
    if (event.type === 'mousemove' && !isMouseDown) return; // åªæœ‰åœ¨æŒ‰ä½æ»‘é¼ å·¦éµæ™‚æ‰è§¸ç™¼
    
   event.preventDefault(); // é˜²æ­¢å¹³æ¿å·¦å³æˆ–ä¸Šä¸‹æ²å‹•
    
    let element;
    if (event.type === 'touchstart' || event.type === 'touchmove') {
        const touch = event.touches[0];
        element = document.elementFromPoint(touch.clientX, touch.clientY);
    } else if (event.type === 'mousedown' || event.type === 'mousemove') {
        element = event.target;
    }
    
    if (element && element.tagName === 'MY-FRA') {
        if (element !== lastTouchElement) {
            if (element.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                element.style.backgroundColor = ''; // å–æ¶ˆé¸å–
            } else if (element.style.backgroundColor === 'rgba(255, 255, 0, 0.2)') {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // é‡æ–°é¸å–
                element.dataset.spoken = ''; // å–æ¶ˆå·²ç™¼éŸ³æ¨™è¨˜
            } else {
                element.style.backgroundColor = 'rgba(255, 0, 0, 0.2)'; // æ”¹è®ŠèƒŒæ™¯é¡è‰²
            }
            lastTouchElement = element;
        }
    }
}
        function sendHighlightedText() {
            const highlightedText = [];
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                    if (span.style.backgroundColor === 'rgba(255, 0, 0, 0.2)') {
                        highlightedText.push(span.textContent);
                        span.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // å·²ç™¼éŸ³çš„æ¨™ç¤º
                        span.dataset.spoken = 'true'; // æ¨™è¨˜ç‚ºå·²ç™¼éŸ³
                    }
                }
            }
            
            const cleanedText = highlightedText.join('').replace(/[\r\n]+/g, ' ').replace(/\s+/g, ' ').trim();
            sendTextToTTS(cleanedText, () => {
                // æœ—è®€å®Œæˆå¾Œçš„å›èª¿
                document.getElementById('sendButton').textContent = "æœ—è®€é¸å–æ–‡å­—";
                document.getElementById('sendButton').classList.remove('button-danger');
                document.getElementById('sendButton').classList.add('button-light');
                isReading = false;
            });
        }

        function clearHighlights() {
            const textLayerDivs = document.getElementById('viewerContainer').getElementsByClassName('textLayer');
            
            for (let textLayer of textLayerDivs) {
                const spans = textLayer.getElementsByTagName('my-fra');
                for (let span of spans) {
                window.speechSynthesis.cancel();
                    span.style.backgroundColor = ''; // æ¸…é™¤èƒŒæ™¯é¡è‰²
                    span.dataset.spoken = ''; // æ¸…é™¤å·²ç™¼éŸ³æ¨™è¨˜
                }
            }
        }

        document.getElementById('sendButton').addEventListener('click', sendHighlightedText);
        document.getElementById('clearButton').addEventListener('click', clearHighlights);
        document.getElementById('touchSelectCheckbox').addEventListener('change', function() {
            const isChecked = this.checked;
            clearHighlights();            
            document.getElementById('sendButton').style.display = isChecked ? 'block' : 'none';
            document.getElementById('clearButton').style.display = isChecked ? 'block' : 'none';                        
            document.getElementById('select-all-text').style.display = isChecked ? 'none' : 'block';            
            document.getElementById('movable-frame').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-bottom').style.display = isChecked ? 'none' : 'block';
            document.getElementById('resize-right').style.display = isChecked ? 'none' : 'block';
            document.getElementById('read-button').style.display = isChecked ? 'none' : 'block';
            
            if (!isChecked) {
            updateButtonPositions();            
            }
        });
        wrapTextInFraTags();
        
        document.getElementById('sendButton').addEventListener('click', function() {
    if (isReading) {
        // å–æ¶ˆæœ—è®€
        window.speechSynthesis.cancel();
        this.textContent = "æœ—è®€é¸å–æ–‡å­—";
        this.classList.remove('button-danger');
        this.classList.add('button-light');
        isReading = false;
    } else {
        // é–‹å§‹æœ—è®€
        sendHighlightedText();
        this.textContent = "å–æ¶ˆæœ—è®€";
        this.classList.remove('button-light');
        this.classList.add('button-danger');
        isReading = true;
    }
});
  
// ä½¿ç”¨ MutationObserver ç›£è½ DOM è®ŠåŒ–
const observer = new MutationObserver((mutationsList, observer) => {
    for (let mutation of mutationsList) {
        if (mutation.type === 'childList') {
            wrapTextInFraTags();
        }
    }
});

// é…ç½® MutationObserver ç›£è½çš„ç›®æ¨™ç¯€é»å’Œé¸é …
const config = { childList: true, subtree: true };

// ç›£è½æ•´å€‹ document çš„è®ŠåŒ–
observer.observe(document, config);

// ç¢ºä¿åœ¨ DOM å®Œå…¨åŠ è¼‰å¾ŒåŸ·è¡Œ
document.addEventListener('DOMContentLoaded', wrapTextInFraTags);
document.getElementById('resize-bottom').addEventListener('mousedown', (e) => resizeFrame(e, 'bottom'));
document.getElementById('resize-right').addEventListener('mousedown', (e) => resizeFrame(e, 'right'));

document.getElementById('resize-bottom').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'bottom'));
document.getElementById('resize-right').addEventListener('touchstart', (e) => resizeFrameTouch(e, 'right'));

function resizeFrame(e, direction) {
  e.stopPropagation();
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  let startX = e.clientX;
  let startY = e.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    if (direction === 'bottom') {
      let newHeight = startHeight + (e.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (e.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('mousemove', doDrag);
    document.removeEventListener('mouseup', stopDrag);
  }

  document.addEventListener('mousemove', doDrag);
  document.addEventListener('mouseup', stopDrag);
}

function resizeFrameTouch(e, direction) {
  e.stopPropagation();
  e.preventDefault(); // Prevent scrolling
  let startWidth = frame.offsetWidth;
  let startHeight = frame.offsetHeight;
  const touch = e.touches[0];
  let startX = touch.clientX;
  let startY = touch.clientY;
  let startTop = frame.offsetTop;
  let startLeft = frame.offsetLeft;

  function doDrag(e) {
    const touch = e.touches[0];
    if (direction === 'bottom') {
      let newHeight = startHeight + (touch.clientY - startY);
      frame.style.height = `${newHeight}px`;
    } else if (direction === 'right') {
      let newWidth = startWidth + (touch.clientX - startX);
      frame.style.width = `${newWidth}px`;
    }
    updateButtonPositions();
  }

  function stopDrag() {
    document.removeEventListener('touchmove', doDrag);
    document.removeEventListener('touchend', stopDrag);
  }

  document.addEventListener('touchmove', doDrag);
  document.addEventListener('touchend', stopDrag);
}

updateButtonPositions();
});
// ç²å–æ¡†å…ƒç´ 
const frame = document.getElementById('movable-frame');

function showPage(page_no) {
    __PAGE_RENDERING_IN_PROGRESS = 1;
    __CURRENT_PAGE = page_no;
    $("#pdf-next, #pdf-prev").attr('disabled', 'disabled');
    $("#pdf-canvas").hide();
    $("#page-loader").show();
    $("#pdf-current-page").text(page_no);
    __PDF_DOC.getPage(page_no).then(function (page) {
        let viewport = page.getViewport({ scale: 1 });
        let scale = __CANVAS.width / viewport.width;
        viewport = page.getViewport({ scale: scale });
        __CANVAS.height = viewport.height;
        var renderContext = {
            canvasContext: __CANVAS_CTX,
            viewport: viewport
        };
        page.render(renderContext).promise.then(function () {
            __PAGE_RENDERING_IN_PROGRESS = 0;
            $("#pdf-next, #pdf-prev").removeAttr('disabled');
            $("#pdf-canvas").show();
            $("#page-loader").hide();
            return page.getTextContent();
        }).then(function (textContent) {
            var canvas_offset = $("#pdf-canvas").offset();
            $("#text-layer").html('');
            document.getElementById('text-layer').style.setProperty('--scale-factor', viewport.scale);
            $("#text-layer").css({ left: canvas_offset.left + 'px', top: canvas_offset.top + 'px' });
            PDFJS.renderTextLayer({
                textContentSource: textContent,
                container: $("#text-layer").get(0),
                viewport: viewport,
                textDivs: []
            });
            console.log('Text Layer Content:', textContent);
        });
    });
}




     // æ›´æ–°èªé€Ÿé¡¯ç¤º
function updateRate(value) {
    const adjustedValue = Math.max(-50, Math.min(50, Number(value)));
    const speedLabel = document.getElementById('speedLabel');
    const speedPercent = document.getElementById('speedPercent');
    
    if (adjustedValue === 0) {
        speedLabel.textContent = '';
        speedPercent.textContent = '0%';
    } else if (adjustedValue > 0) {
        speedLabel.textContent = 'èªé€ŸåŠ ';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    } else {
        speedLabel.textContent = 'èªé€Ÿæ¸›';
        speedPercent.textContent = Math.abs(adjustedValue) + '%';
    }
}

// è¨­ç½®åˆå§‹èªé€Ÿ
document.getElementById('speakSpeed').value = -30;
updateRate(-30);

// API KEY ç®¡ç†åŠŸèƒ½
let qrStream = null;
let qrScanInterval = null;

// æ‰“é–‹ API KEY è¨­å®šæ¨¡æ…‹è¦–çª—
document.getElementById('apiKeySettingsButton').addEventListener('click', async () => {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const apiKeyInput = document.getElementById('apiKeyInput');
    
    // è¼‰å…¥ç¾æœ‰çš„ API KEYï¼ˆä¸é¡¯ç¤ºå®Œæ•´ï¼Œåªé¡¯ç¤ºå‰å¾Œå¹¾ä½ï¼‰
    const existingKey = await loadApiKeyFromIndexedDB();
    if (existingKey) {
        const maskedKey = existingKey.length > 8 
            ? existingKey.substring(0, 4) + '...' + existingKey.substring(existingKey.length - 4)
            : '***';
        apiKeyInput.placeholder = `å·²è¨­å®šï¼š${maskedKey}`;
    } else {
        apiKeyInput.placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
    }
    apiKeyInput.value = '';
    
    modal.style.display = 'block';
    overlay.style.display = 'block';
});

// é—œé–‰æ¨¡æ…‹è¦–çª—
function closeApiKeyModal() {
    const modal = document.getElementById('apiKeyModal');
    const overlay = document.getElementById('apiKeyModalOverlay');
    const qrContainer = document.getElementById('qrScannerContainer');
    
    modal.style.display = 'none';
    overlay.style.display = 'none';
    qrContainer.style.display = 'none';
    
    // åœæ­¢ QR code æƒæ
    stopQRScan();
}

document.getElementById('cancelApiKeyButton').addEventListener('click', closeApiKeyModal);
document.getElementById('apiKeyModalOverlay').addEventListener('click', closeApiKeyModal);

// å„²å­˜ API KEY
document.getElementById('saveApiKeyButton').addEventListener('click', async () => {
    const apiKeyInput = document.getElementById('apiKeyInput');
    const apiKey = apiKeyInput.value.trim();
    
    if (!apiKey) {
        Swal.fire({
            icon: 'warning',
            title: 'è¼¸å…¥ç‚ºç©º',
            text: 'è«‹è¼¸å…¥ API KEY æˆ–æƒæ QR Code'
        });
        return;
    }
    
    try {
        await saveApiKeyToIndexedDB(apiKey);
        Swal.fire({
            icon: 'success',
            title: 'å„²å­˜æˆåŠŸ',
            text: 'API KEY å·²å„²å­˜',
            timer: 1500,
            showConfirmButton: false
        });
        closeApiKeyModal();
    } catch (error) {
        console.error('å„²å­˜ API KEY å¤±æ•—ï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'å„²å­˜å¤±æ•—',
            text: 'ç„¡æ³•å„²å­˜ API KEYï¼Œè«‹é‡è©¦'
        });
    }
});

// åˆªé™¤ API KEY
document.getElementById('deleteApiKeyButton').addEventListener('click', async () => {
    // ç¢ºèªåˆªé™¤
    const result = await Swal.fire({
        icon: 'warning',
        title: 'ç¢ºèªåˆªé™¤',
        text: 'ç¢ºå®šè¦åˆªé™¤ç¾æœ‰çš„ API KEY å—ï¼Ÿ',
        showCancelButton: true,
        confirmButtonText: 'ç¢ºå®šåˆªé™¤',
        cancelButtonText: 'å–æ¶ˆ',
        confirmButtonColor: '#dc3545',
        cancelButtonColor: '#6c757d',
        customClass: {
            popup: 'swal-high-z-index',
            container: 'swal-high-z-index'
        }
    });
    
    if (result.isConfirmed) {
        try {
            await deleteApiKeyFromIndexedDB();
            // æ¸…ç©ºè¼¸å…¥æ¡†å’Œæç¤º
            document.getElementById('apiKeyInput').value = '';
            document.getElementById('apiKeyInput').placeholder = 'è«‹è¼¸å…¥æˆ–æƒæ QR Code';
            
            Swal.fire({
                icon: 'success',
                title: 'åˆªé™¤æˆåŠŸ',
                text: 'API KEY å·²åˆªé™¤',
                timer: 1500,
                showConfirmButton: false,
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
            closeApiKeyModal();
        } catch (error) {
            console.error('åˆªé™¤ API KEY å¤±æ•—ï¼š', error);
            Swal.fire({
                icon: 'error',
                title: 'åˆªé™¤å¤±æ•—',
                text: 'ç„¡æ³•åˆªé™¤ API KEYï¼Œè«‹é‡è©¦',
                customClass: {
                    popup: 'swal-high-z-index',
                    container: 'swal-high-z-index'
                }
            });
        }
    }
});

// åœæ­¢ QR code æƒæ
function stopQRScan() {
    if (qrStream) {
        qrStream.getTracks().forEach(track => track.stop());
        qrStream = null;
    }
    if (qrScanInterval) {
        clearInterval(qrScanInterval);
        qrScanInterval = null;
    }
    const qrVideo = document.getElementById('qrVideo');
    const qrContainer = document.getElementById('qrScannerContainer');
    qrVideo.srcObject = null;
    qrContainer.style.display = 'none';
}

// é–‹å§‹ QR code æƒæ
document.getElementById('scanQRButton').addEventListener('click', async () => {
    const qrContainer = document.getElementById('qrScannerContainer');
    const qrVideo = document.getElementById('qrVideo');
    const qrCanvas = document.getElementById('qrCanvas');
    
    try {
        // è«‹æ±‚ç›¸æ©Ÿæ¬Šé™
        qrStream = await navigator.mediaDevices.getUserMedia({ 
            video: { 
                facingMode: 'environment' // å„ªå…ˆä½¿ç”¨å¾Œç½®ç›¸æ©Ÿ
            } 
        });
        
        qrVideo.srcObject = qrStream;
        qrVideo.setAttribute('playsinline', true);
        qrContainer.style.display = 'block';
        
        await qrVideo.play();
        
        const videoWidth = qrVideo.videoWidth;
        const videoHeight = qrVideo.videoHeight;
        qrCanvas.width = videoWidth;
        qrCanvas.height = videoHeight;
        
        const ctx = qrCanvas.getContext('2d');
        
        // é–‹å§‹æƒæ
        qrScanInterval = setInterval(() => {
            if (qrVideo.readyState === qrVideo.HAVE_ENOUGH_DATA) {
                ctx.drawImage(qrVideo, 0, 0, videoWidth, videoHeight);
                const imageData = ctx.getImageData(0, 0, videoWidth, videoHeight);
                const code = jsQR(imageData.data, imageData.width, imageData.height);
                
                if (code) {
                    // æ‰¾åˆ° QR codeï¼Œå¡«å…¥ API KEY
                    document.getElementById('apiKeyInput').value = code.data;
                    stopQRScan();
                    Swal.fire({
                        icon: 'success',
                        title: 'æƒææˆåŠŸ',
                        text: 'QR Code å·²è®€å–',
                        timer: 1500,
                        showConfirmButton: false
                    });
                }
            }
        }, 100);
        
    } catch (error) {
        console.error('ç„¡æ³•è¨ªå•ç›¸æ©Ÿï¼š', error);
        Swal.fire({
            icon: 'error',
            title: 'ç„¡æ³•è¨ªå•ç›¸æ©Ÿ',
            text: 'è«‹å…è¨±ç€è¦½å™¨è¨ªå•ç›¸æ©Ÿæ¬Šé™ï¼Œæˆ–æ‰‹å‹•è¼¸å…¥ API KEY'
        });
    }
});

// åœæ­¢æƒææŒ‰éˆ•
document.getElementById('stopScanButton').addEventListener('click', stopQRScan);
        
</script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@latest/dist/tesseract.min.js"></script>
</body>
</html>
